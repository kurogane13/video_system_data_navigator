<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Video System | Data Navigator - Upload Dashboard</title>
    <meta name="cache-control" content="no-cache">
    <meta name="expires" content="0">
    <meta name="pragma" content="no-cache">
    <style>
        * { box-sizing: border-box; margin: 0; padding: 0; }
        
        body {
            background: #000000;
            color: white;
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            overflow-x: hidden;
            min-height: 100vh;
            position: relative;
        }
        
        /* Space Travel Starfield */
        body::before {
            content: '';
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: 
                /* Center emerging stars - half size and pure white */
                radial-gradient(2px circle at 50% 50%, rgba(255,255,255,1), transparent),
                radial-gradient(1px circle at 51% 49%, rgba(255,255,255,1), transparent),
                radial-gradient(2px circle at 49% 51%, rgba(255,255,255,1), transparent),
                radial-gradient(2px circle at 52% 48%, rgba(255,255,255,1), transparent),
                radial-gradient(1px circle at 48% 52%, rgba(255,255,255,1), transparent),
                radial-gradient(2px circle at 50.5% 49.5%, rgba(255,255,255,1), transparent),
                radial-gradient(1px circle at 49.5% 50.5%, rgba(255,255,255,1), transparent),
                radial-gradient(2px circle at 51.5% 48.5%, rgba(255,255,255,1), transparent),
                radial-gradient(2px circle at 48.5% 51.5%, rgba(255,255,255,1), transparent),
                radial-gradient(1px circle at 52.5% 47.5%, rgba(255,255,255,1), transparent),
                
                /* Upper quadrants - half size and pure white */
                radial-gradient(3px circle at 30% 20%, rgba(255,255,255,1), transparent),
                radial-gradient(2px circle at 70% 20%, rgba(255,255,255,1), transparent),
                radial-gradient(3px circle at 20% 30%, rgba(255,255,255,1), transparent),
                radial-gradient(2px circle at 80% 30%, rgba(255,255,255,1), transparent),
                radial-gradient(2px circle at 60% 10%, rgba(255,255,255,1), transparent),
                radial-gradient(3px circle at 40% 15%, rgba(255,255,255,1), transparent),
                radial-gradient(2px circle at 15% 40%, rgba(255,255,255,1), transparent),
                radial-gradient(3px circle at 85% 40%, rgba(255,255,255,1), transparent),
                radial-gradient(2px circle at 35% 25%, rgba(255,255,255,1), transparent),
                radial-gradient(3px circle at 65% 25%, rgba(255,255,255,1), transparent),
                radial-gradient(2px circle at 25% 35%, rgba(255,255,255,1), transparent),
                radial-gradient(3px circle at 75% 35%, rgba(255,255,255,1), transparent),
                radial-gradient(2px circle at 45% 8%, rgba(255,255,255,1), transparent),
                radial-gradient(3px circle at 55% 12%, rgba(255,255,255,1), transparent),
                radial-gradient(2px circle at 12% 45%, rgba(255,255,255,1), transparent),
                radial-gradient(3px circle at 88% 45%, rgba(255,255,255,1), transparent),
                
                /* Lower quadrants - half size and pure white */
                radial-gradient(3px circle at 30% 80%, rgba(255,255,255,1), transparent),
                radial-gradient(2px circle at 70% 80%, rgba(255,255,255,1), transparent),
                radial-gradient(3px circle at 20% 70%, rgba(255,255,255,1), transparent),
                radial-gradient(2px circle at 80% 70%, rgba(255,255,255,1), transparent),
                radial-gradient(2px circle at 60% 90%, rgba(255,255,255,1), transparent),
                radial-gradient(3px circle at 40% 85%, rgba(255,255,255,1), transparent),
                radial-gradient(2px circle at 15% 60%, rgba(255,255,255,1), transparent),
                radial-gradient(3px circle at 85% 60%, rgba(255,255,255,1), transparent),
                radial-gradient(2px circle at 35% 75%, rgba(255,255,255,1), transparent),
                radial-gradient(3px circle at 65% 75%, rgba(255,255,255,1), transparent),
                radial-gradient(2px circle at 25% 65%, rgba(255,255,255,1), transparent),
                radial-gradient(3px circle at 75% 65%, rgba(255,255,255,1), transparent),
                radial-gradient(2px circle at 45% 92%, rgba(255,255,255,1), transparent),
                radial-gradient(3px circle at 55% 88%, rgba(255,255,255,1), transparent),
                radial-gradient(2px circle at 12% 55%, rgba(255,255,255,1), transparent),
                radial-gradient(3px circle at 88% 55%, rgba(255,255,255,1), transparent),
                
                /* Edge stars - half size and pure white */
                radial-gradient(4px circle at 5% 25%, rgba(255,255,255,1), transparent),
                radial-gradient(3px circle at 95% 25%, rgba(255,255,255,1), transparent),
                radial-gradient(4px circle at 5% 75%, rgba(255,255,255,1), transparent),
                radial-gradient(3px circle at 95% 75%, rgba(255,255,255,1), transparent),
                radial-gradient(5px circle at 25% 5%, rgba(255,255,255,1), transparent),
                radial-gradient(4px circle at 75% 5%, rgba(255,255,255,1), transparent),
                radial-gradient(5px circle at 25% 95%, rgba(255,255,255,1), transparent),
                radial-gradient(4px circle at 75% 95%, rgba(255,255,255,1), transparent),
                radial-gradient(3px circle at 2% 50%, rgba(255,255,255,1), transparent),
                radial-gradient(4px circle at 98% 50%, rgba(255,255,255,1), transparent),
                radial-gradient(4px circle at 50% 2%, rgba(255,255,255,1), transparent),
                radial-gradient(5px circle at 50% 98%, rgba(255,255,255,1), transparent),
                radial-gradient(3px circle at 8% 15%, rgba(255,255,255,1), transparent),
                radial-gradient(3px circle at 92% 15%, rgba(255,255,255,1), transparent),
                radial-gradient(3px circle at 8% 85%, rgba(255,255,255,1), transparent),
                radial-gradient(3px circle at 92% 85%, rgba(255,255,255,1), transparent);
            
            background-repeat: no-repeat;
            background-size: 100% 100%;
            animation: space-travel 3.2s linear infinite;
            pointer-events: none;
            z-index: -2;
            opacity: 1;
        }
        
        body::after {
            content: '';
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: 
                /* Additional center stars - half size and pure white */
                radial-gradient(1px circle at 49% 49%, rgba(255,255,255,1), transparent),
                radial-gradient(2px circle at 51% 51%, rgba(255,255,255,1), transparent),
                radial-gradient(1px circle at 50.5% 49.5%, rgba(255,255,255,1), transparent),
                radial-gradient(2px circle at 49.5% 50.5%, rgba(255,255,255,1), transparent),
                radial-gradient(2px circle at 51.5% 48.5%, rgba(255,255,255,1), transparent),
                radial-gradient(1px circle at 48.2% 50.8%, rgba(255,255,255,1), transparent),
                radial-gradient(2px circle at 51.8% 49.2%, rgba(255,255,255,1), transparent),
                radial-gradient(2px circle at 49.8% 49.2%, rgba(255,255,255,1), transparent),
                radial-gradient(1px circle at 50.2% 50.8%, rgba(255,255,255,1), transparent),
                radial-gradient(2px circle at 47.5% 52.5%, rgba(255,255,255,1), transparent),
                
                /* Fill more areas - half size and pure white */
                radial-gradient(2px circle at 35% 35%, rgba(255,255,255,1), transparent),
                radial-gradient(3px circle at 65% 35%, rgba(255,255,255,1), transparent),
                radial-gradient(2px circle at 35% 65%, rgba(255,255,255,1), transparent),
                radial-gradient(2px circle at 65% 65%, rgba(255,255,255,1), transparent),
                radial-gradient(3px circle at 25% 50%, rgba(255,255,255,1), transparent),
                radial-gradient(2px circle at 75% 50%, rgba(255,255,255,1), transparent),
                radial-gradient(2px circle at 50% 25%, rgba(255,255,255,1), transparent),
                radial-gradient(3px circle at 50% 75%, rgba(255,255,255,1), transparent),
                radial-gradient(1px circle at 30% 40%, rgba(255,255,255,1), transparent),
                radial-gradient(2px circle at 70% 40%, rgba(255,255,255,1), transparent),
                radial-gradient(2px circle at 40% 30%, rgba(255,255,255,1), transparent),
                radial-gradient(3px circle at 60% 70%, rgba(255,255,255,1), transparent),
                radial-gradient(1px circle at 20% 60%, rgba(255,255,255,1), transparent),
                radial-gradient(2px circle at 80% 40%, rgba(255,255,255,1), transparent),
                radial-gradient(2px circle at 40% 80%, rgba(255,255,255,1), transparent),
                radial-gradient(3px circle at 60% 20%, rgba(255,255,255,1), transparent),
                
                /* More scattered stars - half size and pure white */
                radial-gradient(2px circle at 10% 20%, rgba(255,255,255,1), transparent),
                radial-gradient(3px circle at 90% 20%, rgba(255,255,255,1), transparent),
                radial-gradient(2px circle at 10% 80%, rgba(255,255,255,1), transparent),
                radial-gradient(3px circle at 90% 80%, rgba(255,255,255,1), transparent),
                radial-gradient(4px circle at 20% 10%, rgba(255,255,255,1), transparent),
                radial-gradient(3px circle at 80% 10%, rgba(255,255,255,1), transparent),
                radial-gradient(4px circle at 20% 90%, rgba(255,255,255,1), transparent),
                radial-gradient(3px circle at 80% 90%, rgba(255,255,255,1), transparent),
                radial-gradient(2px circle at 15% 30%, rgba(255,255,255,1), transparent),
                radial-gradient(3px circle at 85% 30%, rgba(255,255,255,1), transparent),
                radial-gradient(2px circle at 15% 70%, rgba(255,255,255,1), transparent),
                radial-gradient(3px circle at 85% 70%, rgba(255,255,255,1), transparent),
                radial-gradient(1px circle at 30% 18%, rgba(255,255,255,1), transparent),
                radial-gradient(2px circle at 70% 18%, rgba(255,255,255,1), transparent),
                radial-gradient(2px circle at 30% 82%, rgba(255,255,255,1), transparent),
                radial-gradient(3px circle at 70% 82%, rgba(255,255,255,1), transparent),
                
                /* Corner stars - half size and pure white */
                radial-gradient(5px circle at 0% 0%, rgba(255,255,255,1), transparent),
                radial-gradient(4px circle at 100% 0%, rgba(255,255,255,1), transparent),
                radial-gradient(5px circle at 0% 100%, rgba(255,255,255,1), transparent),
                radial-gradient(4px circle at 100% 100%, rgba(255,255,255,1), transparent),
                radial-gradient(3px circle at 3% 3%, rgba(255,255,255,1), transparent),
                radial-gradient(4px circle at 97% 3%, rgba(255,255,255,1), transparent),
                radial-gradient(3px circle at 3% 97%, rgba(255,255,255,1), transparent),
                radial-gradient(4px circle at 97% 97%, rgba(255,255,255,1), transparent);
            
            background-repeat: no-repeat;
            background-size: 100% 100%;
            animation: space-travel 2.4s linear infinite;
            pointer-events: none;
            z-index: -1;
            opacity: 0.8;
        }
        
        @keyframes space-travel {
            0% { 
                transform: scale(0.2) translateZ(0);
                opacity: 1;
            }
            5% {
                transform: scale(0.3) translateZ(0);
                opacity: 1;
            }
            10% {
                transform: scale(0.4) translateZ(0);
                opacity: 1;
            }
            15% {
                transform: scale(0.5) translateZ(0);
                opacity: 1;
            }
            20% {
                transform: scale(0.6) translateZ(0);
                opacity: 1;
            }
            25% {
                transform: scale(0.7) translateZ(0);
                opacity: 1;
            }
            30% {
                transform: scale(0.8) translateZ(0);
                opacity: 1;
            }
            35% {
                transform: scale(0.9) translateZ(0);
                opacity: 1;
            }
            40% {
                transform: scale(1.0) translateZ(0);
                opacity: 1;
            }
            45% {
                transform: scale(1.2) translateZ(0);
                opacity: 1;
            }
            50% {
                transform: scale(1.4) translateZ(0);
                opacity: 1;
            }
            55% {
                transform: scale(1.6) translateZ(0);
                opacity: 1;
            }
            60% {
                transform: scale(1.8) translateZ(0);
                opacity: 1;
            }
            65% {
                transform: scale(2.0) translateZ(0);
                opacity: 1;
            }
            70% {
                transform: scale(2.2) translateZ(0);
                opacity: 1;
            }
            75% {
                transform: scale(2.4) translateZ(0);
                opacity: 1;
            }
            80% {
                transform: scale(2.6) translateZ(0);
                opacity: 1;
            }
            85% {
                transform: scale(2.8) translateZ(0);
                opacity: 1;
            }
            90% {
                transform: scale(3.0) translateZ(0);
                opacity: 1;
            }
            95% {
                transform: scale(3.2) translateZ(0);
                opacity: 1;
            }
            100% {
                transform: scale(0.2) translateZ(0);
                opacity: 1;
            }
        }
        
        .container {
            max-width: 1400px;
            margin: 0 auto;
            padding: 20px;
        }
        
        .header {
            text-align: center;
            display: flex;
            align-items: center;
            gap: 20px;
            margin-bottom: 30px;
            min-height: 120px;
            background: 
                linear-gradient(135deg, rgba(71, 85, 105, 0.2), rgba(51, 65, 85, 0.3)),
                radial-gradient(ellipse at center, rgba(100, 116, 139, 0.1), transparent);
            padding: 25px;
            border-radius: 20px;
            border: 2px solid rgba(100, 116, 139, 0.6);
            position: relative;
            backdrop-filter: blur(20px);
            box-shadow: 
                0 8px 32px rgba(0, 0, 0, 0.4),
                inset 0 1px 0 rgba(148, 163, 184, 0.2);
        }
        
        .header::before {
            content: '';
            position: absolute;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background: linear-gradient(45deg, transparent, rgba(148, 163, 184, 0.1), transparent);
            border-radius: 18px;
            animation: header-shimmer 3s ease-in-out infinite;
            pointer-events: none;
        }
        
        @keyframes header-shimmer {
            0%, 100% { opacity: 0; }
            50% { opacity: 1; }
        }

        @keyframes blinkMessage {
            0%, 50% { opacity: 1; }
            50.01%, 100% { opacity: 0; }
        }
        
        .header h1 {
            color: #e2e8f0;
            font-size: 2.5em;
            margin: -15px 0 10px 0;
            text-shadow: 
                0 0 20px rgba(148, 163, 184, 0.5),
                2px 2px 8px rgba(0, 0, 0, 0.8);
            font-weight: 700;
            letter-spacing: 1px;
            position: relative;
            z-index: 1;
        }
        
        .system-ip-display {
            position: absolute;
            left: 50%;
            bottom: 0px;
            transform: translateX(-50%);
            max-width: 450px;
            background: rgba(0, 20, 0, 0.7);
            border: 1px solid #00ffff;
            padding: 8px 16px;
            font-family: 'Courier New', monospace;
            font-size: 14px;
            font-weight: normal;
            color: #00ffff;
            text-align: left;
            backdrop-filter: blur(3px);
            border-radius: 4px;
            box-shadow: 0 1px 5px rgba(0, 255, 0, 0.3);
            opacity: 0.95;
            z-index: 10;
        }
        
        @keyframes ip-glow {
            0% { box-shadow: 0 0 10px rgba(0, 255, 255, 0.3); }
            100% { box-shadow: 0 0 15px rgba(0, 255, 255, 0.6); }
        }
        
        .header-buttons {
            position: absolute;
            top: 15px;
            right: 15px;
            display: flex;
            gap: 15px;
        }
        
        .help-btn, .logout-btn, .upload-btn {
            background: #000000;
            color: #28a745;
            border: 2px solid #28a745;
            padding: 8px 16px;
            border-radius: 20px;
            cursor: pointer;
            font-size: 12px;
            font-weight: bold;
            transition: all 0.3s ease;
        }
        
        .system-specs-btn {
            background: black;
            color: #00ff00;
            border: 2px solid #00ff00;
            padding: 12px 20px;
            border-radius: 25px;
            cursor: pointer;
            font-size: 14px;
            font-weight: bold;
            transition: all 0.3s ease;
            text-shadow: 0 0 5px #00ff00;
            box-shadow: 0 0 10px rgba(0, 255, 0, 0.3);
        }
        
        .system-specs-btn:hover {
            transform: scale(1.1);
            box-shadow: 0 0 20px rgba(0, 255, 0, 0.6), 0 0 40px rgba(0, 255, 0, 0.4);
            text-shadow: 0 0 10px #00ff00;
        }
        
        .logout-btn {
            background: #000000;
            color: #dc3545;
            border-color: #dc3545;
        }
        
        .upload-btn {
            background: #000000;
            color: #17a2b8;
            border-color: #17a2b8;
        }
        
        .help-btn:hover {
            transform: translateY(-1px);
            box-shadow: 0 0 15px rgba(40, 167, 69, 0.6), 0 0 25px rgba(40, 167, 69, 0.4);
        }
        
        .logout-btn:hover {
            transform: translateY(-1px);
            box-shadow: 0 0 15px rgba(220, 53, 69, 0.6), 0 0 25px rgba(220, 53, 69, 0.4);
        }
        
        .upload-btn:hover {
            transform: translateY(-1px);
            box-shadow: 0 0 15px rgba(23, 162, 184, 0.6), 0 0 25px rgba(23, 162, 184, 0.4);
        }
        
        /* Futuristic Toggle System */
        .toggle-container {
            display: flex;
            justify-content: center;
            margin-bottom: 30px;
            gap: 12px;
            padding: 0;
            background: transparent;
            border: none;
            box-shadow: none;
            position: relative;
            flex-wrap: nowrap;
            overflow-x: auto;
            min-height: 70px;
            align-items: center;
        }
        
        
        @keyframes toggle-glow {
            0%, 100% { transform: translateX(-100%); opacity: 0; }
            50% { transform: translateX(100%); opacity: 1; }
        }
        
        @keyframes successPulse {
            0% { 
                transform: scale(0.3);
                opacity: 0;
            }
            50% {
                transform: scale(1.05);
                opacity: 1;
            }
            100% {
                transform: scale(1);
                opacity: 1;
            }
        }
        
        @keyframes errorShake {
            0%, 100% { transform: translateX(0); }
            10%, 30%, 50%, 70%, 90% { transform: translateX(-5px); }
            20%, 40%, 60%, 80% { transform: translateX(5px); }
        }
        
        @keyframes bounce {
            0%, 100% { 
                transform: translateY(0) scale(1);
            }
            50% { 
                transform: translateY(-10px) scale(1.1);
            }
        }
        
        @keyframes modalFadeIn {
            0% { 
                opacity: 0;
                transform: scale(0.9);
            }
            100% { 
                opacity: 1;
                transform: scale(1);
            }
        }
        
        .toggle-btn {
            background: linear-gradient(145deg, #000000, #1a1a1a);
            color: white;
            border: 2px solid #00ffff;
            padding: 18px 28px;
            border-radius: 25px;
            cursor: pointer;
            font-size: 16px;
            font-weight: bold;
            transition: all 0.3s ease;
            box-shadow: 0 4px 15px rgba(0, 255, 255, 0.3), inset 0 0 10px rgba(0, 255, 255, 0.1);
            white-space: nowrap;
            text-shadow: 0 0 3px rgba(255, 255, 255, 0.3);
            display: flex;
            align-items: center;
            gap: 10px;
            text-transform: none;
            letter-spacing: normal;
            min-width: 140px;
            justify-content: center;
        }
        
        
        
        .toggle-btn.active {
            background: linear-gradient(145deg, #1a1a1a, #333333);
            color: white;
            transform: translateY(-2px);
            box-shadow: 0 8px 35px rgba(0, 255, 255, 0.6), inset 0 0 20px rgba(0, 255, 255, 0.3);
            border: 2px solid #00dddd;
            text-shadow: 0 0 8px rgba(255, 255, 255, 0.8);
        }
        
        
        .toggle-btn:hover:not(.active) {
            background: linear-gradient(145deg, #1a1a1a, #333333);
            transform: translateY(-2px);
            box-shadow: 0 8px 25px rgba(0, 255, 255, 0.5), inset 0 0 15px rgba(0, 255, 255, 0.2);
            border: 2px solid #00dddd;
            color: white;
            text-shadow: 0 0 5px rgba(255, 255, 255, 0.5);
        }
        
        .main-layout {
            display: grid;
            grid-template-columns: 0.75fr 0.75fr;
            gap: 25px;
            height: 80vh;
        }
        
        .left-panel {
            background: rgba(0, 0, 0, 0.7);
            border-radius: 15px;
            border: 2px solid #333;
            padding: 0;
            overflow: hidden;
            backdrop-filter: blur(10px);
            box-shadow: 0 10px 30px rgba(0,0,0,0.5);
            min-width: 300px;
        }
        
        .panel-header {
            background: 
                linear-gradient(135deg, #001a1a, #003333),
                linear-gradient(45deg, rgba(0, 255, 255, 0.1), rgba(0, 255, 255, 0.05)),
                radial-gradient(ellipse at center, rgba(0, 255, 255, 0.2), transparent);
            color: #00ffff;
            padding: 25px;
            text-align: center;
            display: flex;
            align-items: center;
            gap: 20px;
            font-weight: 700;
            font-size: 1.4em;
            border: 2px solid #00ffff;
            border-radius: 15px;
            font-family: 'Orbitron', monospace;
            text-shadow: 0 0 10px rgba(0, 255, 255, 0.8);
            box-shadow: 0 0 20px rgba(0, 255, 255, 0.4), inset 0 2px 8px rgba(0, 255, 255, 0.1);
            position: relative;
            overflow: hidden;
            justify-content: center;
            gap: 15px;
            box-shadow: 
                0 8px 32px rgba(0, 0, 0, 0.4),
                0 0 20px rgba(100, 116, 139, 0.3),
                inset 0 1px 0 rgba(203, 213, 225, 0.2);
            position: relative;
            overflow: hidden;
            text-transform: uppercase;
            letter-spacing: 1.2px;
            text-shadow: 
                0 0 10px rgba(241, 245, 249, 0.5),
                2px 2px 4px rgba(0, 0, 0, 0.8);
        }
        
        .panel-header::before {
            content: '';
            position: absolute;
            top: 0;
            left: -100%;
            width: 100%;
            height: 100%;
            background: linear-gradient(90deg, 
                transparent, 
                rgba(203, 213, 225, 0.3), 
                transparent);
            animation: panel-sweep 6s ease-in-out infinite;
        }
        
        @keyframes panel-sweep {
            0% { left: -100%; }
            50% { left: 100%; }
            100% { left: -100%; }
        }
        
        .panel-header::after {
            content: '';
            position: absolute;
            bottom: 0;
            left: 0;
            right: 0;
            height: 2px;
            background: linear-gradient(90deg, 
                transparent, 
                rgba(148, 163, 184, 0.6), 
                rgba(203, 213, 225, 0.8), 
                rgba(148, 163, 184, 0.6), 
                transparent);
            animation: header-line-pulse 3s ease-in-out infinite;
        }
        
        @keyframes header-line-pulse {
            0%, 100% { opacity: 0.3; }
            50% { opacity: 1; }
        }
        
        .panel-content {
            padding: 20px;
            height: calc(100% - 80px);
            overflow-y: auto;
        }
        
        /* Content sections */
        .content-section {
            display: none;
            height: 100%;
        }
        
        .content-section.active {
            display: block;
        }
        
        /* Upload Section Styles */
        .upload-section {
            background: rgba(0, 0, 0, 0.7);
            border-radius: 15px;
            border: 2px solid #333;
            padding: 20px;
            display: flex;
            flex-direction: column;
            backdrop-filter: blur(10px);
            box-shadow: 0 10px 30px rgba(0,0,0,0.5);
        }
        
        .upload-drop-zone {
            border: 3px dashed #17a2b8;
            border-radius: 15px;
            padding: 50px;
            text-align: center;
            display: flex;
            flex-direction: column;
            gap: 15px;
            transition: all 0.3s ease;
            background: rgba(23, 162, 184, 0.1);
            margin-bottom: 20px;
            position: relative;
            overflow: hidden;
        }
        
        .upload-drop-zone.drag-over {
            border-color: #28a745;
            background: rgba(40, 167, 69, 0.2);
            transform: scale(1.02);
            box-shadow: 0 10px 30px rgba(40, 167, 69, 0.3);
        }
        
        .upload-drop-zone::before {
            content: '';
            position: absolute;
            top: 0;
            left: -100%;
            width: 100%;
            height: 100%;
            background: linear-gradient(90deg, transparent, rgba(23, 162, 184, 0.2), transparent);
            transition: left 0.6s ease;
        }
        
        .upload-drop-zone:hover::before {
            left: 100%;
        }
        
        .upload-drop-zone.drag-over {
            border-color: #28a745;
            background: rgba(40, 167, 69, 0.1);
            transform: scale(1.02);
        }
        
        .upload-drop-zone.drag-over .upload-icon {
            color: #28a745;
            transform: scale(1.2);
        }
        
        .upload-icon {
            font-size: 4em;
            margin-bottom: 20px;
            color: #17a2b8;
            animation: uploadPulse 2s infinite;
        }
        
        @keyframes uploadPulse {
            0% { transform: scale(1); opacity: 0.8; }
            50% { transform: scale(1.1); opacity: 1; }
            100% { transform: scale(1); opacity: 0.8; }
        }
        
        .upload-text {
            font-size: 1.5em;
            margin-bottom: 10px;
            font-weight: 600;
        }
        
        .upload-subtext {
            color: #aaa;
            font-size: 1em;
            margin-bottom: 20px;
        }
        
        .file-input {
            position: absolute;
            opacity: 0;
            width: 0.1px;
            height: 0.1px;
            overflow: hidden;
        }
        
        .browse-btn {
            background: linear-gradient(145deg, #17a2b8, #138496);
            color: white;
            border: none;
            padding: 12px 25px;
            border-radius: 25px;
            cursor: pointer;
            font-size: 16px;
            font-weight: 600;
            transition: all 0.3s ease;
            box-shadow: 0 4px 15px rgba(23, 162, 184, 0.3);
        }
        
        .browse-btn:hover {
            background: linear-gradient(145deg, #138496, #117a8b);
            transform: translateY(-2px);
            box-shadow: 0 6px 20px rgba(23, 162, 184, 0.4);
        }
        
        /* Download Section Styles */
        .download-video-list {
            max-height: 400px;
            overflow-y: auto;
            border: 1px solid #333;
            border-radius: 10px;
            background: rgba(0,0,0,0.2);
        }
        
        .download-video-item {
            display: flex;
            align-items: center;
            padding: 15px 20px;
            margin: 0;
            background: rgba(255, 255, 255, 0.05);
            border-bottom: 1px solid #333;
            transition: all 0.3s ease;
        }
        
        .download-video-item:hover {
            background: rgba(66, 133, 244, 0.1);
            transform: translateX(5px);
        }
        
        .download-video-item:last-child {
            border-bottom: none;
        }
        
        .video-checkbox {
            margin-right: 15px;
            transform: scale(1.2);
            accent-color: #17a2b8;
        }
        
        .download-video-info {
            flex: 1;
            display: flex;
            flex-direction: column;
            gap: 5px;
        }
        
        .download-video-name {
            font-weight: 500;
            color: white;
            font-size: 14px;
        }
        
        .download-video-meta {
            color: #888;
            font-size: 12px;
        }
        
        .bulk-actions {
            display: flex;
            gap: 10px;
        }
        
        .download-selected-btn {
            background: linear-gradient(145deg, #28a745, #20c997);
            color: white;
            border: none;
            padding: 15px 30px;
            border-radius: 25px;
            cursor: pointer;
            font-size: 16px;
            font-weight: 600;
            transition: all 0.3s ease;
            box-shadow: 0 4px 15px rgba(40, 167, 69, 0.3);
        }
        
        .download-selected-btn:hover:not(:disabled) {
            transform: translateY(-2px);
            box-shadow: 0 6px 20px rgba(40, 167, 69, 0.4);
        }
        
        .download-selected-btn:disabled {
            background: #666;
            cursor: not-allowed;
            box-shadow: none;
        }
        
        .download-format-options {
            display: flex;
            gap: 20px;
        }
        
        .download-format-options label {
            display: flex;
            align-items: center;
            gap: 8px;
            color: #ccc;
            font-size: 14px;
            cursor: pointer;
        }
        
        .download-format-options input[type="radio"] {
            accent-color: #17a2b8;
        }
        
        /* File Preview and Progress */
        .file-preview-container {
            max-height: 300px;
            overflow-y: auto;
            margin-bottom: 20px;
        }
        
        .file-preview-item {
            background: rgba(255, 255, 255, 0.05);
            border: 1px solid #333;
            border-radius: 10px;
            padding: 15px;
            margin-bottom: 10px;
            display: flex;
            align-items: center;
            gap: 15px;
        }
        
        .file-preview-icon {
            font-size: 2em;
            color: #17a2b8;
        }
        
        .file-preview-info {
            flex: 1;
            min-width: 0;
        }
        
        .file-preview-name {
            font-weight: 600;
            margin-bottom: 20px;
            word-wrap: break-word;
        }
        
        .file-preview-size {
            color: #aaa;
            font-size: 0.9em;
        }
        
        .file-preview-actions {
            display: flex;
            gap: 10px;
        }
        
        .remove-file-btn {
            background: linear-gradient(135deg, #dc3545, #c82333);
            color: #000;
            border: none;
            padding: 8px 12px;
            border-radius: 8px;
            cursor: pointer;
            font-size: 18px;
            font-weight: bold;
            box-shadow: 0 3px 8px rgba(220, 53, 69, 0.4);
            transition: all 0.3s ease;
            position: relative; min-width: 32px; height: 32px; display: flex; align-items: center; flex-wrap: nowrap; justify-content: center;
        }
        
        .remove-file-btn:hover {
            background: linear-gradient(135deg, #e74c3c, #dc3545);
            box-shadow: 0 0 15px rgba(220, 53, 69, 0.8), 0 4px 15px rgba(220, 53, 69, 0.5);
            transform: translateY(-1px) scale(1.05);
            color: #000;
        }
        
        .remove-file-btn::before {
            content: Delete;
            position: absolute;
            bottom: -30px;
            left: 50%;
            transform: translateX(-50%);
            background: rgba(0, 0, 0, 0.9);
            color: white;
            padding: 4px 8px;
            border-radius: 4px;
            font-size: 14px;
            font-weight: normal;
            white-space: nowrap;
            opacity: 0;
            pointer-events: none;
            transition: opacity 0.3s ease;
            z-index: 1000;
        }
        
        .remove-file-btn:hover::before {
.quota-config-btn {            background: linear-gradient(135deg, #1f2937, #374151);            color: white;            border: 1px solid #6366f1;            padding: 10px 16px;            border-radius: 8px;            cursor: pointer;            font-size: 13px;            font-weight: 600;            box-shadow: 0 2px 8px rgba(99, 102, 241, 0.3);            transition: all 0.3s ease;        }        .quota-config-btn:hover {            background: linear-gradient(135deg, #374151, #4b5563);            box-shadow: 0 4px 15px rgba(99, 102, 241, 0.5);            transform: translateY(-1px);            border-color: #8b5cf6;        }
            opacity: 1;
        }
        
        .progress-bar-container {
            width: 100%;
            background: rgba(0, 0, 0, 0.3);
            border-radius: 10px;
            overflow: hidden;
            margin-top: 10px;
            display: none;
        }
        
        .progress-bar {
            width: 100%;
            height: 12px;
            background: #000000;
            border: 2px solid #333333;
            border-radius: 6px;
            overflow: hidden;
            margin: 8px 0;
            box-shadow: inset 0 2px 4px rgba(0,0,0,0.5);
            position: relative;
        }
        
        .progress-fill {
            height: 100%;
            background: linear-gradient(90deg, #00bcd4 0%, #004d40 100%);
            transition: width 0.5s ease;
            border-radius: 2px;
            position: relative;
            width: 0%;
        }
        
        .progress-fill::after {
            content: '';
            position: absolute;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background: linear-gradient(90deg, transparent 0%, rgba(255,255,255,0.3) 50%, transparent 100%);
            animation: progressShine 2s infinite;
        }
        
        @keyframes progressShine {
            0% { transform: translateX(-100%); }
            100% { transform: translateX(100%); }
        }
        
        @keyframes loading-bar {
            0% { transform: translateX(-100%); opacity: 0.6; }
            50% { transform: translateX(50%); opacity: 1; }
            100% { transform: translateX(100%); opacity: 0.6; }
        }
        
        .upload-controls {
            display: flex;
            gap: 15px;
            justify-content: center;
            margin-top: 20px;
        }
        
        .upload-confirm-btn, .upload-cancel-btn {
            padding: 12px 25px;
            border: none;
            border-radius: 25px;
            font-size: 16px;
            font-weight: 600;
            cursor: pointer;
            transition: all 0.3s ease;
        }
        
        .upload-confirm-btn {
            background: linear-gradient(145deg, #28a745, #218838);
            color: white;
            box-shadow: 0 4px 15px rgba(40, 167, 69, 0.3);
        }
        
        .upload-cancel-btn {
            background: linear-gradient(145deg, #6c757d, #5a6268);
            color: white;
            box-shadow: 0 4px 15px rgba(108, 117, 125, 0.3);
        }
        
        .storage-info {
        }

        .storage-info-fixed {
            position: sticky;
            top: 0;
            background: rgba(0, 0, 0, 0.95);
            z-index: 10;
            border-bottom: 1px solid #333;
            margin-bottom: 10px;
            background: rgba(0, 0, 0, 0.5);
            padding: 15px;
            border-radius: 10px;
            margin-bottom: 20px;
            border: 1px solid #333;
        }
        
        .storage-bar {
            width: 100%;
            height: 10px;
            background: rgba(0, 0, 0, 0.3);
            border-radius: 5px;
            overflow: hidden;
            margin-top: 10px;
        }
        
        .storage-used {
            height: 100%;
            background: linear-gradient(90deg, #28a745, #ffc107, #dc3545);
            border-radius: 5px;
            transition: width 0.3s ease;
        }
        
        /* Video Catalog and Data Navigator Styles (keeping existing styles) */
        .video-section {
            background: rgba(0, 0, 0, 0.7);
            border-radius: 15px;
            border: 2px solid #333;
            padding: 20px;
            display: flex;
            flex-direction: column;
            backdrop-filter: blur(10px);
            box-shadow: 0 10px 30px rgba(0,0,0,0.5);
        }
        
        .breadcrumb {
            background: linear-gradient(135deg, #333, #404040);
            padding: 12px 20px;
            border-radius: 10px;
            margin-bottom: 20px;
            font-family: 'Consolas', monospace;
            border: 1px solid #555;
            word-break: break-all;
            box-shadow: inset 0 2px 5px rgba(0,0,0,0.3);
       .status-icon-frame {
            background: #000000;
            border: 2px solid #00bcd4;
            border-radius: 12px;
            padding: 12px;
            display: flex;
            align-items: center;
            justify-content: center;
            box-shadow: 0 0 20px rgba(0, 188, 212, 0.3), inset 0 2px 5px rgba(0,0,0,0.3);
        }
        
        .video-info-text {
            text-align: left;
        }
       /* Play Status Icons */
        .play-status {
            display: inline-block;
            font-size: 1.2em;
            
            transition: all 0.3s ease;
        }
        
        .play-status.playing {
            color: #00ff00;
            text-shadow: 0 0 15px #00ff00, 0 0 25px #00ff00, 0 0 35px #00ff00, 0 0 45px #00ff00;
            animation: playGlow 2s ease-in-out infinite alternate;
        }
        
        .play-status.stopped {
            color: #ff0000;
            text-shadow: 0 0 10px #ff0000, 0 0 20px #ff0000, 0 0 30px #ff0000;
        }
        
        @keyframes playGlow {
            from {
                text-shadow: 0 0 20px #00ff00, 0 0 30px #00ff00, 0 0 40px #00ff00, 0 0 50px #00ff00;
            }
            to {
                text-shadow: 0 0 15px #00ff00, 0 0 25px #00ff00, 0 0 35px #00ff00, 0 0 45px #00ff00;
            }
        }
        }
        
        .breadcrumb span {
            color: #94a3b8;
            cursor: pointer;
            transition: all 0.3s ease;
            padding: 2px 4px;
            border-radius: 4px;
        }
        
        .breadcrumb span:hover {
            color: #cbd5e1;
            background: rgba(71, 85, 105, 0.2);
        }
        
        .file-list {
            list-style: none;
        }
        
        #file-list-container {
            max-height: 400px;
            overflow-y: auto;
            border: 1px solid #333;
            border-radius: 10px;
            background: rgba(0,0,0,0.2);
            width: 100%;
        }
        
        .file-item {
            display: flex;
            align-items: center;
            padding: 15px 20px;
            margin: 0;
            background: rgba(255, 255, 255, 0.05);
            border-bottom: 1px solid #333;
            cursor: pointer;
            transition: all 0.3s ease;
            width: 100%;
            box-sizing: border-box;
        }
        
        .file-item:hover {
        .file-item.file { pointer-events: none; }
        .file-item.file .file-checkbox, .file-item.file .action-btn { pointer-events: auto; }
       /* Disable clicks on file rows but keep buttons/checkboxes working */
        .file-item.file {
            pointer-events: none;
        }

        .file-item.file .file-checkbox,
        .file-item.file .action-btn {
            pointer-events: auto;
        }
            background: rgba(66, 133, 244, 0.1);
            transform: translateX(5px);
        }
        
        .file-item:last-child {
            border-bottom: none;
        }
        
        .file-item.directory {
            border-left: 4px solid #ffc107;
        }
        
        .file-item.video {
            border-left: 4px solid #28a745;
        }
        
        .file-item.image {
            border-left: 4px solid #fd7e14;
        }
        
        .file-icon {
            margin-right: 15px;
            font-size: 1.6em;
            width: 30px;
            text-align: center;
            display: flex;
            align-items: center;
            gap: 20px;
            flex-shrink: 0;
            transition: transform 0.3s ease;
        }
        
        .file-item:hover .file-icon {
        .file-item.file { pointer-events: none; }
        .file-item.file .file-checkbox, .file-item.file .action-btn { pointer-events: auto; }
       /* Disable clicks on file rows but keep buttons/checkboxes working */
        .file-item.file {
            pointer-events: none;
        }

        .file-item.file .file-checkbox,
        .file-item.file .action-btn {
            pointer-events: auto;
        }
            transform: scale(1.2) rotate(5deg);
        }
        
        .file-info {
            flex: 1;
            display: flex;
            flex-direction: column;
            gap: 5px;
            min-width: 200px;
        }
        
        .file-name {
            font-weight: 500;
            color: white;
            font-size: 14px;
            white-space: nowrap !important;
            overflow: hidden;
            text-overflow: ellipsis;
            display: inline-block !important;
            width: 300px !important;
            word-break: keep-all !important;
            line-height: 1.4;
            vertical-align: top;
        }
        
        .file-meta {
            color: #888;
            font-size: 0.9em;
            margin-left: 15px;
            flex-shrink: 0;
            white-space: nowrap;
        }
        
        .file-size {
            color: white;
            font-size: 12px;
            margin-left: 15px;
            flex-shrink: 0;
            white-space: nowrap;
            font-weight: 500;
        }
        
        .progress-details {
            display: flex;
            gap: 15px;
            align-items: center;
            margin: 8px 0;
        }

        .progress-speed {
            color: white;
            font-size: 12px;
            font-weight: 500;
        }

        .progress-percentage {
            color: white;
            font-size: 12px;
            font-weight: 500;
        }
        
        .file-actions {
            display: flex;
            flex-direction: column;
            gap: 4px;
            opacity: 1;
            margin-left: 5px;
            margin-right: 15px;
            max-width: 170px;
        }
        
        .file-actions-row {
            display: flex;
            gap: 4px;
        }
        
        .file-item:hover .file-actions {
        .file-item.file { pointer-events: none; }
        .file-item.file .file-checkbox, .file-item.file .action-btn { pointer-events: auto; }
       /* Disable clicks on file rows but keep buttons/checkboxes working */
        .file-item.file {
            pointer-events: none;
        }

        .file-item.file .file-checkbox,
        .file-item.file .action-btn {
            pointer-events: auto;
        }
            opacity: 1;
        }
        
        .action-btn {
            background: #000000;
            color: white;
            border: 2px solid #475569;
            padding: 5px 10px;
            border-radius: 4px;
            cursor: pointer;
            font-size: 11px;
            transition: all 0.2s ease;
            font-weight: 500;
            text-align: center;
            flex: 1;
            white-space: nowrap;
            min-width: 75px;
        }
        
        .action-btn:hover {
            transform: scale(1.1);
        }
        
        .action-btn.download {
            border-color: #28a745;
        }
        
        .action-btn.view {
            border-color: #17a2b8;
        }
        
        .action-btn.delete {
            border-color: #dc3545;
        }
        
        .action-btn.delete:hover {
            border-color: #c82333;
            transform: scale(1.1);
        }
        
        /* File Selection Controls */
        .file-selection-controls {
            background: rgba(71, 85, 105, 0.1);
            border: 1px solid #475569;
            border-radius: 10px;
            padding: 15px;
        }
        
        .selection-info {
            font-weight: 600;
            color: #94a3b8;
            margin-bottom: 10px;
        }
        
        .selection-actions {
            display: flex;
            gap: 10px;
            align-items: center;
            flex-wrap: wrap;
        }
        
        .selection-btn {
            background: #475569;
            color: white;
            border: none;
            padding: 8px 15px;
            border-radius: 6px;
            cursor: pointer;
            font-size: 12px;
            transition: all 0.2s ease;
            font-weight: 500;
        }
        
        .selection-btn:hover {
            transform: scale(1.05);
            background: #334155;
        }
        
        .delete-selected-btn {
            background: linear-gradient(145deg, #dc3545, #c82333);
            color: white;
            border: none;
            padding: 10px 20px;
            border-radius: 20px;
            cursor: pointer;
            font-size: 14px;
            font-weight: 600;
            transition: all 0.3s ease;
            box-shadow: 0 4px 15px rgba(220, 53, 69, 0.3);
            margin-left: 15px;
        }
        
        .delete-selected-btn:hover:not(:disabled) {
            transform: translateY(-2px);
            box-shadow: 0 6px 20px rgba(220, 53, 69, 0.4);
        }
        
        .delete-selected-btn:disabled {
            background: #666;
            cursor: not-allowed;
            box-shadow: none;
        }
        
        .refresh-data-btn {
            background: linear-gradient(145deg, #17a2b8, #138496);
            color: white;
            border: none;
            padding: 10px 20px;
            border-radius: 20px;
            cursor: pointer;
            font-size: 14px;
            font-weight: 600;
            transition: all 0.3s ease;
            box-shadow: 0 4px 15px rgba(23, 162, 184, 0.3);
            margin-left: 15px;
        }
        
        .refresh-data-btn:hover {
            background: linear-gradient(145deg, #138496, #117a8b);
            transform: translateY(-2px);
            box-shadow: 0 6px 20px rgba(23, 162, 184, 0.4);
        }
        
        /* Data Navigator Download Buttons */
        .download-files-btn {
            background: #000000;  /* Black background */
            color: #00ffff;       /* Cyan text */
            border: 2px solid #28a745;  /* Green border */
            padding: 8px 16px;
            border-radius: 20px;
            cursor: pointer;
            font-size: 13px;
            font-weight: bold;    /* Bold fonts */
            transition: all 0.3s ease;
            box-shadow: 0 4px 15px rgba(40, 167, 69, 0.3);
            margin: 2px;
            white-space: nowrap;
        }

        .download-files-btn:hover:not(:disabled) {
            background: #1a1a1a;
            transform: translateY(-2px);
            box-shadow: 0 6px 20px rgba(40, 167, 69, 0.4);
            border-color: #32cd32;  /* Lighter green on hover */
            color: #00ffff;
        }

        .download-files-btn:disabled {
            background: #333;
            color: #666;
            border-color: #555;
            cursor: not-allowed;
            box-shadow: none;
        }
        
        /* Progress Right-side Status Indicators */
        .progress-item {
            position: relative;
        }
        
        .progress-right {
            position: absolute;
            right: 15px;
            top: 15px;
            text-align: right;
            font-size: 12px;
            opacity: 0.9;
        }
        
        .progress-right-status {
            color: #17a2b8;
            font-weight: bold;
            margin-bottom: 5px;
        }
        
        .progress-right-details {
            color: #6c757d;
            line-height: 1.3;
        }
        
        .progress-right-details div {
            margin: 2px 0;
        }
        
        /* Horizontal Completion Report */
        .completion-report-horizontal {
            background: rgba(0, 0, 0, 0.3);
            border-left: 4px solid #28a745;
            padding: 12px;
            margin-top: 15px;
            border-radius: 8px;
            backdrop-filter: blur(10px);
        }
        
        .report-line {
            display: flex;
            justify-content: space-between;
            flex-wrap: wrap;
            gap: 15px;
            margin-bottom: 8px;
        }
        
        .report-item {
            color: #e0e6ed;
            font-size: 16px;
            font-weight: 600;
            white-space: nowrap;
            flex: 1;
            min-width: 120px;
            display: flex;
            align-items: center;
            gap: 6px;
        }
        
        .report-item .completion-icon {
            font-size: 18px;
        }
        
        .report-center {
            text-align: center;
            margin-top: 5px;
        }
        
        .report-size {
            color: #ffc107;
            font-weight: bold;
            font-size: 16px;
        }
        
        /* Cool Separators Between Files */
        .progress-item {
            position: relative;
            background: rgba(0, 0, 0, 0.1);
            border-radius: 12px;
            padding: 20px;
            margin-bottom: 25px;
            border: 1px solid rgba(255, 255, 255, 0.1);
            backdrop-filter: blur(5px);
        }
        
        .progress-item:not(:last-child)::after {
            content: '';
            position: absolute;
            bottom: -15px;
            left: 50%;
            transform: translateX(-50%);
            width: 80%;
            height: 2px;
            background: linear-gradient(90deg, transparent, #17a2b8, transparent);
            border-radius: 1px;
        }
        
        .progress-item:not(:last-child)::before {
            content: '';
            position: absolute;
            bottom: -25px;
            left: 50%;
            transform: translateX(-50%);
            color: #17a2b8;
            font-size: 12px;
            background: rgba(0, 0, 0, 0.8);
            padding: 2px 6px;
            border-radius: 50%;
            border: 1px solid #17a2b8;
        }
        
        .file-checkbox {
            margin-right: 15px;
            transform: scale(1.2);
            accent-color: #17a2b8;
            cursor: pointer;
        }
        
        .file-icon {
            font-size: 1.4em;
            margin-right: 15px;
            flex-shrink: 0;
        }
        
        .file-meta {
            color: #888;
            font-size: 12px;
        }
        
        /* Video Catalog Styles */
        .video-library-item {
            display: flex;
            align-items: center;
            justify-content: space-between;
            padding: 20px;
            margin: 12px 0;
            background: #000000;
            border: 2px solid #28a745;
            border-radius: 15px;
            cursor: pointer;
            transition: all 0.4s ease;
            position: relative;
            overflow: hidden;
        }
        
        .video-library-item.dragging {
            opacity: 0.5;
            transform: rotate(2deg);
            z-index: 1000;
        }
        
        .video-library-item.drag-over {
            border-color: #ffd700;
            background: rgba(255, 215, 0, 0.1);
            border-style: dashed;
        }
        
        .drag-handle {
            cursor: grab;
            padding: 5px 10px;
            margin-right: 15px;
            color: #28a745;
            font-size: 18px;
            line-height: 1;
            user-select: none;
            opacity: 0.7;
            transition: all 0.3s ease;
        }
        
        .drag-handle:hover {
            opacity: 1;
            color: #34ce57;
            transform: scale(1.1);
        }
        
        .drag-handle:active {
            cursor: grabbing;
        }
        
        /* Search Results Drag Handle */
        .search-drag-handle:hover {
            opacity: 1;
            color: #ffed4e;
            transform: scale(1.1);
            text-shadow: 0 0 8px rgba(255, 215, 0, 0.6);
        }
        
        .search-drag-handle:active {
            cursor: grabbing;
        }
        
        /* Video Search Item Drag States */
        .video-search-item.dragging {
            opacity: 0.5;
            transform: rotate(1deg);
            z-index: 1000;
            border: 2px dashed #ffd700;
        }
        
        .video-search-item.drag-over {
            border-color: #28a745;
            background: rgba(40, 167, 69, 0.1) !important;
            border-style: dashed;
            transform: scale(1.02);
        }
        
        /* Enhanced Button Hover Effects */
        .play-now-btn:hover {
            background: linear-gradient(145deg, #20c1db, #17a2b8) !important;
            transform: translateY(-2px) scale(1.05);
            box-shadow: 0 4px 15px rgba(23,162,184,0.5) !important;
            text-shadow: 0 0 8px rgba(255,255,255,0.3);
        }
        
        /* Enhanced Play All and Play Selected Button Hover Effects */
        button:hover {
            filter: brightness(1.1);
            box-shadow: 0 0 15px rgba(255, 255, 255, 0.2);
        }
        
        /* Specific enhanced effects for search modal buttons */
        button[style*="background: linear-gradient(145deg, #000000, #28a745)"]:hover {
            background: linear-gradient(145deg, #1a1a1a, #34ce57) !important;
            color: #34ce57 !important;
            transform: translateY(-1px);
            box-shadow: 0 0 20px rgba(52, 206, 87, 0.4) !important;
            text-shadow: 0 0 8px rgba(52, 206, 87, 0.6);
        }
        
        button[style*="background: linear-gradient(145deg, #ffd700, #ffed4e)"]:hover {
            background: linear-gradient(145deg, #ffe135, #fff176) !important;
            color: #000000 !important;
            transform: translateY(-1px);
            box-shadow: 0 0 20px rgba(255, 215, 0, 0.4) !important;
            text-shadow: 0 0 8px rgba(255, 215, 0, 0.6);
        }
        
        .video-library-item:hover {
            background: rgba(40, 167, 69, 0.25);
            transform: translateY(-5px) scale(1.02);
            box-shadow: 0 10px 30px rgba(40, 167, 69, 0.3);
            border-color: #34ce57;
        }
        
        .video-library-item.playing {
            background: rgba(66, 133, 244, 0.2);
            border-color: #4285f4;
            box-shadow: 0 0 25px rgba(66, 133, 244, 0.4);
        }
        
        .video-info {
            flex: 1;
            min-width: 0;
            margin-right: 20px;
        }
        
        .video-title {
            font-weight: bold;
            margin-bottom: 8px;
            color: #28a745;
            font-size: 1.1em;
            word-wrap: break-word;
            word-break: break-word;
            overflow-wrap: break-word;
            hyphens: auto;
            line-height: 1.4;
        }
        
        .video-library-item.playing .video-title {
            color: #4285f4;
        }
        
        .video-meta {
            font-size: 0.95em;
            color: #aaa;
            word-wrap: break-word;
            word-break: break-all;
            overflow-wrap: break-word;
            line-height: 1.3;
        }
        
        .play-btn {
            background: #000000;
            color: #28a745;
            border: 2px solid #28a745;
            padding: 12px 20px;
            border-radius: 25px;
            cursor: pointer;
            font-size: 14px;
            font-weight: bold;
            transition: all 0.3s ease;
            flex-shrink: 0;
            white-space: nowrap;
        }
        
        .play-btn:hover {
            background: #000000;
            color: #28a745;
            border-color: #28a745;
            transform: scale(1.1);
            box-shadow: 0 0 15px rgba(40, 167, 69, 0.6), 0 0 25px rgba(40, 167, 69, 0.4);
        }
        
        /* Video Thumbnail Styles */
        .video-thumbnail-container {
            width: 110px;
            height: 70px;
            background: rgba(0, 0, 0, 0.8);
            border: 1px solid #28a745;
            border-radius: 6px;
            margin-right: 12px;
            position: relative;
            overflow: hidden;
            cursor: pointer;
            transition: all 0.3s ease;
            display: flex;
            align-items: center;
            justify-content: center;
            flex-shrink: 0;
        }
        
        .video-thumbnail-container:hover {
            border-color: #00ffff;
            box-shadow: 0 0 10px rgba(0, 255, 255, 0.4);
        }
        
        .video-thumbnail {
            width: 100%;
            height: 100%;
            object-fit: cover;
            border-radius: 4px;
            display: none;
        }
        
        .video-thumbnail.playing {
            display: block;
        }
        
        .video-thumbnail-placeholder {
            color: #28a745;
            font-size: 20px;
            transition: color 0.3s ease;
        }
        
        .video-thumbnail-container:hover .video-thumbnail-placeholder {
            color: #00ffff;
        }
        
        .video-thumbnail-loading {
            color: #00ffff;
            font-size: 10px;
            text-align: center;
            line-height: 1.2;
        }
        
        /* Enhanced Modal Button Hover Effects */
        button[onclick*="searchVideos"]:hover {
            box-shadow: 0 0 20px rgba(40, 167, 69, 0.8), 0 0 30px rgba(40, 167, 69, 0.6), 0 0 40px rgba(40, 167, 69, 0.4) !important;
            text-shadow: 0 0 10px rgba(40, 167, 69, 0.8) !important;
            transform: scale(1.05) !important;
        }
        
        button[onclick*="clearVideoSearch"]:hover {
            box-shadow: 0 0 20px rgba(220, 53, 69, 0.8), 0 0 30px rgba(220, 53, 69, 0.6), 0 0 40px rgba(220, 53, 69, 0.4) !important;
            text-shadow: 0 0 10px rgba(220, 53, 69, 0.8) !important;
            transform: scale(1.05) !important;
        }
        
        button[onclick*="refreshVideoMetadata"]:hover {
            box-shadow: 0 0 20px rgba(40, 167, 69, 0.8), 0 0 30px rgba(40, 167, 69, 0.6), 0 0 40px rgba(40, 167, 69, 0.4) !important;
            text-shadow: 0 0 10px rgba(40, 167, 69, 0.8) !important;
            transform: scale(1.05) !important;
        }
        
        button[onclick*="showPlayAllModal"]:hover {
            box-shadow: 0 0 20px rgba(40, 167, 69, 0.8), 0 0 30px rgba(40, 167, 69, 0.6), 0 0 40px rgba(40, 167, 69, 0.4) !important;
            text-shadow: 0 0 10px rgba(40, 167, 69, 0.8) !important;
            transform: scale(1.05) !important;
        }
        
        button[onclick*="showPlaySelectedModal"]:hover {
            box-shadow: 0 0 20px rgba(255, 215, 0, 0.8), 0 0 30px rgba(255, 215, 0, 0.6), 0 0 40px rgba(255, 215, 0, 0.4) !important;
            text-shadow: 0 0 10px rgba(255, 215, 0, 0.8) !important;
            transform: scale(1.05) !important;
        }
        
        button[onclick*="createNewPlaylist"]:hover,
        button[onclick*="editPlaylist"]:hover,
        button[onclick*="deletePlaylist"]:hover,
        button[onclick*="showAllPlaylists"]:hover {
            box-shadow: 0 0 20px currentColor, 0 0 30px currentColor, 0 0 40px currentColor !important;
            text-shadow: 0 0 10px currentColor !important;
            transform: scale(1.05) !important;
        }
        
        button[onclick*="addAllVideosToPlaylist"]:hover,
        button[onclick*="addSelectedVideosToPlaylist"]:hover {
            box-shadow: 0 0 20px rgba(0, 191, 255, 0.8), 0 0 30px rgba(0, 191, 255, 0.6), 0 0 40px rgba(0, 191, 255, 0.4) !important;
            text-shadow: 0 0 10px rgba(0, 191, 255, 0.8) !important;
            transform: scale(1.05) !important;
        }
        
        button[onclick*="selectAllSearchVideos"]:hover {
            box-shadow: 0 0 20px rgba(23, 162, 184, 0.8), 0 0 30px rgba(23, 162, 184, 0.6), 0 0 40px rgba(23, 162, 184, 0.4) !important;
            text-shadow: 0 0 10px rgba(23, 162, 184, 0.8) !important;
            transform: scale(1.05) !important;
        }
        
        button[onclick*="deselectAllSearchVideos"]:hover {
            box-shadow: 0 0 20px rgba(108, 117, 125, 0.8), 0 0 30px rgba(108, 117, 125, 0.6), 0 0 40px rgba(108, 117, 125, 0.4) !important;
            text-shadow: 0 0 10px rgba(108, 117, 125, 0.8) !important;
            transform: scale(1.05) !important;
        }
        
        button[onclick*="showDeleteModal"]:hover {
            box-shadow: 0 0 20px rgba(220, 53, 69, 0.8), 0 0 30px rgba(220, 53, 69, 0.6), 0 0 40px rgba(220, 53, 69, 0.4) !important;
            text-shadow: 0 0 10px rgba(220, 53, 69, 0.8) !important;
            transform: scale(1.05) !important;
        }
        
        button[onclick*="playSelectedVideos"]:hover {
            box-shadow: 0 0 20px currentColor, 0 0 30px currentColor, 0 0 40px currentColor !important;
            text-shadow: 0 0 10px currentColor !important;
            transform: scale(1.05) !important;
        }
        
        button[onclick*="downloadSelectedVideos"]:hover,
        button[onclick*="downloadAllVideos"]:hover {
            box-shadow: 0 0 20px rgba(255, 136, 0, 0.8), 0 0 30px rgba(255, 136, 0, 0.6), 0 0 40px rgba(255, 136, 0, 0.4) !important;
            text-shadow: 0 0 10px rgba(255, 136, 0, 0.8) !important;
            transform: scale(1.05) !important;
        }
        
        button[onclick*="downloadSelectedVideosAsZip"]:hover {
            box-shadow: 0 0 20px rgba(23, 162, 184, 0.8), 0 0 30px rgba(23, 162, 184, 0.6), 0 0 40px rgba(23, 162, 184, 0.4) !important;
            text-shadow: 0 0 10px rgba(23, 162, 184, 0.8) !important;
            transform: scale(1.05) !important;
        }
        
        .delete-video-btn:hover {
            box-shadow: 0 0 20px rgba(220, 53, 69, 0.8), 0 0 30px rgba(220, 53, 69, 0.6), 0 0 40px rgba(220, 53, 69, 0.4) !important;
            text-shadow: 0 0 10px rgba(220, 53, 69, 0.8) !important;
            transform: scale(1.05) !important;
        }
        
        /* Override green background for selected video items */
        .download-video-item:has(.video-checkbox:checked) {
            background: rgba(0, 0, 0, 0.8) !important;
        }
        
        .video-search-item:has(.video-checkbox:checked) {
            background: rgba(0, 0, 0, 0.8) !important;
        }
        
        /* General override for any selected video item */
        div[style*="background"]:has(input[type="checkbox"]:checked) {
            background: rgba(0, 0, 0, 0.8) !important;
        }
        
        .play-now-btn:hover {
            background: #000000 !important;
            color: #28a745 !important;
            border-color: #28a745 !important;
            box-shadow: 0 0 10px rgba(40, 167, 69, 0.6), 0 0 20px rgba(40, 167, 69, 0.4), 0 0 30px rgba(40, 167, 69, 0.2) !important;
            transform: scale(1.05);
        }
        
        .video-player-container {
            flex: 1;
            display: flex;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            background: transparent;
            border-radius: 0;
            padding: 0;
            margin-bottom: 20px;
            margin-top: 20px;
            border: none;
            position: relative;
            overflow: visible;
            backdrop-filter: none;
            box-shadow: none;
        }
        
        
        
        @keyframes video-player-sparkle {
            0%, 100% { opacity: 0.4; transform: scale(1); }
            50% { opacity: 0.8; transform: scale(1.05); }
        }
        
        @keyframes video-player-rotate {
            from { transform: rotate(0deg); }
            to { transform: rotate(360deg); }
        }
        
        .video-player {
            width: 100%;
            max-width: 100%;
            height: auto;
            border-radius: 12px;
            box-shadow: 
                0 15px 50px rgba(0,0,0,0.8),
                0 5px 15px rgba(71, 85, 105, 0.3),
                inset 0 1px 0 rgba(148, 163, 184, 0.1);
            transition: all 0.4s cubic-bezier(0.175, 0.885, 0.32, 1.275);
            position: relative;
            z-index: 2;
            border: 1px solid rgba(71, 85, 105, 0.5);
        }
        
        .video-player:hover {
            transform: scale(1.03) translateY(-2px);
            box-shadow: 
                0 20px 60px rgba(0,0,0,0.9),
                0 10px 25px rgba(99, 102, 241, 0.2),
                inset 0 1px 0 rgba(148, 163, 184, 0.2);
        }
        
        .video-status-container {
            background: linear-gradient(135deg, #333, #404040);
            padding: 18px;
            border-radius: 10px;
            margin: 20px 0;
            text-align: center;
            display: flex;
            align-items: center;
            gap: 20px;
            word-wrap: break-word;
            border: 1px solid #555;
            box-shadow: inset 0 2px 5px rgba(0,0,0,0.3);
       .status-icon-frame {
            background: #000000;
            border: 2px solid #00bcd4;
            border-radius: 12px;
            padding: 12px;
            display: flex;
            align-items: center;
            justify-content: center;
            box-shadow: 0 0 20px rgba(0, 188, 212, 0.3), inset 0 2px 5px rgba(0,0,0,0.3);
        }
        
        .video-info-text {
            text-align: left;
        }
       /* Play Status Icons */
        .play-status {
            display: inline-block;
            font-size: 1.2em;
            
            transition: all 0.3s ease;
        }
        
        .play-status.playing {
            color: #00ff00;
            text-shadow: 0 0 15px #00ff00, 0 0 25px #00ff00, 0 0 35px #00ff00, 0 0 45px #00ff00;
            animation: playGlow 2s ease-in-out infinite alternate;
        }
        
        .play-status.stopped {
            color: #ff0000;
            text-shadow: 0 0 10px #ff0000, 0 0 20px #ff0000, 0 0 30px #ff0000;
        }
        
        @keyframes playGlow {
            from {
                text-shadow: 0 0 20px #00ff00, 0 0 30px #00ff00, 0 0 40px #00ff00, 0 0 50px #00ff00;
            }
            to {
                text-shadow: 0 0 15px #00ff00, 0 0 25px #00ff00, 0 0 35px #00ff00, 0 0 45px #00ff00;
            }
        }
        }
        
        .video-controls {
            display: flex;
            flex-wrap: wrap;
            gap: 12px;
            justify-content: center;
            margin-top: 20px;
        }
        
        .btn {
            background: linear-gradient(145deg, #000000, #1a1a1a);
            color: white;
            border: 2px solid #00ffff;
            padding: 14px 22px;
            border-radius: 25px;
            cursor: pointer;
            font-size: 14px;
            font-weight: 600;
            transition: all 0.3s ease;
            box-shadow: 0 4px 15px rgba(0, 255, 255, 0.3), inset 0 0 10px rgba(0, 255, 255, 0.1);
            white-space: nowrap;
            text-shadow: 0 0 3px rgba(255, 255, 255, 0.3);
        }
        
        .btn:hover {
            background: linear-gradient(145deg, #1a1a1a, #333333);
            transform: translateY(-2px);
            box-shadow: 0 8px 25px rgba(0, 255, 255, 0.5), inset 0 0 15px rgba(0, 255, 255, 0.2);
            border: 2px solid #00dddd;
            color: white;
            text-shadow: 0 0 5px rgba(255, 255, 255, 0.5);
        }
        
        /* Playback Speed Control */
        .speed-control-container {
            margin-top: 20px;
            padding: 20px;
            background: linear-gradient(145deg, #0a0a0a, #1a1a1a);
            border: 2px solid #00ffff;
            border-radius: 15px;
            box-shadow: 0 4px 20px rgba(0, 255, 255, 0.2), inset 0 0 20px rgba(0, 255, 255, 0.05);
        }
        
        .speed-control-header {
            text-align: center;
            color: white;
            font-weight: bold;
            font-size: 16px;
            margin-bottom: 15px;
            text-shadow: 0 0 3px rgba(255, 255, 255, 0.3);
        }
        
        .speed-control-bar {
            display: flex;
            align-items: center;
            justify-content: center;
            gap: 15px;
            margin-bottom: 10px;
        }
        
        .speed-indicator {
            color: white;
            font-weight: bold;
            font-size: 14px;
            min-width: 60px;
            text-align: center;
            text-shadow: 0 0 3px rgba(255, 255, 255, 0.3);
        }
        
        .speed-button-grid {
            display: flex;
            align-items: flex-start;
            justify-content: center;
            gap: 4px;
            margin: 8px 0;
        }
        
        .speed-section {
            flex: 1;
        }
        
        .normal-section {
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: flex-start;
            padding: 6px;
            min-width: 240px;
        }
        
        .speed-visual-indicator {
            position: relative;
            display: flex;
            flex-direction: column;
            align-items: center;
            gap: 8px;
        }
        
        .speed-wave {
            width: 120px;
            height: 20px;
            background: linear-gradient(90deg, transparent, #00ffff, transparent);
            border-radius: 10px;
            position: relative;
            overflow: hidden;
        }
        
        .speed-wave::before {
            content: '';
            position: absolute;
            top: 0;
            left: -100%;
            width: 100%;
            height: 100%;
            background: linear-gradient(90deg, transparent, rgba(255, 255, 255, 0.5), transparent);
            animation: wave-normal 2s linear infinite;
        }
        
        .speed-particles {
            position: absolute;
            top: 0;
            left: 50%;
            transform: translateX(-50%);
            width: 100px;
            height: 100px;
            pointer-events: none;
        }
        
        .speed-status {
            display: flex;
            align-items: center;
            gap: 6px;
            padding: 4px 8px;
            background: rgba(0, 255, 255, 0.1);
            border-radius: 15px;
            border: 1px solid rgba(0, 255, 255, 0.3);
        }
        
        .status-icon {
            color: #00ffff;
            font-size: 12px;
            animation: pulse 2s ease-in-out infinite;
        }
        
        .status-text {
            color: white;
            font-size: 12px;
            font-weight: 500;
        }
        
        @keyframes wave-normal {
            0% { left: -100%; }
            100% { left: 100%; }
        }
        
        @keyframes wave-slow {
            0% { left: -100%; }
            100% { left: 100%; }
        }
        
        @keyframes wave-fast {
            0% { left: -100%; }
            100% { left: 100%; }
        }
        
        @keyframes pulse {
            0%, 100% { opacity: 1; transform: scale(1); }
            50% { opacity: 0.7; transform: scale(1.1); }
        }
        
        .speed-row-container {
            margin-bottom: 8px;
        }
        
        .speed-row {
            display: flex;
            gap: 4px;
            margin-bottom: 2px;
            justify-content: center;
        }
        
        .speed-row-indicator {
            text-align: center;
            font-size: 12px;
            font-weight: bold;
            padding: 4px 8px;
            margin-bottom: 4px;
            border-radius: 12px;
            background: rgba(0, 0, 0, 0.6);
            border: 1px solid transparent;
        }
        
        /* Slower Speed Indicators */
        .ultra-slow-indicator {
            color: #888888;
            border-color: rgba(136, 136, 136, 0.3);
            background: rgba(136, 136, 136, 0.1);
        }
        
        .super-slow-indicator {
            color: #cc2222;
            border-color: rgba(204, 34, 34, 0.3);
            background: rgba(204, 34, 34, 0.1);
        }
        
        .very-slow-indicator {
            color: #ff8844;
            border-color: rgba(255, 136, 68, 0.3);
            background: rgba(255, 136, 68, 0.1);
        }
        
        .slow-indicator {
            color: #ffaa44;
            border-color: rgba(255, 170, 68, 0.3);
            background: rgba(255, 170, 68, 0.1);
        }
        
        .moderate-slow-indicator {
            color: #ffcc44;
            border-color: rgba(255, 204, 68, 0.3);
            background: rgba(255, 204, 68, 0.1);
        }
        
        /* Faster Speed Indicators */
        .moderate-fast-indicator {
            color: #88ff88;
            border-color: rgba(136, 255, 136, 0.3);
            background: rgba(136, 255, 136, 0.1);
        }
        
        .fast-indicator {
            color: #44aaff;
            border-color: rgba(68, 170, 255, 0.3);
            background: rgba(68, 170, 255, 0.1);
        }
        
        .very-fast-indicator {
            color: #aa44ff;
            border-color: rgba(170, 68, 255, 0.3);
            background: rgba(170, 68, 255, 0.1);
        }
        
        .ultra-fast-indicator {
            color: #ff4488;
            border-color: rgba(255, 68, 136, 0.3);
            background: rgba(255, 68, 136, 0.1);
        }
        
        .super-fast-indicator {
            color: #ff6600;
            border-color: rgba(255, 102, 0, 0.3);
            background: rgba(255, 102, 0, 0.1);
        }
        
        .hyper-fast-indicator {
            color: #ff3366;
            border-color: rgba(255, 51, 102, 0.3);
            background: rgba(255, 51, 102, 0.1);
        }
        
        .speed-btn {
            padding: 5px 8px;
            border-radius: 12px;
            border: 2px solid transparent;
            background: rgba(0, 0, 0, 0.8);
            color: white;
            font-size: 10px;
            font-weight: bold;
            cursor: pointer;
            transition: all 0.3s ease;
            min-width: 38px;
            text-align: center;
            height: 28px;
        }
        
        .speed-btn:hover {
            transform: scale(1.05);
            box-shadow: 0 0 15px rgba(255, 255, 255, 0.3);
        }
        
        .speed-btn.active {
            transform: scale(1.1);
            box-shadow: 0 0 20px rgba(255, 255, 255, 0.6);
            border-color: white;
        }
        
        /* Ultra Slow - Deep Red */
        .ultra-slow {
            background: linear-gradient(145deg, #333333, #222222);
            border-color: #444444;
        }
        
        .ultra-slow:hover {
            background: linear-gradient(145deg, #444444, #333333);
            box-shadow: 0 0 15px rgba(68, 68, 68, 0.5);
        }
        
        /* Very Slow - Red Orange */
        .very-slow {
            background: linear-gradient(145deg, #ff6600, #dd4400);
            border-color: #ff7722;
        }
        
        .very-slow:hover {
            background: linear-gradient(145deg, #ff7722, #ee5511);
            box-shadow: 0 0 15px rgba(255, 119, 34, 0.5);
        }
        
        /* Slow - Orange Yellow */
        .slow {
            background: linear-gradient(145deg, #ffaa44, #cc8822);
            border-color: #ffbb55;
            color: #000000;
        }
        
        .slow:hover {
            background: linear-gradient(145deg, #ffbb55, #dd9933);
            box-shadow: 0 0 15px rgba(255, 187, 85, 0.5);
            color: #000000;
        }
        
        /* Moderate Slow - Golden Orange */
        .moderate-slow {
            background: linear-gradient(145deg, #ffdd00, #ccaa00);
            border-color: #ffee22;
            color: #000000;
        }
        
        .moderate-slow:hover {
            background: linear-gradient(145deg, #ffee22, #ddbb11);
            box-shadow: 0 0 15px rgba(255, 238, 34, 0.5);
            color: #000000;
        }
        
        /* Normal - White */
        .normal-btn {
            background: linear-gradient(145deg, #333333, #222222);
            color: #00ffff;
            border: 2px solid #00ffff;
            padding: 10px 20px;
            font-size: 12px;
            font-weight: bold;
            min-width: 120px;
            height: 45px;
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            line-height: 1.1;
            margin: 5px 0;
            cursor: pointer;
            transition: all 0.3s ease;
            border-radius: 12px;
        }
        
        .normal-btn:hover {
            background: linear-gradient(145deg, #444444, #333333);
            transform: translateY(-1px);
            box-shadow: 0 0 20px rgba(0, 255, 255, 0.6);
            border-color: #00ffff;
            color: #00ffff;
        }
        
        /* Moderate Fast - Light Lime Green */
        .moderate-fast {
            background: linear-gradient(145deg, #88cc44, #77bb33);
            border-color: #aaee66;
        }
        
        .moderate-fast:hover {
            background: linear-gradient(145deg, #99dd55, #88cc44);
            box-shadow: 0 0 15px rgba(170, 238, 102, 0.5);
        }
        
        /* Fast - Forest Green */
        .fast {
            background: linear-gradient(145deg, #228844, #116633);
            border-color: #44aa66;
        }
        
        .fast:hover {
            background: linear-gradient(145deg, #339955, #228844);
            box-shadow: 0 0 15px rgba(68, 170, 102, 0.5);
        }
        
        /* Very Fast - Cyan Blue */
        .very-fast {
            background: linear-gradient(145deg, #1199cc, #0077aa);
            border-color: #33bbff;
        }
        
        .very-fast:hover {
            background: linear-gradient(145deg, #22aadd, #1199cc);
            box-shadow: 0 0 15px rgba(51, 187, 255, 0.5);
        }
        
        /* Ultra Fast - Electric Purple */
        .ultra-fast {
            background: linear-gradient(145deg, #8844cc, #6633aa);
            border-color: #aa66ff;
        }
        
        .ultra-fast:hover {
            background: linear-gradient(145deg, #9955dd, #8844cc);
            box-shadow: 0 0 15px rgba(170, 102, 255, 0.5);
        }
        
        .super-slow {
            background: linear-gradient(145deg, #cc0000, #aa0000);
            border-color: #dd1111;
        }
        
        .super-slow:hover {
            background: linear-gradient(145deg, #dd1111, #bb1111);
            box-shadow: 0 0 15px rgba(221, 17, 17, 0.5);
        }
        
        .super-fast {
            background: linear-gradient(145deg, #ff6600, #dd4400);
            border-color: #ff7722;
        }
        
        .super-fast:hover {
            background: linear-gradient(145deg, #ff7722, #ee5511);
            box-shadow: 0 6px 15px rgba(255, 102, 0, 0.4);
        }
        
        .hyper-fast {
            background: linear-gradient(145deg, #ff3366, #dd1144);
            border-color: #ff4477;
        }
        
        .hyper-fast:hover {
            background: linear-gradient(145deg, #ff4477, #ee2255);
            box-shadow: 0 6px 15px rgba(255, 51, 102, 0.4);
        }
        
        .speed-slider::-webkit-slider-thumb {
            -webkit-appearance: none;
            width: 20px;
            height: 20px;
            background: radial-gradient(circle, #00ffff, #0088ff);
            border: 2px solid #ffffff;
            border-radius: 50%;
            cursor: pointer;
            box-shadow: 0 0 10px rgba(0, 255, 255, 0.8), 0 0 20px rgba(0, 255, 255, 0.4);
            transition: all 0.2s ease;
        }
        
        .speed-slider::-webkit-slider-thumb:hover {
            transform: scale(1.2);
            box-shadow: 0 0 15px rgba(0, 255, 255, 1), 0 0 30px rgba(0, 255, 255, 0.6);
        }
        
        .speed-slider::-moz-range-thumb {
            width: 20px;
            height: 20px;
            background: radial-gradient(circle, #00ffff, #0088ff);
            border: 2px solid #ffffff;
            border-radius: 50%;
            cursor: pointer;
            box-shadow: 0 0 10px rgba(0, 255, 255, 0.8);
        }
        
        /* Removed old speed-labels and speed-label styles as they're no longer needed */
        
        .loading {
            text-align: center;
            display: flex;
            align-items: center;
            gap: 20px;
            padding: 30px;
            color: #94a3b8;
            font-size: 1.2em;
            font-weight: 500;
        }
        
        .loading::after {
            content: "";
            display: inline-block;
            width: 24px;
            height: 24px;
            border: 3px solid #94a3b8;
            border-radius: 50%;
            border-top-color: transparent;
            animation: spin 1s linear infinite;
            margin-left: 15px;
        }
        
        @keyframes spin {
            to { transform: rotate(360deg); }
        }
        
        @keyframes pulse {
            0%, 100% { opacity: 0.4; }
            50% { opacity: 1; }
        }
        
        @keyframes shimmer {
            0% { left: -100%; }
            100% { left: 100%; }
        }
        
        .error {
            background: rgba(220, 53, 69, 0.1);
            border: 1px solid #dc3545;
            color: #dc3545;
            padding: 18px;
            border-radius: 10px;
            margin: 20px 0;
            text-align: center;
            display: flex;
            align-items: center;
            gap: 20px;
            word-wrap: break-word;
            font-weight: 500;
        }
        
        .success {
            background: rgba(40, 167, 69, 0.1);
            border: 1px solid #28a745;
            color: #28a745;
            padding: 18px;
            border-radius: 10px;
            margin: 20px 0;
            text-align: center;
            display: flex;
            align-items: center;
            gap: 20px;
            word-wrap: break-word;
            font-weight: 500;
        }
        
        /* Modal Styles */
        .modal {
            display: none;
            position: fixed;
            z-index: 1000;
            left: 0;
            top: 0;
            width: 100%;
            height: 100%;
            background-color: rgba(0,0,0,0.95);
            backdrop-filter: blur(8px);
        }
        
        .modal-content {
            background: #000000;
            margin: 2% auto;
            padding: 0;
            border-radius: 20px;
            width: 95%;
            max-width: 1600px;
            height: 90%;
            overflow: hidden;
            box-shadow: 0 25px 80px rgba(0,0,0,0.9);
            border: 2px solid #475569;
        }
        
        .modal-header {
            background: linear-gradient(135deg, #475569, #334155);
            color: white;
            padding: 25px;
            display: flex;
            justify-content: space-between;
            align-items: center;
        }
        
        .modal-header h2 {
            margin: 0;
            font-size: 1.8em;
        }

        /* Playlist Modal Override */
        .playlist-modal-content {
            width: fit-content !important;
            height: auto !important;
        }
        
.download-debug-btn {
    background: #28a745;
    color: white;
    border: none;
    padding: 8px 16px;
    border-radius: 5px;
    cursor: pointer;
    font-size: 14px;
    font-weight: bold;
    
    transition: background 0.3s ease;
}

.download-debug-btn:hover {
modal-header-buttons {
    display: flex;
    gap: 10px;
    align-items: center;
}
    background: #218838;
}

        .close {
            background: rgba(255,255,255,0.2);
            color: white;
            border: none;
            padding: 12px 16px;
            border-radius: 50%;
            cursor: pointer;
            font-size: 18px;
            font-weight: bold;
            transition: all 0.3s ease;
        }
        
        .close:hover {
            background: rgba(255,255,255,0.3);
            transform: scale(1.1) rotate(90deg);
        }
        
        .modal-body {
            padding: 30px;
            height: calc(100% - 100px);
            overflow-y: auto;
            font-family: 'Consolas', monospace;
            font-size: 14px;
            line-height: 1.6;
            color: #e0e0e0;
        }
        
        /* Responsive design */
        @media (max-width: 768px) {
            .main-layout {
                grid-template-columns: 1fr;
                height: auto;
                gap: 15px;
            }
            
            .header h1 {
                font-size: 1.8em;
            }
            
            .toggle-container {
                flex-wrap: wrap;
                border-radius: 15px;
                gap: 5px;
            }
            
            .toggle-btn {
                padding: 12px 20px;
                border-radius: 10px;
            }
            
            .header-buttons {
                position: relative;
                margin-top: 35px;
                justify-content: center;
                flex-wrap: wrap;
            }
        }

        /* Terminal Modal Styles */
        .terminal-modal {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0, 0, 0, 0.8);
            z-index: 9999;
            display: none;
            justify-content: center;
            align-items: center;
            animation: fadeIn 0.3s ease-in-out;
        }

        .terminal-modal.show {
            display: flex;
        }

        @keyframes fadeIn {
            from { opacity: 0; }
            to { opacity: 1; }
        }

        .terminal-window {
            background: linear-gradient(135deg, #0a0a0a, #1a1a1a);
            border: 2px solid #475569;
            border-radius: 15px;
            width: 95%;
            max-width: 1200px;
            height: 80%;
            max-height: 700px;
            padding: 0;
            overflow: hidden;
            box-shadow: 0 10px 40px rgba(0, 0, 0, 0.6);
            animation: slideIn 0.3s ease-out;
        }

        @keyframes slideIn {
            from { transform: scale(0.8); opacity: 0; }
            to { transform: scale(1); opacity: 1; }
        }

        .terminal-header {
            background: linear-gradient(135deg, #475569, #334155);
            padding: 15px 20px;
            display: flex;
            justify-content: space-between;
            align-items: center;
            border-bottom: 2px solid #333;
        }

        .terminal-title {
            color: white;
            font-size: 1.2em;
            font-weight: 600;
            display: flex;
            align-items: center;
            gap: 10px;
        }

        .terminal-close-btn {
            background: #dc3545;
            color: white;
            border: none;
            width: 35px;
            height: 35px;
            border-radius: 50%;
            font-size: 18px;
            font-weight: bold;
            cursor: pointer;
            transition: all 0.3s ease;
            display: flex;
            align-items: center;
            justify-content: center;
        }

        .terminal-close-btn:hover {
            background: #c82333;
            transform: scale(1.1);
        }

        .terminal-body {
            padding: 20px;
            height: calc(100% - 70px);
            display: flex;
            flex-direction: column;
        }

        .terminal-controls {
            margin-bottom: 20px;
        }

        .quick-commands {
            display: flex;
            gap: 10px;
            flex-wrap: wrap;
            margin-bottom: 15px;
        }

        .quick-cmd-btn {
            background: linear-gradient(135deg, #4a4a4a, #333333);
            color: white;
            border: none;
            padding: 8px 16px;
            border-radius: 20px;
            cursor: pointer;
            font-size: 12px;
            font-weight: 600;
            transition: all 0.3s ease;
            font-family: 'Courier New', monospace;
        }

        .quick-cmd-btn:hover {
            background: linear-gradient(135deg, #555555, #2a2a2a);
            transform: translateY(-1px);
        }

        .quick-cmd-btn.clear-btn {
            background: linear-gradient(135deg, #dc3545, #c82333);
        }

        .terminal-input-section {
            display: flex;
            gap: 10px;
            align-items: center;
            margin-bottom: 20px;
        }

        .terminal-prompt {
            color: #28a745;
            font-family: 'Courier New', monospace;
            font-weight: bold;
            white-space: nowrap;
        }

        .terminal-input {
            flex: 1;
            background: rgba(255, 255, 255, 0.1);
            color: white;
            border: 2px solid #333;
            padding: 12px 15px;
            border-radius: 8px;
            font-family: 'Courier New', monospace;
            font-size: 16px;
        }

        .terminal-input:focus {
            outline: none;
            border-color: #475569;
            box-shadow: 0 0 10px rgba(0, 188, 212, 0.3);
        }

        .terminal-execute-btn {
            background: linear-gradient(135deg, #28a745, #218838);
            color: white;
            border: none;
            padding: 12px 20px;
            border-radius: 8px;
            cursor: pointer;
            font-weight: 600;
            transition: all 0.3s ease;
        }

        .terminal-execute-btn:hover {
            background: linear-gradient(135deg, #218838, #1e7e34);
            transform: translateY(-2px);
        }

        .terminal-output {
            flex: 1;
            background: rgba(0, 0, 0, 0.8);
            border: 2px solid #333;
            border-radius: 10px;
            padding: 20px;
            overflow-y: auto;
            font-family: 'Courier New', monospace;
            font-size: 16px;
            line-height: 1.4;
            color: white;
            white-space: pre-wrap;
            word-break: break-all;
        }

        .terminal-output::-webkit-scrollbar {
            width: 10px;
        }

        .terminal-output::-webkit-scrollbar-track {
            background: rgba(0, 0, 0, 0.3);
            border-radius: 5px;
        }

        .terminal-output::-webkit-scrollbar-thumb {
            background: rgba(0, 188, 212, 0.6);
            border-radius: 5px;
        }

        .terminal-output::-webkit-scrollbar-thumb:hover {

/* API Modal Styles */
.api-modal {
    position: fixed;
    z-index: 10000;
    left: 0;
    top: 0;
    width: 100%;
    height: 100%;
    background-color: rgba(0,0,0,0.5);
}

.api-modal-content {
    background-color: #1a1a2e;
    margin: 5% auto;
    padding: 20px;
    border: 1px solid #e94560;
    border-radius: 10px;
    width: 80%;
    max-width: 1600px;
    color: white;
}

.api-modal-header {
    display: flex;
    justify-content: space-between;
    align-items: center;
    margin-bottom: 20px;
}

.api-close {
    color: #e94560;
    font-size: 28px;
    font-weight: bold;
    cursor: pointer;
}

.api-close:hover {
    color: #ff6b88;
}

.api-credentials {
    margin-bottom: 20px;
}

.api-credentials label {
    display: inline-block;
    width: 80px;
    color: #e94560;
    font-weight: bold;
}

.api-credentials input {
    width: 200px;
    padding: 8px;
    margin: 5px 10px;
    background: #0f0a1a;
    border: 1px solid #16213e;
    border-radius: 4px;
    color: #f39c12;
}

.api-buttons button {
    margin: 5px;
    padding: 10px 15px;
    background: linear-gradient(45deg, #16213e, #1a1a2e);
    border: 1px solid #e94560;
    border-radius: 5px;
    color: #e94560;
    cursor: pointer;
    font-weight: bold;
}

.api-buttons button:hover {
    background: linear-gradient(45deg, #e94560, #ff6b88);
    color: white;
}

.api-output {
    margin-top: 20px;
}

#api-command {
    background: #0f0a1a;
    padding: 10px;
    border-radius: 4px;
    font-family: monospace;
    color: #f39c12;
    margin-bottom: 10px;
}

#api-result {
    background: #000;
    color: #00ff00;
    padding: 15px;
    border-radius: 4px;
    min-height: 150px;
    font-family: monospace;
    overflow-x: auto;
}
            background: rgba(0, 188, 212, 0.8);
        }

        .xterm-container {
            flex: 1;
            padding: 10px;
            background: #000;
            border-radius: 10px;
            overflow: hidden;
        }
        
        .xterm-container .xterm {
            height: 100%;
        }
        
        .xterm-container .xterm-viewport {
            background: #000;
        }
        
        /* Custom Confirmation Modal Styles */
        .confirmation-modal {
            display: none;
            position: fixed;
            z-index: 2000;
            left: 0;
            top: 0;
            width: 100%;
            height: 100%;
            background-color: rgba(0, 0, 0, 0.8);
            backdrop-filter: blur(5px);
        }
        
        .confirmation-modal-content {
            background: #000000;
            margin: 15% auto;
            padding: 0;
            border-radius: 20px;
            width: auto;
            max-width: 1000px;
            min-width: 800px;
            min-height: auto;
            height: fit-content;
            box-shadow: 0 25px 80px rgba(0, 0, 0, 0.9);
            border: 2px solid #dc3545;
            animation: modalSlideIn 0.3s ease-out;
        }
        
        @keyframes modalSlideIn {
            from {
                transform: translateY(-50px);
                opacity: 0;
            }
            to {
                transform: translateY(0);
                opacity: 1;
            }
        }
        
        .confirmation-modal-header {
            background: linear-gradient(135deg, #dc3545, #c82333);
            color: white;
            padding: 20px;
            border-radius: 18px 18px 0 0;
            display: flex;
            align-items: center;
            gap: 15px;
        }
        
        .confirmation-modal-header h3 {
            margin: 0;
            font-size: 1.3em;
            font-weight: 600;
        }
        
        .confirmation-modal-header .icon {
            font-size: 1.5em;
            opacity: 0.9;
        }
        
        .confirmation-modal-body {
            padding: 20px 25px;
            color: #e0e0e0;
            font-size: 1.1em;
            line-height: 1.4;
        }
        
        .file-list {
            background: rgba(0, 0, 0, 0.3);
            border-radius: 10px;
            padding: 15px;
            margin: 15px 0;
            border-left: 4px solid #dc3545;
            max-height: 500px;
            overflow-y: auto;
        }
        
        .file-list-item {
            padding: 5px 0;
            color: #ffc107;
            font-weight: 500;
        }
        
        .file-list-item::before {
            content: " ";
            color: #dc3545;
            font-weight: bold;
            margin-right: 5px;
        }
        
        .confirmation-modal-footer {
            padding: 15px 25px;
            display: flex;
            justify-content: flex-end;
            gap: 15px;
            background: rgba(0, 0, 0, 0.1);
            border-radius: 0 0 18px 18px;
        }
        
        .modal-btn {
            padding: 12px 24px;
            border: none;
            border-radius: 25px;
            font-size: 14px;
            font-weight: 600;
            cursor: pointer;
            transition: all 0.3s ease;
            min-width: 100px;
        }
        
        .modal-btn-cancel {
            background: linear-gradient(135deg, #6c757d, #5a6268);
            color: white;
            box-shadow: 0 4px 15px rgba(108, 117, 125, 0.3);
        }
        
        .modal-btn-cancel:hover {
            background: linear-gradient(135deg, #5a6268, #495057);
            transform: translateY(-2px);
            box-shadow: 0 8px 25px rgba(108, 117, 125, 0.4);
        }
        
        .modal-btn-delete {
            background: linear-gradient(135deg, #dc3545, #c82333);
            color: white;
            box-shadow: 0 4px 15px rgba(220, 53, 69, 0.3);
        }
        
        .modal-btn-delete:hover {
            background: linear-gradient(135deg, #c82333, #bd2130);
            transform: translateY(-2px);
            box-shadow: 0 8px 25px rgba(220, 53, 69, 0.4);
        }
        
        .warning-text {
            color: #ffc107;
            font-weight: 600;
            font-size: 1.0em;
            margin-top: 10px;
        }
        
        /* Success Modal Styles */
        .success-modal {
            display: none;
            position: fixed;
            z-index: 2000;
            left: 0;
            top: 0;
            width: 100%;
            height: 100%;
            background-color: rgba(0, 0, 0, 0.8);
            backdrop-filter: blur(5px);
        }
        
        .success-modal-content {
            background: #000000;
            margin: 5% auto;
            padding: 0;
            border-radius: 20px;
            width: 95%;
            max-width: 1600px;
            min-height: auto;
            height: auto;
            box-shadow: 0 25px 80px rgba(0, 0, 0, 0.9);
            border: 2px solid #28a745;
            animation: successModalSlideIn 0.4s ease-out;
        }
        
        @keyframes successModalSlideIn {
            from {
                transform: translateY(-50px) scale(0.9);
                opacity: 0;
            }
            to {
                transform: translateY(0) scale(1);
                opacity: 1;
            }
        }
        
        .success-modal-header {
            background: linear-gradient(135deg, #28a745, #218838);
            color: white;
            padding: 25px;
            border-radius: 18px 18px 0 0;
            display: flex;
            align-items: center;
            justify-content: center;
            gap: 10px;
        }
        
        .success-modal-header h3 {
            margin: 0;
            font-size: 1.4em;
            font-weight: 600;
        }
        
        .success-modal-header .success-icon {
            font-size: 2em;
            animation: successPulse 1.5s ease-in-out;
        }
        
        @keyframes successPulse {
            0%, 100% { transform: scale(1); }
            50% { transform: scale(1.1); }
        }
        
        .success-modal-body {
            padding: 30px;
            color: #e0e0e0;
            font-size: 1.1em;
            line-height: 1.6;
            text-align: center;
            display: flex;
            flex-direction: column;
            gap: 15px;
        }
        
        .success-details {
            background: rgba(40, 167, 69, 0.1);
            border-radius: 10px;
            padding: 20px;
            margin: 20px 0;
            border-left: 4px solid #28a745;
        }
        
        .success-count {
            font-size: 1.3em;
            font-weight: bold;
            color: #28a745;
            margin-bottom: 10px;
        }
        
        .success-file-list {
            max-height: 500px;
            overflow-y: auto;
            text-align: left;
            padding: 10px;
        }
        
        .success-file-item {
            display: flex;
            align-items: center;
            text-align: left !important;
            padding: 8px;
            background: rgba(255,255,255,0.05);
            margin: 2px 0;
            border-radius: 4px;
        }
        
        .file-list-item {
            display: flex;
            align-items: center;
            text-align: left !important;
            padding: 8px;
            background: rgba(255,255,255,0.05);
            margin: 2px 0;
            border-radius: 4px;
        }
        
        .file-item-line {
            flex: 1;
            height: 1px;
            margin: 0 10px;
            border-top: 2px dotted;
        }
        
        .file-size-small {
            border-color: #10b981;
        }
        
        .file-size-medium {
            border-color: #fbbf24;
        }
        
        .file-size-large {
            border-color: #ef4444;
        }
        
        .file-size-huge {
            border-color: #8b5cf6;
        }
        
        .success-file-item {
            text-align: left !important;
        }
        
        .file-list-item {
            text-align: left !important;
        }
        
        .success-file-item {
            padding: 5px 0;
            color: #90EE90;
            font-weight: 500;
        }
        
        .success-file-item::before {
            content: " ";
            color: #28a745;
            font-weight: bold;
            margin-right: 5px;
        }
        
        .success-modal-footer {
            padding: 20px;
            display: flex;
            justify-content: center;
            background: rgba(0, 0, 0, 0.1);
            border-radius: 0 0 18px 18px;
        }
        
        .success-modal-btn {
            background: linear-gradient(135deg, #28a745, #218838);
            color: white;
            border: none;
            padding: 12px 30px;
            border-radius: 25px;
            font-size: 14px;
            font-weight: 600;
            cursor: pointer;
            transition: all 0.3s ease;
            min-width: 120px;
            box-shadow: 0 4px 15px rgba(40, 167, 69, 0.3);
        }
        
        .success-modal-btn:hover {
            background: linear-gradient(135deg, #218838, #1e7e34);
            transform: translateY(-2px);
            box-shadow: 0 8px 25px rgba(40, 167, 69, 0.4);
        }
        
        /* Refresh Data Modal Styles */
        .refresh-data-modal {
            display: none;
            position: fixed;
            z-index: 1000;
            left: 0;
            top: 0;
            width: 100%;
            height: 100%;
            background-color: rgba(0, 0, 0, 0.8);
            backdrop-filter: blur(5px);
        }
        
        .refresh-data-modal-content {
            background: #000000;
            margin: 8% auto;
            padding: 0;
            border-radius: 20px;
            width: 95%;
            max-width: 1000px;
            max-height: 80vh;
            overflow: hidden;
            box-shadow: 0 25px 80px rgba(0, 0, 0, 0.9);
            border: 2px solid #475569;
            animation: refreshModalSlideIn 0.4s ease-out;
        }
        
        @keyframes refreshModalSlideIn {
            from {
                transform: translateY(-50px) scale(0.9);
                opacity: 0;
            }
            to {
                transform: translateY(0) scale(1);
                opacity: 1;
            }
        }
        
        .refresh-data-modal-header {
            background: linear-gradient(135deg, #475569, #334155);
            color: white;
            padding: 25px;
            border-radius: 18px 18px 0 0;
            display: flex;
            align-items: center;
            justify-content: space-between;
        }
        
        .refresh-data-modal-header h3 {
            margin: 0;
            font-size: 1.5em;
            font-weight: 600;
            display: flex;
            align-items: center;
            gap: 15px;
        }
        
        .refresh-data-modal-close {
            background: rgba(255, 255, 255, 0.2);
            color: white;
            border: none;
            padding: 10px 15px;
            border-radius: 50%;
            cursor: pointer;
            font-size: 18px;
            font-weight: bold;
            transition: all 0.3s ease;
        }
        
        .refresh-data-modal-close:hover {
            background: rgba(255, 255, 255, 0.3);
            transform: scale(1.1);
        }
        
        .refresh-data-modal-body {
            padding: 30px;
            color: #e0e0e0;
            font-size: 1.1em;
            line-height: 1.6;
            max-height: 60vh;
            overflow-y: auto;
        }
        
        .refresh-summary {
            background: rgba(71, 85, 105, 0.1);
            border-radius: 10px;
            padding: 20px;
            margin-bottom: 25px;
            border-left: 4px solid #475569;
            text-align: left;
            display: flex !important;
            flex-direction: column !important;
            gap: 15px !important;
        }
        
        .file-count-display {
            font-size: 1.4em;
            font-weight: bold;
            color: #94a3b8;
            margin-bottom: 15px;
        }
        
        .new-files-section {
            background: rgba(40, 167, 69, 0.1);
            border-radius: 10px;
            padding: 20px;
            margin: 20px 0;
            border-left: 4px solid #28a745;
        }
        
        .new-files-header {
            font-size: 1.2em;
            font-weight: bold;
            color: #28a745;
            margin-bottom: 15px;
            display: flex;
            align-items: center;
            gap: 10px;
        }
        
        .new-file-item {
            padding: 8px 0;
            color: #90EE90;
            font-weight: 500;
            display: flex;
            align-items: center;
            gap: 10px;
        }
        
        .new-file-item::before {
            content: "";
            font-size: 1.2em;
        }
        
        .all-files-section {
            background: rgba(0, 0, 0, 0.2);
            border-radius: 10px;
            padding: 20px;
            margin: 20px 0;
            border: 1px solid #333;
        }
        
        .all-files-header {
            font-size: 1.1em;
            font-weight: bold;
            color: #94a3b8;
            margin-bottom: 15px;
            display: flex;
            align-items: center;
            justify-content: space-between;
            cursor: pointer;
        }
        
        .file-dropdown {
            max-height: 0;
            overflow: hidden;
            transition: max-height 0.3s ease;
        }
        
        .file-dropdown.open {
            max-height: 300px;
            overflow-y: auto;
        }
        
        .file-item {
            padding: 5px 0;
            color: #ccc;
            font-size: 0.95em;
            display: flex;
            align-items: center;
            gap: 10px;
        }
        
        
        .dropdown-toggle {
            font-size: 1.2em;
            transition: transform 0.3s ease;
        }
        
        .dropdown-toggle.open {
            transform: rotate(180deg);
        }
        
        /* Enhanced Navigation Styles */
        .quick-nav-btn {
            background: rgba(71, 85, 105, 0.2);
            border: 1px solid #475569;
            color: #e2e8f0;
            padding: 10px 18px;
            border-radius: 6px;
            cursor: pointer;
            font-size: 12px;
            transition: all 0.2s ease;
        }
        
        .quick-nav-btn:hover {
            background: rgba(71, 85, 105, 0.4);
            transform: translateY(-1px);
        }
        
        .breadcrumb-segment {
            transition: all 0.2s ease;
        }
        
        .breadcrumb-segment:hover {
            background: #334155 !important;
            transform: translateY(-1px);
        }
        
        #nav-up-btn:hover {
            background: rgba(71, 85, 105, 0.5) !important;
            transform: translateY(-1px);
        }
        .quota-btn {
            background: transparent !important;
            color: #00bcd4 !important;
            border: 1px solid #00bcd4 !important;
            padding: 10px 18px;
            border-radius: 4px;
            cursor: pointer;
            font-size: 14px;
            font-weight: 500;
            transition: all 0.3s ease;
            margin-top: 5px;
        }

        .quota-btn:hover {
            transform: scale(1.1) !important;
            box-shadow: 0 0 10px rgba(0, 188, 212, 0.8) !important;
            color: #4dd0e1 !important;
            border-color: #4dd0e1 !important;
            background: transparent !important;
        }
       .storage-details-vertical {
            display: flex;
            flex-direction: column;
            gap: 4px;
            margin-top: 8px;
        }

        .storage-detail-item {
            display: flex;
            justify-content: space-between;
            align-items: center;
            padding: 6px 10px;
            border-radius: 4px;
            font-size: 11px;
            font-weight: 500;
            background: rgba(0, 0, 0, 0.2);
        }

        .storage-available {
            color: #4ade80;
            border-left: 3px solid #4ade80;
        }

        .storage-reserve {
            color: #fbbf24;
            border-left: 3px solid #fbbf24;
        }

        .storage-upload-limit {
            color: #8b5cf6;
            border-left: 3px solid #ef4444;
        }
       .storage-details-vertical {
            display: flex;
            flex-direction: column;
            gap: 4px;
            margin-top: 35px;
        }

        .storage-detail-item {
            display: flex;
            justify-content: space-between;
            align-items: center;
            padding: 6px 10px;
            border-radius: 4px;
            font-size: 13px;
            font-weight: 500;
            background: rgba(0, 0, 0, 0.2);
            color: white;
        }

        .storage-available {
            border-left: 3px solid #4ade80;
        }

        .storage-reserve {
            border-left: 3px solid #fbbf24;
        }

        .storage-upload-limit {
            border-left: 3px solid #ef4444;
        }
       /* In-modal notifications */
        .quota-notification {
            position: fixed;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            background: linear-gradient(135deg, #1a1a1a, #2a2a2a);
            border: 2px solid #4CAF50;
            border-radius: 12px;
            padding: 20px;
            min-width: 350px;
            max-width: 500px;
            box-shadow: 0 10px 30px rgba(0,0,0,0.8), 0 0 20px rgba(76, 175, 80, 0.3);
            z-index: 10000;
            animation: notificationSlideIn 0.3s ease-out;
        }
        
        .quota-notification.error {
            border-color: #dc2626;
            box-shadow: 0 10px 30px rgba(0,0,0,0.8), 0 0 20px rgba(255, 107, 107, 0.3);
        }
        
        .quota-notification-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 15px;
            padding-bottom: 10px;
            border-bottom: 1px solid #333;
        }
        
        .quota-notification-title {
            color: #4CAF50;
            font-size: 16px;
            font-weight: 600;
            display: flex;
            align-items: center;
            gap: 8px;
        }
        
        .quota-notification.error .quota-notification-title {
            color: #dc2626;
        }
        
        .quota-notification-close {
            background: transparent;
            border: none;
            color: #999;
            font-size: 20px;
            cursor: pointer;
            width: 30px;
            height: 30px;
            border-radius: 50%;
            display: flex;
            align-items: center;
            justify-content: center;
            transition: all 0.3s ease;
        }
        
        .quota-notification-close:hover {
            background: rgba(255,255,255,0.1);
            color: #fff;
            transform: scale(1.1);
        }
        
        .quota-notification-body {
            color: #e0e0e0;
            font-size: 14px;
            line-height: 1.5;
        }
        
        @keyframes notificationSlideIn {
            0% {
                opacity: 0;
                transform: translate(-50%, -50%) scale(0.9);
            }
            100% {
                opacity: 1;
                transform: translate(-50%, -50%) scale(1);
            }
        }
       /* Quota Success Modal */
        .quota-success-modal {
            display: none;
            position: fixed;
            z-index: 10000;
            left: 0;
            top: 0;
            width: 100%;
            height: 100%;
            background-color: rgba(0,0,0,0.8);
        }

        .quota-success-content {
            background: #2a2a2a;
            margin: 20% auto;
            padding: 0;
            border-radius: 10px;
            width: 90%;
            max-width: 400px;
            border: 2px solid #4CAF50;
        }


        /* Quota Error Modal */
        .quota-error-modal {
            display: none;
            position: fixed;
            z-index: 10000;
            left: 0;
            top: 0;
            width: 100%;
            height: 100%;
            background-color: rgba(0,0,0,0.8);
        }

        .quota-error-content {
            background: #2a2a2a;
            margin: 10% auto;
            padding: 0;
            border-radius: 10px;
            width: 90%;
            max-width: 1000px;
            min-height: auto;
            border: 2px solid #dc2626;
        }
        
        .refresh-modal-content {
            background: #000000;
            margin: 10% auto;
            padding: 0;
            border-radius: 10px;
            width: 90%;
            max-width: 800px;
            min-height: 400px;
            border: 2px solid #4CAF50;
        }
        
        /* Custom Speed Controls Styling */
        .custom-speed-container {
            margin-top: 45px;
            padding: 10px;
            background: linear-gradient(135deg, rgba(30, 30, 30, 0.9), rgba(50, 50, 50, 0.8));
            border: 1px solid rgba(0, 255, 255, 0.3);
            border-radius: 10px;
            box-shadow: 0 4px 12px rgba(0, 255, 255, 0.1);
            position: relative;
            overflow: hidden;
        }
        
        .custom-speed-container::before {
            content: '';
            position: absolute;
            top: -50%;
            left: -50%;
            width: 200%;
            height: 200%;
            background: linear-gradient(45deg, transparent, rgba(0, 255, 255, 0.05), transparent);
            animation: cosmic-glow 4s linear infinite;
            pointer-events: none;
        }
        
        @keyframes cosmic-glow {
            0% { transform: rotate(0deg); }
            100% { transform: rotate(360deg); }
        }
        
        .custom-speed-header {
            display: flex;
            align-items: center;
            justify-content: center;
            gap: 6px;
            margin-bottom: 6px;
            position: relative;
            z-index: 1;
        }
        
        .custom-icon {
            font-size: 12px;
            filter: drop-shadow(0 0 4px rgba(255, 215, 0, 0.7));
        }
        
        @keyframes pulse-icon {
            0%, 100% { transform: scale(1); }
            50% { transform: scale(1.15); }
        }
        
        .custom-text {
            color: #00ffff;
            font-size: 11px;
            font-weight: bold;
            text-shadow: 0 0 4px rgba(0, 255, 255, 0.6);
        }
        
        .custom-speed-input-group {
            display: flex;
            align-items: center;
            justify-content: center;
            gap: 8px;
            margin: 6px 0;
            position: relative;
            z-index: 1;
        }
        
        .custom-speed-input {
            width: 60px;
            padding: 6px 8px;
            background: linear-gradient(135deg, rgba(0, 0, 0, 0.9), rgba(20, 20, 40, 0.8));
            color: #00ffff;
            border: 1px solid rgba(0, 255, 255, 0.4);
            border-radius: 8px;
            text-align: center;
            font-size: 12px;
            font-weight: bold;
            outline: none;
            transition: all 0.3s ease;
        }
        
        .custom-speed-input:focus {
            border-color: #00ffff;
            box-shadow: 0 0 20px rgba(0, 255, 255, 0.4), inset 0 2px 6px rgba(0, 255, 255, 0.1);
            transform: scale(1.05);
        }
        
        .custom-speed-input::placeholder {
            color: rgba(0, 255, 255, 0.5);
        }
        
        .speed-multiplier {
            color: #fff;
            font-size: 16px;
            font-weight: bold;
            text-shadow: 0 0 6px rgba(255, 255, 255, 0.5);
        }
        
        .custom-apply-btn {
            background: linear-gradient(135deg, #22c55e, #16a34a);
            color: white;
            border: 1px solid rgba(34, 197, 94, 0.6);
            padding: 6px 12px;
            border-radius: 8px;
            font-size: 11px;
            font-weight: bold;
            cursor: pointer;
            transition: all 0.3s ease;
            display: flex;
            align-items: center;
            gap: 4px;
            position: relative;
            overflow: hidden;
            box-shadow: 0 2px 8px rgba(34, 197, 94, 0.3);
        }
        
        .custom-apply-btn::before {
            content: '';
            position: absolute;
            top: 0;
            left: -100%;
            width: 100%;
            height: 100%;
            background: linear-gradient(90deg, transparent, rgba(255, 255, 255, 0.2), transparent);
            transition: left 0.5s ease;
        }
        
        .custom-apply-btn:hover {
            background: linear-gradient(135deg, #16a34a, #22c55e);
            transform: scale(1.1);
            box-shadow: 0 8px 25px rgba(34, 197, 94, 0.6);
            border-color: #22c55e;
        }
        
        .custom-apply-btn:hover::before {
            left: 100%;
        }
        
        .apply-icon {
            font-size: 12px;
            filter: drop-shadow(0 0 4px rgba(255, 255, 0, 0.8));
        }
        
        .apply-text {
            font-weight: bold;
        }
        
        .custom-speed-hint {
            color: rgba(255, 255, 255, 0.6);
            font-size: 9px;
            text-align: center;
            margin-top: 4px;
            font-style: italic;
            position: relative;
            z-index: 1;
        }
        
        /* Enhanced Current Speed Display */
        .current-speed-display {
            text-align: center;
            margin-top: 10px;
            padding: 8px;
            background: linear-gradient(135deg, rgba(0, 0, 0, 0.6), rgba(30, 30, 60, 0.4));
            border: 1px solid rgba(0, 255, 255, 0.3);
            border-radius: 10px;
            position: relative;
            box-shadow: 0 3px 10px rgba(0, 0, 0, 0.3);
        }
        
        .playing-status-container {
            display: flex;
            align-items: center;
            justify-content: center;
            gap: 8px;
            margin-bottom: 4px;
        }
        
        .playing-icon {
            font-size: 12px;
            filter: drop-shadow(0 0 4px rgba(255, 215, 0, 0.8));
            animation: movie-spin 3s linear infinite;
        }
        
        @keyframes movie-spin {
            0% { transform: rotate(0deg); }
            100% { transform: rotate(360deg); }
        }
        
        .current-speed-text {
            color: white;
            font-weight: bold;
            font-size: 13px;
            text-shadow: 0 0 6px rgba(255, 255, 255, 0.5);
        }
        
        .custom-speed-message {
            color: #00ffff;
            font-size: 12px;
            margin-top: 4px;
            font-weight: 600;
            text-shadow: 0 0 4px rgba(0, 255, 255, 0.6);
            display: none;
            animation: message-glow 2s ease-in-out infinite;
        }
        
        @keyframes message-glow {
            0%, 100% { opacity: 0.8; }
            50% { opacity: 1; }
        }
        
        /* System Specs Modal Styles */
        .system-specs-modal {
            display: none;
            position: fixed;
            z-index: 10000;
            left: 0;
            top: 0;
            width: 100%;
            height: 100%;
            background-color: rgba(0, 0, 0, 0.9);
            animation: fadeIn 0.3s ease-in-out;
        }

        .system-specs-modal-content {
            background: linear-gradient(135deg, #000000, #1a1a1a);
            margin: 2% auto;
            padding: 0;
            border: 3px solid #444444;
            border-radius: 15px;
            width: 95%;
            max-width: 1400px;
            height: 90%;
            box-shadow: 0 0 30px rgba(68, 68, 68, 0.5);
            display: flex;
            flex-direction: column;
        }

        .system-specs-header {
            background: linear-gradient(135deg, #2a2a2a, #3a3a3a);
            color: white;
            padding: 15px 20px;
            border-radius: 12px 12px 0 0;
            display: flex;
            justify-content: space-between;
            align-items: center;
            font-weight: bold;
            border-bottom: 2px solid #444444;
        }

        .system-specs-title {
            font-size: 24px;
            font-weight: bold;
            text-transform: uppercase;
            letter-spacing: 2px;
            color: white;
            text-shadow: 2px 2px 4px rgba(0, 0, 0, 0.8);
        }

        .system-specs-close {
            color: white;
            font-size: 32px;
            font-weight: bold;
            cursor: pointer;
            transition: all 0.3s ease;
        }

        .system-specs-close:hover {
            transform: scale(1.2);
            text-shadow: 0 0 10px rgba(255, 0, 0, 0.8);
            color: #ff4444;
        }

        .system-specs-body {
            flex: 1;
            padding: 20px;
            overflow-y: auto;
            background: #000000;
            border-radius: 0 0 12px 12px;
        }

        .system-specs-terminal {
            background: #000000;
            color: #ffffff;
            font-family: 'Courier New', monospace;
            font-size: 14px;
            line-height: 1.6;
            padding: 20px;
            border-radius: 8px;
            border: 2px solid #444444;
            height: 100%;
            overflow-y: auto;
            white-space: pre-wrap;
            text-shadow: 1px 1px 2px rgba(0, 0, 0, 0.8);
        }
        
        .section-separator {
            color: #00ff00;
            font-weight: normal;
            text-shadow: 0 0 3px #00ff00;
        }
        
        .section-title {
            color: #00ff00;
            font-weight: normal;
            text-shadow: 0 0 3px #00ff00;
        }

        .system-specs-loading {
            color: #ffff00;
            text-align: center;
            font-size: 16px;
            padding: 50px;
            animation: blink 1s infinite;
        }

        @keyframes blink {
            0%, 50% { opacity: 1; }
            51%, 100% { opacity: 0.3; }
        }

        /* Custom Delete Confirmation Modal */
        .delete-confirmation-modal {
            display: none;
            position: fixed;
            z-index: 10000;
            left: 0;
            top: 0;
            width: 100%;
            height: 100%;
            background-color: rgba(0, 0, 0, 0.8);
            backdrop-filter: blur(5px);
        }

        .delete-confirmation-content {
            background: #000000;
            border: 2px solid #dc3545;
            border-radius: 8px;
            margin: 10% auto;
            padding: 0;
            width: 90%;
            max-width: 500px;
            box-shadow: 0 0 20px rgba(220, 53, 69, 0.5);
            animation: deleteModalSlideIn 0.3s ease-out;
        }

        .delete-confirmation-header {
            background: #000000;
            color: #dc3545;
            padding: 15px 20px;
            border-bottom: 1px solid #dc3545;
            font-weight: bold;
            font-size: 18px;
            text-shadow: 0 0 5px #dc3545;
        }

        .delete-confirmation-body {
            padding: 20px;
            color: #ffffff;
            line-height: 1.5;
        }

        .delete-confirmation-footer {
            padding: 15px 20px;
            border-top: 1px solid #333;
            display: flex;
            justify-content: flex-end;
            gap: 10px;
        }

        .delete-btn {
            background: #dc3545;
            color: white;
            border: none;
            padding: 10px 20px;
            border-radius: 5px;
            cursor: pointer;
            font-weight: bold;
            transition: all 0.3s ease;
        }

        .delete-btn:hover {
            background: #c82333;
            box-shadow: 0 0 10px rgba(220, 53, 69, 0.5);
        }

        .cancel-btn {
            background: #6c757d;
            color: white;
            border: none;
            padding: 10px 20px;
            border-radius: 5px;
            cursor: pointer;
            font-weight: bold;
            transition: all 0.3s ease;
        }

        .cancel-btn:hover {
            background: #5a6268;
        }

        @keyframes deleteModalSlideIn {
            from { opacity: 0; transform: translateY(-50px) scale(0.9); }
            to { opacity: 1; transform: translateY(0) scale(1); }
        }

        /* Custom Success Modal */
        .delete-success-modal {
            display: none;
            position: fixed;
            z-index: 10000;
            left: 0;
            top: 0;
            width: 100%;
            height: 100%;
            background-color: rgba(0, 0, 0, 0.8);
            backdrop-filter: blur(5px);
        }

        .delete-success-content {
            background: #000000;
            border: 2px solid #28a745;
            border-radius: 8px;
            margin: 15% auto;
            padding: 0;
            width: 90%;
            max-width: 450px;
            box-shadow: 0 0 20px rgba(40, 167, 69, 0.5);
            animation: successModalSlideIn 0.3s ease-out;
        }

        .delete-success-header {
            background: #000000;
            color: #28a745;
            padding: 15px 20px;
            border-bottom: 1px solid #28a745;
            font-weight: bold;
            font-size: 18px;
            text-shadow: 0 0 5px #28a745;
        }

        .delete-success-body {
            padding: 20px;
            color: #ffffff;
            line-height: 1.5;
        }

        .delete-success-footer {
            padding: 15px 20px;
            border-top: 1px solid #333;
            display: flex;
            justify-content: center;
        }

        .ok-btn {
            background: #28a745;
            color: white;
            border: none;
            padding: 10px 30px;
            border-radius: 5px;
            cursor: pointer;
            font-weight: bold;
            transition: all 0.3s ease;
        }

        .ok-btn:hover {
            background: #218838;
            box-shadow: 0 0 10px rgba(40, 167, 69, 0.5);
        }

        @keyframes successModalSlideIn {
            from { opacity: 0; transform: translateY(-30px) scale(0.9); }
            to { opacity: 1; transform: translateY(0) scale(1); }
        }
    </style>
    <script src="storage-functions.js"></script>
</head>
<body>
    <div class="container">
        <div class="header">
            <div class="header-buttons">
                <button class="system-specs-btn" onclick="showSystemSpecs()"> Linux System Specs</button>
                <button class="upload-btn" onclick="switchMode('upload')"> Upload</button>
                <button class="help-btn" onclick="showHelp()"> Help</button>
                <button class="logout-btn" onclick="logout()"> Logout</button>
            </div>
            <h1> Video System | Data Navigator</h1>
            <!-- System IP Display -->
            <div class="system-ip-display" id="system-ip-display">
                System IP/FQDN: Loading...
            </div>
        </div>
        
        <!-- Enhanced Toggle System with Upload -->
        <div class="toggle-container">
            <button class="toggle-btn active" id="video-toggle" onclick="switchMode('video')">
                <span></span>
                <span>Video Catalog</span>
            </button>
            <button class="toggle-btn" id="file-toggle" onclick="switchMode('file')">
                <span></span>
                <span>Data Navigator</span>
            </button>
            <button class="toggle-btn" id="upload-toggle" onclick="switchMode('upload')">
                <span></span>
                <span>Upload Videos</span>
            </button>
            <button class="toggle-btn" id="general-upload-toggle" onclick="switchMode('general-upload')">
                <span></span>
                <span>General Upload</span>
            </button>
            <button class="toggle-btn" id="download-toggle" onclick="switchMode('download')">
                <span></span>
                <span>Download Videos</span>
            </button>
            <button class="toggle-btn" id="terminal-toggle" onclick="openTerminalModal()">
                <span></span>
                <span>Terminal</span>
            </button>
            <button class="toggle-btn" id="api-toggle" onclick="openApiConsole()">
                
                <span>API Calls</span>
            </button>
        </div>
        
        <div class="main-layout">
            <!-- Left Panel - Shows Either Videos OR Files OR Upload -->
            <div class="left-panel">
                <!-- Video Catalog Section -->
                <div id="video-content" class="content-section active">
                    <div class="panel-header">
                         Video Catalog
                    </div>
                    <div class="panel-content">
                        <!-- Storage Information -->
                        <div class="storage-info-fixed">
                            <div style="display: flex; justify-content: space-between; align-items: center; margin-bottom: 10px;">
                                <span><strong> Storage Status</strong></span>
                                <span id="storage-text-video">Loading...</span>
                                <div style="text-align: right; margin-top: 3px; display: flex; flex-direction: column; align-items: flex-end; gap: 5px;">
                                    <button class="quota-btn" onclick="openQuotaConfig('video')"> Disk quota reserve limit</button>
                                    <button onclick="refreshStorageData()" style="background: transparent; color: #4CAF50; border: 1px solid #4CAF50; border-radius: 4px; padding: 6px 12px; font-size: 14px; cursor: pointer;"> Refresh</button>
                                </div>
                            </div>
                            <div class="storage-bar">
                                <div class="storage-used" id="storage-used-video" style="width: 0%"></div>
                            </div>
            <div style="height: 15px;"></div>
            <div class="storage-details-vertical">
                <div class="storage-detail-item storage-available">
                    <span>Available:</span>
                    <span id="storage-available-video">--</span>
                </div>
                <div style="height: 1px; background: linear-gradient(90deg, transparent, #4ade80, transparent); margin: 8px 0;"></div>
                <div class="storage-detail-item storage-reserve">
                    <span>Reserve:</span>
                    <span id="storage-reserve-video">--</span>
                </div>
                <div style="height: 1px; background: linear-gradient(90deg, transparent, #fbbf24, transparent); margin: 8px 0;"></div>
                <div class="storage-detail-item storage-upload-limit">
                    <span>Upload limit:</span>
                <div style="height: 1px; background: linear-gradient(90deg, transparent, #fbbf24, transparent); margin: 8px 0;"></div>
                    <span id="storage-upload-video">--</span>
                </div>
            </div>
            <span id="storage-details-video" style="display: none;">Checking storage...</span>
                        </div>
                        
                        <div id="video-library-container">
                            <div class="loading">Loading videos...</div>
                        </div>
                    </div>
                </div>
                
                <!-- Data Navigator Section -->
                <div id="file-content" class="content-section">
                    <div class="panel-header">
                         Data Navigator
                    </div>
                    <div class="panel-content">
                        <!-- Storage Information (First Section) -->
                        <div class="storage-info-fixed">
                            <div style="display: flex; justify-content: space-between; align-items: center; margin-bottom: 10px;">
                                <span><strong> Storage Status</strong></span>
                                <span id="storage-text-files">Loading...</span>
                                <div style="text-align: right; margin-top: 3px; display: flex; flex-direction: column; align-items: flex-end; gap: 5px;">
                                    <button class="quota-btn" onclick="openQuotaConfig('files')"> Disk quota reserve limit</button>
                                    <button onclick="refreshStorageData()" style="background: transparent; color: #4CAF50; border: 1px solid #4CAF50; border-radius: 4px; padding: 6px 12px; font-size: 14px; cursor: pointer;"> Refresh</button>
                                </div>
                            </div>
                            <div class="storage-bar">
                                <div class="storage-used" id="storage-used-files" style="width: 0%"></div>
                            </div>
            <div style="height: 15px;"></div>
            <div class="storage-details-vertical">
                <div class="storage-detail-item storage-available">
                    <span>Available:</span>
                    <span id="storage-available-files">--</span>
                </div>
                <div style="height: 1px; background: linear-gradient(90deg, transparent, #4ade80, transparent); margin: 8px 0;"></div>
                <div class="storage-detail-item storage-reserve">
                    <span>Reserve:</span>
                    <span id="storage-reserve-files">--</span>
                </div>
                <div style="height: 1px; background: linear-gradient(90deg, transparent, #fbbf24, transparent); margin: 8px 0;"></div>
                <div class="storage-detail-item storage-upload-limit">
                    <span>Upload limit:</span>
                    <span id="storage-upload-files">--</span>
                </div>
            </div>
            <span id="storage-details-files" style="display: none;">Checking storage...</span>
                        </div>
                        
                        <!-- Enhanced Navigation Section -->
                        <div class="navigation-section" style="margin: 20px 0;">
                            <div style="font-weight: 600; color: #e2e8f0; margin-bottom: 15px; display: flex; align-items: center; flex-wrap: nowrap; gap: 10px;">
                                 Navigation
                                <button id="nav-up-btn" onclick="navigateUp()" style="background: rgba(71, 85, 105, 0.3); border: 1px solid #475569; color: #e2e8f0; padding: 5px 8px; border-radius: 5px; cursor: pointer; font-size: 12px;" title="Go to parent directory">
                                     Up
                                </button>
                            </div>
                            
                            <!-- Enhanced Breadcrumb with clickable segments -->
                            <div class="enhanced-breadcrumb" style="background: rgba(255, 255, 255, 0.05); border-radius: 8px; padding: 12px; border: 1px solid #374151;">
                                <div style="display: flex; align-items: center; flex-wrap: nowrap; flex-wrap: wrap; gap: 5px;" id="breadcrumb-segments">
                                    <span class="breadcrumb-segment" onclick="navigateTo('/')" style="background: #475569; color: white; padding: 4px 8px; border-radius: 4px; cursor: pointer; font-size: 13px; font-family: monospace;">/</span>
                                </div>
                            </div>
                            
                            <!-- Quick Access Directories -->
                            <div class="quick-access" style="margin-top: 35px;">
                                <div style="font-size: 13px; color: #9ca3af; margin-bottom: 8px;"> Quick Access:</div>
                                <div style="display: flex; flex-wrap: wrap; gap: 6px;">
                                    <button onclick="navigateTo('/home/gus')" class="quick-nav-btn"> Home</button>
                                    <button onclick="navigateTo('/home/gus/random_files')" class="quick-nav-btn"> Random Files</button>
                                    <button onclick="navigateTo('/home/gus/video-system/videos')" class="quick-nav-btn"> Videos</button>
                    <button onclick="showDebugLogs()" class="quick-nav-btn" style="background: #000; color: #00ff00; border: 1px solid #00bcd4; font-weight: bold;"> View Debug Logs</button>
                                </div>
                            </div>
                        </div>
                        
                        <!-- File Selection Controls -->
                        <div class="file-selection-controls" style="margin: 15px 0; display: none;">
                            <div class="selection-info">
                                <span id="file-selection-count">0 files selected</span>
                            </div>
                            <div class="selection-actions">
                                <button class="selection-btn" onclick="selectAllFiles()">Select All</button>
                                <button class="selection-btn" onclick="clearFileSelection()">Clear All</button>
                                <button class="delete-selected-btn" onclick="deleteSelectedFiles()"> Delete Selected</button>
                                <button class="refresh-data-btn" onclick="refreshDirectoryData()"> Refresh Data</button>
                                
                                <!-- Download buttons for file explorer -->
                                <button class="download-files-btn" onclick="downloadSelectedFiles()" id="download-selected-files-btn"> Download Selected</button>
                                <button class="download-files-btn" onclick="downloadAllFiles()" id="download-all-files-btn"> Download All</button>
                                <button class="download-files-btn" onclick="downloadFilesAsZip()" id="download-zip-files-btn"> Download as ZIP</button>
                            </div>
                        </div>
                        
                        <div id="file-list-container">
                            <div class="loading">Loading files...</div>
                        </div>
                    </div>
                </div>
                
                <!-- Upload Section -->
                <div id="upload-content" class="content-section">
                    <div class="panel-header">
                         Upload Videos
                    </div>
                    <div class="panel-content">
                        <!-- File Extension Warning -->
                        <div style="background: rgba(255, 193, 7, 0.15); border: 2px solid #ffc107; border-radius: 8px; padding: 12px; margin: 15px 0; color: #ffc107;">
                            <div style="display: flex; align-items: center; gap: 10px; margin-bottom: 5px;">
                                <span style="font-size: 20px;"></span>
                                <strong style="font-size: 16px; font-weight: bold;">Video Files Only</strong>
                            </div>
                            <div style="font-size: 14px; font-weight: 500;">
                                Only video file extensions are permitted for upload: <strong>MP4, WebM, AVI, MOV, MKV, FLV</strong>
                            </div>
                        </div>
                        
                        <!-- Storage Information -->
                        <div class="storage-info-fixed">
                            <div style="display: flex; justify-content: space-between; align-items: center; margin-bottom: 10px;">
                                <span><strong> Storage Status</strong></span>
                                <span id="storage-text">Loading...</span>
                                <div style="text-align: right; margin-top: 3px; display: flex; flex-direction: column; align-items: flex-end; gap: 5px;">
                                    <button class="quota-btn" onclick="openQuotaConfig('upload')"> Disk quota reserve limit</button>
                                    <button onclick="refreshStorageData()" style="background: transparent; color: #4CAF50; border: 1px solid #4CAF50; border-radius: 4px; padding: 6px 12px; font-size: 14px; cursor: pointer;"> Refresh</button>
                                </div>
                            </div>
                            <div class="storage-bar">
                                <div class="storage-used" id="storage-used" style="width: 0%"></div>
                            </div>
            <div style="height: 15px;"></div>
            <div class="storage-details-vertical">
                <div class="storage-detail-item storage-available">
                    <span>Available:</span>
                    <span id="storage-available-upload">--</span>
                </div>
                <div style="height: 1px; background: linear-gradient(90deg, transparent, #4ade80, transparent); margin: 8px 0;"></div>
                <div class="storage-detail-item storage-reserve">
                    <span>Reserve:</span>
                    <span id="storage-reserve-upload">--</span>
                </div>
                <div style="height: 1px; background: linear-gradient(90deg, transparent, #fbbf24, transparent); margin: 8px 0;"></div>
                <div class="storage-detail-item storage-upload-limit">
                    <span>Upload limit:</span>
                    <span id="storage-upload-upload">--</span>
                </div>
            </div>
            <span id="storage-details" style="display: none;">Checking storage...</span>
                        </div>
                        
                        <div style="margin-bottom: 15px; padding: 10px; background: rgba(255, 193, 7, 0.1); border-left: 4px solid #ffc107; border-radius: 5px;">
                            <strong> Upload Location:</strong> Files will be uploaded to <code>~/video-system/videos/</code>
                            <br><small style="color: #aaa;">Accepts only video file types.</small>
                        </div>
                        
                        <!-- Drag and Drop Zone -->
                        <form id="upload-form" enctype="multipart/form-data">
                            <div class="upload-drop-zone" id="drop-zone">
                                <div class="upload-icon"></div>
                                <div class="upload-text">Only Drag & Drop Video Files Here</div>
                                <div class="upload-subtext">or click to browse files</div>
                                <label for="file-input" class="browse-btn" id="browse-btn">
                                    Browse Files
                                </label>
                            </div>
                            <input type="file" id="file-input" name="videos" class="file-input" multiple accept="video/*,.mp4,.webm,.ogg,.avi,.mov,.mkv,.flv">
                        </form>
                        
                        <!-- File Preview -->
                        <div class="file-preview-container" id="file-preview-container" style="display: block;">
                            <h3 style="margin-bottom: 15px;"> Files Ready to Upload</h3>
                            <div id="file-preview-list"></div>
                            
                            <div class="upload-controls">
                                <button class="upload-confirm-btn" onclick="confirmUpload()">
                                     Upload Files
                                </button>
                                <button class="upload-cancel-btn" onclick="cancelUpload()">
                                     Cancel
                                </button>
                            </div>
                        </div>
                    </div>
                </div>

                <!-- General File Upload Section -->
                <div id="general-upload-content" class="content-section">
                    <div class="panel-header">
                         Upload General Files
                    </div>
                    <div class="panel-content">
                        <!-- File Permission Banner -->
                        <div style="background: rgba(34, 197, 94, 0.15); border: 2px solid #22c55e; border-radius: 8px; padding: 12px; margin: 15px 0; color: #22c55e;">
                            <div style="display: flex; align-items: center; gap: 10px; margin-bottom: 5px;">
                                <span style="font-size: 20px;"></span>
                                <strong style="font-size: 16px; font-weight: bold;">All File Types Permitted</strong>
                            </div>
                            <div style="font-size: 14px; font-weight: 500;">
                                Any file extension is allowed for upload: <strong>Documents, Images, Archives, Scripts, etc.</strong>
                            </div>
                        </div>
                        
                        <!-- Storage Information -->
                        <div class="storage-info-fixed">
                            <div style="display: flex; justify-content: space-between; align-items: center; margin-bottom: 10px;">
                                <span><strong> Storage Status</strong></span>
                                <span id="storage-text-general">Loading...</span>
                                <div style="text-align: right; margin-top: 3px; display: flex; flex-direction: column; align-items: flex-end; gap: 5px;">
                                    <button class="quota-btn" onclick="openQuotaConfig('general')"> Disk quota reserve limit</button>
                                    <button onclick="refreshStorageData()" style="background: transparent; color: #4CAF50; border: 1px solid #4CAF50; border-radius: 4px; padding: 6px 12px; font-size: 14px; cursor: pointer;"> Refresh</button>
                                </div>
                            </div>
                            <div class="storage-bar">
                                <div class="storage-used" id="storage-used-general" style="width: 0%"></div>
                            </div>
            <div style="height: 15px;"></div>
            <div class="storage-details-vertical">
                <div class="storage-detail-item storage-available">
                    <span>Available:</span>
                    <span id="storage-available-general">--</span>
                </div>
                <div style="height: 1px; background: linear-gradient(90deg, transparent, #4ade80, transparent); margin: 8px 0;"></div>
                <div class="storage-detail-item storage-reserve">
                    <span>Reserve:</span>
                    <span id="storage-reserve-general">--</span>
                </div>
                <div style="height: 1px; background: linear-gradient(90deg, transparent, #fbbf24, transparent); margin: 8px 0;"></div>
                <div class="storage-detail-item storage-upload-limit">
                    <span>Upload limit:</span>
                    <span id="storage-upload-general">--</span>
                </div>
            </div>
            <span id="storage-details-general" style="display: none;">Checking storage...</span>
                        </div>
                        
                        <div style="margin-bottom: 15px; padding: 10px; background: rgba(255, 193, 7, 0.1); border-left: 4px solid #ffc107; border-radius: 5px;">
                            <strong> Upload Location:</strong> Files will be uploaded to <code>~/random_files/</code>
                            <br><small style="color: #aaa;">Accepts any file type including documents, images, archives, etc.</small>
                        </div>
                        
                        <!-- General Drag and Drop Zone -->
                        <form id="general-upload-form" enctype="multipart/form-data">
                            <div class="upload-drop-zone" id="general-drop-zone">
                                <div class="upload-icon"></div>
                                <div class="upload-text">Drag & Drop Any Files Here</div>
                                <div class="upload-subtext">or click to browse files</div>
                                <label for="general-file-input" class="browse-btn" id="general-browse-btn">
                                    Browse Files
                                </label>
                            </div>
                            <input type="file" id="general-file-input" name="files" class="file-input" multiple>
                        </form>
                        
                        <!-- General File Preview -->
                        <div class="file-preview-container" id="general-file-preview-container" style="display: block;">
                            <h3 style="margin-bottom: 15px;"> Files Ready to Upload</h3>
                            <div id="general-file-preview-list"></div>
                            
                            <div class="upload-controls">
                                <button class="upload-confirm-btn" onclick="confirmGeneralUpload()">
                                     Upload Files
                                </button>
                                <button class="upload-cancel-btn" onclick="cancelGeneralUpload()">
                                     Cancel
                                </button>
                            </div>
                        </div>
                    </div>
                </div>
                
                <!-- Download Section -->
                <div id="download-content" class="content-section">
                    <div class="panel-header">
                         Download Videos
                    </div>
                    <div class="panel-content">
                        <!-- Storage Information -->
                        <div class="storage-info-fixed">
                            <div style="display: flex; justify-content: space-between; align-items: center; margin-bottom: 10px;">
                                <span><strong> Storage Status</strong></span>
                                <span id="storage-text-downloads">Loading...</span>
                                <div style="text-align: right; margin-top: 3px; display: flex; flex-direction: column; align-items: flex-end; gap: 5px;">
                                    <button class="quota-btn" onclick="openQuotaConfig('downloads')"> Disk quota reserve limit</button>
                                    <button onclick="refreshStorageData()" style="background: transparent; color: #4CAF50; border: 1px solid #4CAF50; border-radius: 4px; padding: 6px 12px; font-size: 14px; cursor: pointer;"> Refresh</button>
                                </div>
                            </div>
                            <div class="storage-bar">
                                <div class="storage-used" id="storage-used-downloads" style="width: 0%"></div>
                            </div>
            <div style="height: 15px;"></div>
            <div class="storage-details-vertical">
                <div class="storage-detail-item storage-available">
                    <span>Available:</span>
                    <span id="storage-available-downloads">--</span>
                </div>
                <div style="height: 1px; background: linear-gradient(90deg, transparent, #4ade80, transparent); margin: 8px 0;"></div>
                <div class="storage-detail-item storage-reserve">
                    <span>Reserve:</span>
                    <span id="storage-reserve-downloads">--</span>
                </div>
                <div style="height: 1px; background: linear-gradient(90deg, transparent, #fbbf24, transparent); margin: 8px 0;"></div>
                <div class="storage-detail-item storage-upload-limit">
                    <span>Upload limit:</span>
                    <span id="storage-upload-downloads">--</span>
                </div>
            </div>
            <span id="storage-details-downloads" style="display: none;">Checking storage...</span>
                        </div>
                        
                        
                        <!-- Video Selection Controls -->
                        <div class="download-controls">
                            <div style="display: flex; justify-content: space-between; align-items: center; margin-bottom: 20px;">
                                <div class="selection-info">
                                    <strong> Video Selection</strong>
                                    <span id="selection-count" style="margin-left: 10px; color: #17a2b8;">0 videos selected</span>
                                </div>
                                <div class="bulk-actions">
                                    <button class="action-btn select-all" onclick="selectAllVideos()"> Select All</button>
                                    <button class="action-btn clear-all" onclick="clearAllVideos()"> Clear All</button>
                                </div>
                            </div>
                        </div>
                        
                        <!-- Video List for Download -->
                        <div class="download-video-list" id="download-video-list">
                            <div class="loading">Loading available videos...</div>
                        </div>
                        
                        <!-- Download Actions -->
                        <div class="download-actions" style="margin-top: 20px;">
                            <button class="download-selected-btn" id="download-selected-btn" onclick="downloadSelected()" disabled>
                                 Download Selected Videos
                            </button>
                            <div class="download-format-options" style="margin-top: 35px;">
                                <label>
                                    <input type="radio" name="download-format" value="individual" checked> Download files individually
                                </label>
                                <label style="margin-left: 20px;">
                                    <input type="radio" name="download-format" value="zip"> Download as ZIP archive
                                </label>
                            </div>
                        </div>
                        
                        <!-- Download Progress -->
                        <div class="download-progress-container" id="download-progress-container" style="display: block;">
                            <h3 style="margin-bottom: 15px;"> Download Progress</h3>
                            <div id="download-progress-list"></div>
                        </div>
                    </div>
                </div>
            </div>
            
            <!-- Right Panel - Video Player -->
            <div class="video-section">
                <div class="panel-header" style="background: linear-gradient(135deg, #001a1a, #003333); color: #00ffff; border: 2px solid #00ffff; border-radius: 15px; text-shadow: 0 0 10px rgba(0, 255, 255, 0.8); font-family: 'Orbitron', monospace; font-weight: bold; font-size: 18px; box-shadow: 0 0 20px rgba(0, 255, 255, 0.4), inset 0 2px 8px rgba(0, 255, 255, 0.1); position: relative; overflow: hidden;">
                    <div style="position: absolute; top: 0; left: 0; right: 0; height: 2px; background: linear-gradient(90deg, transparent, #00ffff, transparent); animation: pulse 2s infinite;"></div>
                    <span style="font-size: 24px; margin-right: 10px;"></span>
                    <span style="background: linear-gradient(45deg, #00ffff, #00cccc); -webkit-background-clip: text; -webkit-text-fill-color: transparent;">VIDEO PLAYER</span>
                </div>
                
                <div class="video-player-container">
<video id="videoPlayer" class="video-player" controls preload="metadata">                        <p>Video player ready. Select a video from the library to play.</p>                    </video>
                </div>
                
                <div class="video-status-container">
                    <div class="status-icon-frame"><span id="play-status-icon" class="play-status stopped"></span></div><div class="video-info-text"><strong id="status-text">Stopped reproduction of video:</strong> <span id="current-video-name">No video selected</span></div>
                </div>
                
                <div class="video-controls">
                    <button class="btn" onclick="playPause()"> Play/Pause</button>
                    <button class="btn" onclick="toggleLoop()" id="loopToggle"> Loop: OFF</button>
                    <button class="btn" onclick="restartVideo()"> Restart</button>
                    <button class="btn" onclick="toggleMute()"> Toggle Mute</button>
                    <button class="btn" onclick="toggleFullscreen()"> Fullscreen</button>
                    <button class="btn" onclick="openVideoSearchModal()" style="border: 2px solid #ffd700; color: #28a745; font-weight: bold;"> Manage and play videos</button>
                </div>
                
                <!-- Playlist Controls -->
                <div class="video-controls" style="margin-top: 10px;">
                    <button class="btn" onclick="playAllTopToBottom()"> Play All<br>First video to last</button>
                    <button class="btn" onclick="playAllBottomToTop()"> Play All<br>Last video to first</button>
                    <button class="btn" onclick="playNextVideo()"> Next</button>
                    <button class="btn" onclick="playPreviousVideo()"> Previous</button>
                </div>
                
                <!-- Playback Speed Control -->
                <div class="speed-control-container">
                    <div class="speed-control-header">
                         Playback Speed Control
                    </div>
                    
                    <div class="speed-button-grid">
                        <!-- Slower Speeds (Left Side) -->
                        <div class="speed-section slower-section">
                            <h4 style="color: #ff6666; text-align: center; margin-bottom: 8px; font-size: 16px; font-weight: bold;">Slower Speeds</h4>
                            
                            <!-- Row 1: Ultra Slow (Red) -->
                            <div class="speed-row-container">
                                <div class="speed-row-indicator ultra-slow-indicator"> Ultra Slow</div>
                                <div class="speed-row">
                                    <button class="speed-btn ultra-slow" onclick="setVideoSpeed(0.05)">0.05x</button>
                                    <button class="speed-btn ultra-slow" onclick="setVideoSpeed(0.1)">0.1x</button>
                                    <button class="speed-btn ultra-slow" onclick="setVideoSpeed(0.15)">0.15x</button>
                                </div>
                            </div>
                            
                            <div class="speed-row-container">
                                <div class="speed-row-indicator super-slow-indicator"> Super Slow</div>
                                <div class="speed-row">
                                    <button class="speed-btn super-slow" onclick="setVideoSpeed(0.2)">0.2x</button>
                                    <button class="speed-btn super-slow" onclick="setVideoSpeed(0.25)">0.25x</button>
                                    <button class="speed-btn super-slow" onclick="setVideoSpeed(0.3)">0.3x</button>
                                </div>
                            </div>
                            
                            <!-- Row 3-4: Very Slow (Orange) -->
                            <div class="speed-row-container">
                                <div class="speed-row-indicator very-slow-indicator"> Very Slow</div>
                                <div class="speed-row">
                                    <button class="speed-btn very-slow" onclick="setVideoSpeed(0.35)">0.35x</button>
                                    <button class="speed-btn very-slow" onclick="setVideoSpeed(0.4)">0.4x</button>
                                    <button class="speed-btn very-slow" onclick="setVideoSpeed(0.45)">0.45x</button>
                                </div>
                            </div>
                            
                            <div class="speed-row-container">
                                <div class="speed-row-indicator slow-indicator"> Slow</div>
                                <div class="speed-row">
                                    <button class="speed-btn slow" onclick="setVideoSpeed(0.5)">0.5x</button>
                                    <button class="speed-btn slow" onclick="setVideoSpeed(0.6)">0.6x</button>
                                    <button class="speed-btn slow" onclick="setVideoSpeed(0.7)">0.7x</button>
                                </div>
                            </div>
                            
                            <!-- Row 5: Slow (Yellow) -->
                            <div class="speed-row-container">
                                <div class="speed-row-indicator moderate-slow-indicator"> Moderate Slow</div>
                                <div class="speed-row">
                                    <button class="speed-btn moderate-slow" onclick="setVideoSpeed(0.8)">0.8x</button>
                                    <button class="speed-btn moderate-slow" onclick="setVideoSpeed(0.9)">0.9x</button>
                                    <button class="speed-btn moderate-slow" onclick="setVideoSpeed(0.95)">0.95x</button>
                                </div>
                            </div>
                        </div>
                        
                        <!-- Normal Speed (Center) -->
                        <div class="speed-section normal-section">
                            <div class="speed-visual-indicator">
                                <button class="speed-btn normal-btn active" onclick="setVideoSpeed(1.0)">
                                    Normal Speed 1.0x
                                </button>
                            </div>
                            
                            <!-- Custom Speed Input - Inside normal section, below button -->
                            <div class="custom-speed-container">
                                <div class="custom-speed-header">
                                    <span class="custom-icon"></span>
                                    <span class="custom-text">Custom Speed Control</span>
                                </div>
                                <div class="custom-speed-input-group">
                                    <input type="number" id="customSpeedInput" placeholder="1.0" min="0.01" max="20" step="0.01" class="custom-speed-input">
                                    <span class="speed-multiplier"></span>
                                    <button onclick="setCustomSpeed()" class="custom-apply-btn">
                                        <span class="apply-icon"></span>
                                        <span class="apply-text">Apply</span>
                                    </button>
                                </div>
                                <div class="custom-speed-hint">Enter any speed from 0.01 to 20</div>
                                
                                <!-- Current Speed Display - Below custom control -->
                                <div class="current-speed-display">
                                    <div class="playing-status-container">
                                        <span class="playing-icon"></span>
                                        <span id="currentSpeed" class="current-speed-text">Speed: Normal (1.0x)</span>
                                    </div>
                                    <div id="customSpeedMessage" class="custom-speed-message"></div>
                                </div>
                            </div>
                        </div>
                        
                        <!-- Faster Speeds (Right Side) -->
                        <div class="speed-section faster-section">
                            <h4 style="color: #66ff66; text-align: center; margin-bottom: 8px; font-size: 16px; font-weight: bold;">Faster Speeds</h4>
                            
                            <!-- Row 1: Fast (Light Green) -->
                            <div class="speed-row-container">
                                <div class="speed-row-indicator moderate-fast-indicator"> Moderate Fast</div>
                                <div class="speed-row">
                                    <button class="speed-btn moderate-fast" onclick="setVideoSpeed(1.05)">1.05x</button>
                                    <button class="speed-btn moderate-fast" onclick="setVideoSpeed(1.1)">1.1x</button>
                                    <button class="speed-btn moderate-fast" onclick="setVideoSpeed(1.2)">1.2x</button>
                                </div>
                            </div>
                            
                            <div class="speed-row-container">
                                <div class="speed-row-indicator fast-indicator"> Fast</div>
                                <div class="speed-row">
                                    <button class="speed-btn fast" onclick="setVideoSpeed(1.3)">1.3x</button>
                                    <button class="speed-btn fast" onclick="setVideoSpeed(1.4)">1.4x</button>
                                    <button class="speed-btn fast" onclick="setVideoSpeed(1.5)">1.5x</button>
                                </div>
                            </div>
                            
                            <!-- Row 3-4: Very Fast (Green) -->
                            <div class="speed-row-container">
                                <div class="speed-row-indicator very-fast-indicator"> Very Fast</div>
                                <div class="speed-row">
                                    <button class="speed-btn very-fast" onclick="setVideoSpeed(1.75)">1.75x</button>
                                    <button class="speed-btn very-fast" onclick="setVideoSpeed(2.0)">2.0x</button>
                                    <button class="speed-btn very-fast" onclick="setVideoSpeed(2.25)">2.25x</button>
                                </div>
                            </div>
                            
                            <div class="speed-row-container">
                                <div class="speed-row-indicator super-fast-indicator"> Super Fast</div>
                                <div class="speed-row">
                                    <button class="speed-btn super-fast" onclick="setVideoSpeed(2.5)">2.5x</button>
                                    <button class="speed-btn super-fast" onclick="setVideoSpeed(2.75)">2.75x</button>
                                    <button class="speed-btn super-fast" onclick="setVideoSpeed(3.0)">3.0x</button>
                                </div>
                            </div>
                            
                            <!-- Row 5: Ultra Fast (Dark Green) -->
                            <div class="speed-row-container">
                                <div class="speed-row-indicator hyper-fast-indicator"> Hyper Fast</div>
                                <div class="speed-row">
                                    <button class="speed-btn hyper-fast" onclick="setVideoSpeed(4.0)">4.0x</button>
                                    <button class="speed-btn hyper-fast" onclick="setVideoSpeed(5.0)">5.0x</button>
                                    <button class="speed-btn hyper-fast" onclick="setVideoSpeed(10.0)">10.0x</button>
                                </div>
                            </div>
                        </div>
                    </div>
                    
                </div>
                
                <!-- Error and success messages now use modals instead of inline display -->
                <div id="error-message" class="error" style="display: none !important;"></div>
                <div id="success-message" class="success" style="display: none !important;"></div>
            </div>
        </div>
    </div>

    <!-- Upload Progress Modal -->
    <div id="upload-modal" class="modal">
        <div class="modal-content">
            <div class="modal-header">
                <h2> Upload Progress</h2>
                <button class="close" onclick="closeUploadModal()" style="display: block;">&times;</button>
            </div>
            <div class="modal-body" style="padding: 20px 30px 10px 30px; height: auto; max-height: 60vh; overflow-y: auto;">
                <div id="upload-progress-container">
                    <!-- Progress items will be inserted here -->
                </div>
            </div>
            <div class="modal-footer" id="upload-modal-footer" style="display: none; padding: 20px; text-align: center; border-top: 1px solid #333; background: rgba(0,0,0,0.1); position: sticky; bottom: 0;">
                <button id="upload-ok-btn" class="success-modal-btn" onclick="proceedToUploadCompletion()" style="padding: 12px 30px; font-size: 16px;">Press Ok to close this window</button>
            </div>
        </div>
    </div>

    <!-- General Upload Progress Modal -->
    <div id="general-upload-modal" class="modal">
        <div class="modal-content">
            <div class="modal-header">
                <h2> General Upload Progress</h2>
                <button class="close" onclick="closeGeneralUploadModal()" style="display: block;">&times;</button>
            </div>
            <div class="modal-body" style="padding: 20px 30px 10px 30px; height: auto; max-height: 60vh; overflow-y: auto;">
                <div id="general-upload-progress-container">
                    <!-- Progress items will be inserted here -->
                </div>
            </div>
            <div class="modal-footer" id="general-upload-modal-footer" style="display: none; padding: 20px; text-align: center; border-top: 1px solid #333; background: rgba(0,0,0,0.1); position: sticky; bottom: 0;">
                <button id="general-upload-ok-btn" class="success-modal-btn" onclick="proceedToGeneralUploadCompletion()" style="padding: 12px 30px; font-size: 16px;">Press Ok to close this window</button>
            </div>
        </div>
    </div>

    <!-- Help Modal -->
    <div id="helpModal" class="modal">
        <div class="modal-content">
            <div class="modal-header">
                <h2> Setup Instructions & Help</h2>
                <button class="close" onclick="closeHelp()">&times;</button>
            </div>
            <div class="modal-body" id="helpContent">
                <div class="loading">Loading help documentation...</div>
            </div>
        </div>
    </div>
    
    
    <div id="debugLogsModal" class="modal">
        <div class="modal-content">
            <div class="modal-header">
                <h2> Debug Logs Viewer</h2>
                <div class="modal-header-buttons">
                <button class="download-debug-btn" onclick="scrollToTop()"> Top</button>
                <button class="download-debug-btn" onclick="scrollToBottom()"> Bottom</button>
                <button class="download-debug-btn" onclick="downloadDebugLog()"> Download</button>
                    <button class="close" onclick="closeDebugLogs()">&times;</button>
                </div>
            </div>
            <div class="modal-body" id="debugLogsContent">
                <div class="loading">Loading debug logs...</div>
            </div>
        </div>
    </div>

    <!-- Refresh Data Modal -->
    <div id="refreshDataModal" class="refresh-data-modal">
        <div class="refresh-data-modal-content">
            <div class="refresh-data-modal-header">
                <h3> Refresh Data</h3>
                <button class="refresh-data-modal-close" onclick="closeRefreshDataModal()">&times;</button>
            </div>
            <div class="refresh-data-modal-body" id="refreshDataModalBody">
                <div class="loading">Refreshing data...</div>
            </div>
        </div>
    </div>

    <!-- Video Search Modal -->
    <div id="videoSearchModal" class="modal" style="display: none;">
        <div class="modal-content" style="max-width: 90vw; width: 1400px; height: 90vh;">
            <div class="modal-header" style="background: linear-gradient(135deg, #1a1a1a, #2a2a2a); border-bottom: 2px solid #ffd700;">
                <h2 style="color: #ffd700;"> Search and Play Videos</h2>
                <button class="close" onclick="closeVideoSearchModal()" style="background: rgba(255,255,255,0.9) !important; color: #000000 !important; font-weight: bold; font-size: 18px;">&times;</button>
            </div>
            <div class="modal-body" style="padding: 30px; background: #0a0a0a; color: white; height: calc(100% - 100px); overflow-y: auto;">
                
                <!-- Search Section -->
                <div style="margin-bottom: 30px; padding: 20px; background: #000000; border: 2px solid #ffd700; border-radius: 10px;">
                    <div style="display: flex; gap: 15px; align-items: center; margin-bottom: 15px;">
                        <input type="text" id="videoSearchInput" placeholder="Enter video name or partial name..." 
                               onkeypress="if(event.key==='Enter') searchVideos()"
                               style="flex: 1; padding: 12px; background: rgba(0,0,0,0.8); border: 2px solid #28a745; border-radius: 8px; color: white; font-size: 16px;">
                        <button onclick="searchVideos()" style="padding: 12px 25px; background: #000000; color: #28a745; border: 2px solid #28a745; border-radius: 8px; font-weight: bold; cursor: pointer;"> Find</button>
                        <button onclick="clearVideoSearch()" style="padding: 12px 25px; background: #000000; color: #dc3545; border: 2px solid #dc3545; border-radius: 8px; font-weight: bold; cursor: pointer;">Clear</button>
                        <button onclick="refreshVideoMetadata()" style="padding: 12px 25px; background: #000000; color: #28a745; border: 2px solid #28a745; border-radius: 8px; font-weight: bold; cursor: pointer;"> Refresh Metadata</button>
                        <button onclick="showPlayAllModal()" style="padding: 12px 25px; background: #000000; color: #28a745; border: 2px solid #28a745; border-radius: 8px; font-weight: bold; cursor: pointer;"> Play All</button>
                        <button onclick="showPlaySelectedModal()" style="padding: 12px 25px; background: #000000; color: #ffd700; border: 2px solid #ffd700; border-radius: 8px; font-weight: bold; cursor: pointer;"> Play Selected</button>
                    </div>
                    
                    <!-- Playlist Management Buttons -->
                    <div style="display: flex; gap: 15px; align-items: center; margin: 15px 0; padding: 15px; background: #000000; border-radius: 8px; border: 2px solid #28a745;">
                        <div style="color: #28a745; font-weight: bold; margin-right: 10px;"> Playlist Management:</div>
                        <button onclick="createNewPlaylist()" style="padding: 10px 20px; background: #000000; color: #28a745; border: 2px solid #28a745; border-radius: 6px; font-weight: bold; cursor: pointer; transition: all 0.3s ease;"> New Playlist</button>
                        <button onclick="editPlaylist()" style="padding: 10px 20px; background: #000000; color: #ffd700; border: 2px solid #ffd700; border-radius: 6px; font-weight: bold; cursor: pointer; transition: all 0.3s ease;"> Edit Playlist</button>
                        <button onclick="deletePlaylist()" style="padding: 10px 20px; background: #000000; color: #dc3545; border: 2px solid #dc3545; border-radius: 6px; font-weight: bold; cursor: pointer; transition: all 0.3s ease;"> Delete Playlist</button>
                        <button onclick="showAllPlaylists()" style="padding: 10px 20px; background: #000000; color: #17a2b8; border: 2px solid #17a2b8; border-radius: 6px; font-weight: bold; cursor: pointer; transition: all 0.3s ease;"> Show All Playlists</button>
                    </div>
                    
                    <!-- Add Videos to Playlist Buttons -->
                    <div style="display: flex; gap: 15px; align-items: center; margin: 15px 0; padding: 15px; background: #000000; border-radius: 8px; border: 2px solid #00bfff;">
                        <div style="color: #00bfff; font-weight: bold; margin-right: 10px;"> Add Videos:</div>
                        <button onclick="addAllVideosToPlaylist()" style="padding: 10px 20px; background: #000000; color: #00bfff; border: 2px solid #00bfff; border-radius: 6px; font-weight: bold; cursor: pointer; transition: all 0.3s ease;"> Add All Videos to Playlist</button>
                        <button onclick="addSelectedVideosToPlaylist()" style="padding: 10px 20px; background: #000000; color: #00bfff; border: 2px solid #00bfff; border-radius: 6px; font-weight: bold; cursor: pointer; transition: all 0.3s ease;"> Add Selected Videos to Playlist</button>
                    </div>
                    
                    <div id="searchStatus" style="color: #28a745; font-size: 14px;"></div>
                </div>

                <!-- Results Section -->
                <div id="videoSearchResults" style="display: none;">
                    <div style="margin-bottom: 20px; padding: 15px; background: #000000; border: 2px solid #28a745; border-radius: 8px;">
                        <h3 style="color: #28a745; margin-bottom: 15px;">Search Results</h3>
                        <div style="background: #1a1a1a; color: #ffd700; padding: 10px; border: 2px solid #ffd700; border-radius: 5px; margin-bottom: 15px; display: flex; align-items: center; gap: 8px; font-weight: bold; animation: blinkMessage 3s infinite;">
                            <span style="font-size: 18px;"></span>
                            <span>Scroll down to see the Videos Catalog Metadata</span>
                        </div>
                        <div style="display: flex; gap: 10px; align-items: center; margin-bottom: 15px;">
                            <button onclick="selectAllSearchVideos()" style="padding: 8px 15px; background: #000000; color: #17a2b8; border: 2px solid #17a2b8; border-radius: 5px; cursor: pointer; font-weight: bold;">Select All</button>
                            <button onclick="deselectAllSearchVideos()" style="padding: 8px 15px; background: #000000; color: #dc3545; border: 2px solid #dc3545; border-radius: 5px; cursor: pointer; font-weight: bold;">Deselect All</button>
                            <button onclick="goToTop()" style="padding: 8px 15px; background: #000000; color: #ff7f00; border: 2px solid #ff7f00; border-radius: 5px; cursor: pointer; font-weight: bold; transition: all 0.3s ease;" onmouseover="this.style.transform='scale(1.05)'; this.style.boxShadow='0 0 15px #ff7f00'; this.style.textShadow='0 0 8px #ff7f00';" onmouseout="this.style.transform='scale(1)'; this.style.boxShadow='none'; this.style.textShadow='none';">Go to Top</button>
                            <button onclick="goToBottom()" style="padding: 8px 15px; background: #000000; color: #ff7f00; border: 2px solid #ff7f00; border-radius: 5px; cursor: pointer; font-weight: bold; transition: all 0.3s ease;" onmouseover="this.style.transform='scale(1.05)'; this.style.boxShadow='0 0 15px #ff7f00'; this.style.textShadow='0 0 8px #ff7f00';" onmouseout="this.style.transform='scale(1)'; this.style.boxShadow='none'; this.style.textShadow='none';">Go to Bottom</button>
                            <button onclick="goToMiddle()" style="padding: 8px 15px; background: #000000; color: #ff7f00; border: 2px solid #ff7f00; border-radius: 5px; cursor: pointer; font-weight: bold; transition: all 0.3s ease;" onmouseover="this.style.transform='scale(1.05)'; this.style.boxShadow='0 0 15px #ff7f00'; this.style.textShadow='0 0 8px #ff7f00';" onmouseout="this.style.transform='scale(1)'; this.style.boxShadow='none'; this.style.textShadow='none';">Go to Middle</button>
                            <span id="selectedCount" style="color: #ffd700; font-weight: bold;">0 selected</span>
                        </div>
                    </div>
                    
                    <!-- Delete Videos Section -->
                    <div id="deleteControls" style="margin-bottom: 20px; padding: 20px; background: #000000; border: 2px solid #dc3545; border-radius: 8px; display: none;">
                        <h4 style="color: #dc3545; margin-bottom: 15px;"> Delete Videos</h4>
                        <div style="display: flex; gap: 15px; align-items: center;">
                            <button onclick="showDeleteModal('selected')" style="padding: 12px 20px; background: #000000; color: #dc3545; border: 2px solid #dc3545; border-radius: 8px; font-weight: bold; cursor: pointer;"> Delete Selected</button>
                            <button onclick="showDeleteModal('all')" style="padding: 12px 20px; background: #000000; color: #dc3545; border: 2px solid #dc3545; border-radius: 8px; font-weight: bold; cursor: pointer;"> Delete All</button>
                            <span style="color: #ff6666; margin-left: 20px;">Permanently remove videos from the system</span>
                        </div>
                    </div>
                    
                    <!-- Play Controls - BELOW Search Results header, BEFORE video list -->
                    <div id="playControls" style="margin-bottom: 20px; padding: 20px; background: #000000; border: 2px solid #ffd700; border-radius: 8px; display: none;">
                        <h4 style="color: #ffd700; margin-bottom: 15px;">PlayList Options</h4>
                        <div style="display: flex; gap: 15px; align-items: center;">
                            <button onclick="playSelectedVideos('top-to-bottom')" style="padding: 12px 20px; background: #000000; color: #28a745; border: 2px solid #28a745; border-radius: 8px; font-weight: bold; cursor: pointer;"> Play from Top to Bottom</button>
                            <button onclick="playSelectedVideos('bottom-to-top')" style="padding: 12px 20px; background: #000000; color: #dc3545; border: 2px solid #dc3545; border-radius: 8px; font-weight: bold; cursor: pointer;"> Play from Bottom to Top</button>
                            <span style="color: #ccc; margin-left: 20px;">Selected videos will play in chosen order</span>
                        </div>
                    </div>
                    
                    <!-- Download Controls -->
                    <div id="downloadControls" style="margin-bottom: 20px; padding: 20px; background: #000000; border: 2px solid #ff8800; border-radius: 8px; display: none;">
                        <h4 style="color: #ff8800; margin-bottom: 15px;"> Download Videos</h4>
                        <div style="display: flex; gap: 15px; align-items: center;">
                            <button onclick="downloadSelectedVideos()" style="padding: 12px 20px; background: #000000; color: #ff8800; border: 2px solid #28a745; border-radius: 8px; font-weight: bold; cursor: pointer;"> Download Selected</button>
                            <button onclick="downloadAllVideos()" style="padding: 12px 20px; background: #000000; color: #ff8800; border: 2px solid #28a745; border-radius: 8px; font-weight: bold; cursor: pointer;"> Download All</button>
                            <button onclick="downloadSelectedVideosAsZip()" style="padding: 12px 20px; background: #000000; color: #17a2b8; border: 2px solid #17a2b8; border-radius: 8px; font-weight: bold; cursor: pointer;"> Download ZIP File</button>
                            <span style="color: #ff8800; margin-left: 20px;">Videos will be downloaded to your device</span>
                        </div>
                    </div>
                    
                    <!-- Video List -->
                    <div id="videoList" style="max-height: 500px; overflow-y: auto; border: 1px solid #333; border-radius: 8px; background: #000000;"></div>
                </div>

            </div>
        </div>
    </div>

    <!-- Order Selection Modals -->
    <div id="playAllOrderModal" class="modal" style="display: none; z-index: 10001;">
        <div class="modal-content" style="width: auto; max-width: 500px; min-width: 350px; height: auto; background: linear-gradient(135deg, #000000, #0a0a0a); border: 2px solid #00ffff; border-radius: 20px; box-shadow: 0 0 30px rgba(0, 255, 255, 0.5), inset 0 0 20px rgba(0, 255, 255, 0.1);">
            <div class="modal-header" style="background: linear-gradient(135deg, #001a1a, #003333); border-bottom: 2px solid #00ffff; border-radius: 18px 18px 0 0; position: relative; overflow: hidden;">
                <div style="position: absolute; top: 0; left: 0; right: 0; height: 2px; background: linear-gradient(90deg, transparent, #00ffff, transparent); animation: pulse 2s infinite;"></div>
                <h2 style="color: #00ffff; text-shadow: 0 0 10px rgba(0, 255, 255, 0.8); font-family: 'Orbitron', monospace; font-weight: 700; margin: 0; display: flex; align-items: center; gap: 15px;">
                    <span style="font-size: 24px;"></span>
                    <span style="background: linear-gradient(45deg, #00ffff, #00cccc); -webkit-background-clip: text; -webkit-text-fill-color: transparent;">PLAY ALL VIDEOS</span>
                </h2>
                <button class="close" onclick="closePlayAllOrderModal()" style="background: linear-gradient(135deg, #00ffff, #00cccc) !important; color: #000000 !important; border: 2px solid #ffffff; border-radius: 50%; width: 40px; height: 40px; font-size: 18px; font-weight: bold; box-shadow: 0 0 15px rgba(0, 255, 255, 0.6); transition: all 0.3s ease;">&times;</button>
            </div>
            <div class="modal-body" style="padding: 40px; background: linear-gradient(135deg, #000000, #001122); color: white; text-align: center; border-radius: 0 0 18px 18px;">
                <div style="background: linear-gradient(135deg, rgba(0, 255, 255, 0.1), rgba(0, 255, 255, 0.05)); border: 1px solid rgba(0, 255, 255, 0.3); border-radius: 15px; padding: 25px; margin-bottom: 30px; position: relative; overflow: hidden;">
                    <div style="position: absolute; top: 0; left: -100%; width: 100%; height: 100%; background: linear-gradient(90deg, transparent, rgba(0, 255, 255, 0.1), transparent); animation: shimmer 3s infinite;"></div>
                    <p style="margin: 0; font-size: 18px; color: #00ffff; font-weight: 500; text-shadow: 0 0 5px rgba(0, 255, 255, 0.5);">Choose the execution order for all search results:</p>
                </div>
                <div style="display: flex; gap: 25px; justify-content: center; flex-wrap: wrap;">
                    <button onclick="playAllVideos('top-to-bottom')" style="
                        padding: 20px 35px; 
                        background: linear-gradient(135deg, #00ffff, #00cccc, #008888); 
                        color: #000000; 
                        border: 2px solid #ffffff; 
                        border-radius: 15px; 
                        font-weight: bold; 
                        cursor: pointer; 
                        font-size: 16px; 
                        font-family: 'Orbitron', monospace;
                        box-shadow: 0 8px 25px rgba(0, 255, 255, 0.4), inset 0 2px 8px rgba(255, 255, 255, 0.2);
                        transition: all 0.3s ease;
                        position: relative;
                        overflow: hidden;
                        text-shadow: 0 1px 2px rgba(0, 0, 0, 0.3);
                    " onmouseover="this.style.transform='translateY(-3px) scale(1.05)'; this.style.boxShadow='0 12px 35px rgba(0, 255, 255, 0.6), inset 0 2px 12px rgba(255, 255, 255, 0.3)';" onmouseout="this.style.transform='translateY(0) scale(1)'; this.style.boxShadow='0 8px 25px rgba(0, 255, 255, 0.4), inset 0 2px 8px rgba(255, 255, 255, 0.2)';">
                        <span style="font-size: 18px; margin-right: 8px;"></span>
                        FIRST  LAST
                    </button>
                    <button onclick="playAllVideos('bottom-to-top')" style="
                        padding: 20px 35px; 
                        background: linear-gradient(135deg, #ff0080, #cc0066, #990044); 
                        color: #ffffff; 
                        border: 2px solid #ffffff; 
                        border-radius: 15px; 
                        font-weight: bold; 
                        cursor: pointer; 
                        font-size: 16px; 
                        font-family: 'Orbitron', monospace;
                        box-shadow: 0 8px 25px rgba(255, 0, 128, 0.4), inset 0 2px 8px rgba(255, 255, 255, 0.2);
                        transition: all 0.3s ease;
                        position: relative;
                        overflow: hidden;
                        text-shadow: 0 1px 2px rgba(0, 0, 0, 0.5);
                    " onmouseover="this.style.transform='translateY(-3px) scale(1.05)'; this.style.boxShadow='0 12px 35px rgba(255, 0, 128, 0.6), inset 0 2px 12px rgba(255, 255, 255, 0.3)';" onmouseout="this.style.transform='translateY(0) scale(1)'; this.style.boxShadow='0 8px 25px rgba(255, 0, 128, 0.4), inset 0 2px 8px rgba(255, 255, 255, 0.2)';">
                        <span style="font-size: 18px; margin-right: 8px;"></span>
                        LAST  FIRST
                    </button>
                </div>
            </div>
        </div>
    </div>

    <div id="playSelectedOrderModal" class="modal" style="display: none; z-index: 10001;">
        <div class="modal-content" style="max-width: 500px; height: auto;">
            <div class="modal-header" style="background: linear-gradient(135deg, #ffd700, #ffed4e); border-bottom: 2px solid #ffd700;">
                <h2 style="color: #000000;"> Play Selected Videos</h2>
                <button class="close" onclick="closePlaySelectedOrderModal()" style="background: rgba(255,215,0,0.2); color: #000000;">&times;</button>
            </div>
            <div class="modal-body" style="padding: 30px; background: #0a0a0a; color: white; text-align: center;">
                <p style="margin-bottom: 30px; font-size: 16px; color: #ccc;">Choose the order to play selected videos:</p>
                <div style="display: flex; gap: 20px; justify-content: center;">
                    <button onclick="playSelectedVideosOrdered('top-to-bottom')" style="padding: 15px 30px; background: #000000; color: #28a745; border: 2px solid #28a745; border-radius: 8px; font-weight: bold; cursor: pointer; font-size: 16px;"> Play from Top to Bottom</button>
                    <button onclick="playSelectedVideosOrdered('bottom-to-top')" style="padding: 15px 30px; background: #000000; color: #dc3545; border: 2px solid #dc3545; border-radius: 8px; font-weight: bold; cursor: pointer; font-size: 16px;"> Play from Bottom to Top</button>
                </div>
            </div>
        </div>
    </div>

    <script>
        console.log(" JAVASCRIPT LOADED AT:", new Date().toISOString());
        console.log(" CSS CHANGES ACTIVE - CYAN BUTTON FIX v4");
        let currentPath = '/home/gus';
        let currentMode = 'video';
        let allVideos = [];
        let currentPlayingVideo = null;
        let pendingFiles = [];
        let uploadInProgress = false;
        let storageInfo = null;
        let selectedVideos = new Set(); // Track selected videos for download
        let downloadInProgress = false;
        // Directory cache is now defined in the refresh section above
        let baselineTimestamp = null; // Baseline timestamp for file comparison
        // No hardcoded limits - all validation handled dynamically by reserve space functions
        
        document.addEventListener('DOMContentLoaded', function() {
            console.log(' DOMContentLoaded fired - starting authentication check');
            checkAuthentication();
            setupDragAndDrop();
            setupGeneralDragAndDrop();
            setupVideoEventListeners();
        });

        // Also try on window load as backup
        window.addEventListener('load', function() {
            console.log(' Window load fired - backup check');
            const modal = document.getElementById('welcomeModal');
            if (modal && modal.style.display !== 'block') {
                console.log(' Modal not shown yet, triggering video modal');
                const token = sessionStorage.getItem('authToken');
                const authenticated = sessionStorage.getItem('authenticated');
                if (token && authenticated === 'true') {
                    console.log(' User is authenticated, showing video modal');
                    modal.style.display = 'block';
                    // Check if this is a fresh sign-in
                    const isFromLogin = document.referrer.includes('login.html') || sessionStorage.getItem('justSignedIn') === 'true';
                    startWelcomeVideo(!isFromLogin);
                }
            }
        });
        
        function checkAuthentication() {
            console.log('Dashboard: checkAuthentication called');
            const token = sessionStorage.getItem('authToken');
            const authenticated = sessionStorage.getItem('authenticated');
            
            console.log('Dashboard: token =', token ? 'present' : 'missing');
            console.log('Dashboard: authenticated =', authenticated);
            
            if (!token || authenticated !== 'true') {
                console.log('Dashboard: Authentication failed, redirecting to login');
                window.location.href = '/login.html';
                return;
            }
            
            console.log('Dashboard: Authentication successful');
            
            // Check if this is a fresh sign-in or page reload
            const isFromLogin = document.referrer.includes('login.html') || sessionStorage.getItem('justSignedIn') === 'true';
            console.log('Is fresh sign-in?', isFromLogin, 'Referrer:', document.referrer);
            
            // Clear the sign-in flag after checking
            sessionStorage.removeItem('justSignedIn');
            
            // Show video modal IMMEDIATELY after successful authentication
            console.log('Showing welcome modal immediately');
            const modal = document.getElementById('welcomeModal');
            if (modal) {
                console.log('Modal element found, showing and starting video');
                modal.style.display = 'block';
                // Add a small delay to ensure modal is visible before starting video
                setTimeout(function() {
                    console.log('About to call startWelcomeVideo after modal display');
                    // Pass true for page reload, false for fresh sign-in
                    startWelcomeVideo(!isFromLogin);
                }, 100);
            } else {
                console.error('Modal element not found!');
            }
            
            // Set up authentication headers for all API calls
            window.authHeaders = {
                'Authorization': `Bearer ${token}`,
                'Content-Type': 'application/json'
            };
            
            // Fetch and display system IP
            fetchSystemIP();
            
            // Set baseline timestamp for file comparison
            baselineTimestamp = new Date();
            console.log('Baseline timestamp set:', baselineTimestamp.toISOString());
            
            // Load initial random files cache to establish baseline
            loadInitialRandomFilesCache();
            
            // Load storage info immediately on page load
            loadStorageInfo();
            
            // Load initial content
            switchMode('video');
        }
        
        // Load initial random files cache when page loads
        async function loadInitialRandomFilesCache() {
            try {
                console.log('Loading initial random files cache...');
                const response = await fetch('/api/list?path=/home/gus/random_files', {
                    headers: window.authHeaders
                });
                
                if (response.ok) {
                    const data = await response.json();
                    directoryCache['/home/gus/random_files'] = data.files || [];
                    console.log('Initial random files cache loaded:', directoryCache['/home/gus/random_files'].length, 'files');
                } else {
                    console.log('Random files directory may not exist yet, cache will remain empty');
                    directoryCache['/home/gus/random_files'] = [];
                }
            } catch (error) {
                console.log('Error loading initial random files cache:', error.message);
                directoryCache['/home/gus/random_files'] = [];
            }
        }
        
        // Update baseline timestamp when files are uploaded
        function updateBaselineTimestamp() {
            baselineTimestamp = new Date();
            console.log('Baseline timestamp updated after upload:', baselineTimestamp.toISOString());
        }
        
        function logout() {
            sessionStorage.removeItem('authToken');
            sessionStorage.removeItem('authenticated');
            window.location.href = '/login.html';
        }
        
        async function showHelp() {
            const modal = document.getElementById('helpModal');
            const helpContent = document.getElementById('helpContent');
            
            modal.style.display = 'block';
            helpContent.innerHTML = '<div class="loading">Loading help documentation...</div>';
            
            try {
                const response = await fetch('/api/instructions', {
                    headers: window.authHeaders
                });
                
                if (response.ok) {
                    const instructions = await response.text();
                    helpContent.innerHTML = `<pre>${instructions}</pre>`;
                } else {
                    
                    helpContent.innerHTML = '<div class="error">Failed to load instructions</div>';
                }
            } catch (error) {
                helpContent.innerHTML = '<div class="error">Error loading instructions: ' + error.message + '</div>';
            }
        }
        
        function closeHelp() {
            document.getElementById('helpModal').style.display = 'none';
        }
        async function showDebugLogs() {
            const modal = document.getElementById('debugLogsModal');
            const debugLogsContent = document.getElementById('debugLogsContent');
            
            modal.style.display = 'block';
            debugLogsContent.innerHTML = '<div class="loading">Loading debug logs...</div>';
            
            try {
                const response = await fetch('/api/debug-log', {
                    headers: window.authHeaders
                });
                
                if (response.ok) {
                    const instructions = await response.text();
                    debugLogsContent.innerHTML = `<pre>${instructions}</pre>`;
                } else {
                    
                    debugLogsContent.innerHTML = '<div class="error">Failed to load debug logs</div>';
                }
            } catch (error) {
                debugLogsContent.innerHTML = '<div class="error">Error loading debug logs: ' + error.message + '</div>';
            }
        }
function scrollToTop() {            const debugContent = document.getElementById("debugLogsContent");            debugContent.scrollTop = 0;        }        function scrollToBottom() {            const debugContent = document.getElementById("debugLogsContent");            debugContent.scrollTop = debugContent.scrollHeight;        }
        function closeDebugLogs() {
            document.getElementById("debugLogsModal").style.display = "none";
        }
async function downloadDebugLog() {            try {                const response = await fetch("/api/debug-log", {                    headers: window.authHeaders                });                                if (response.ok) {                    const debugLogContent = await response.text();                    const blob = new Blob([debugLogContent], { type: "text/plain" });                    const url = window.URL.createObjectURL(blob);                                        const a = document.createElement("a");                    a.href = url;                    a.download = "debug_logs_" + new Date().toISOString().slice(0, 19).replace(/:/g, "-") + ".txt";                    document.body.appendChild(a);                    a.click();                    document.body.removeChild(a);                    window.URL.revokeObjectURL(url);                } else {                    alert("Failed to download debug logs: " + response.status);                }            } catch (error) {                alert("Error downloading debug logs: " + error.message);            }        }
        
        function switchMode(mode) {
            currentMode = mode;
            logAction("User switched to " + mode + " section", "Section changed to: " + mode, "/dashboard", "UI");
            
            // Update toggle button states
            document.getElementById('video-toggle').classList.remove('active');
            document.getElementById('file-toggle').classList.remove('active');
            document.getElementById('upload-toggle').classList.remove('active');
            document.getElementById('download-toggle').classList.remove('active');
            document.getElementById('general-upload-toggle').classList.remove('active');
            document.getElementById(mode + '-toggle').classList.add('active');
            
            // Show/hide content sections
            document.getElementById('video-content').classList.remove('active');
            document.getElementById('file-content').classList.remove('active');
            document.getElementById('upload-content').classList.remove('active');
            document.getElementById('download-content').classList.remove('active');
            document.getElementById('general-upload-content').classList.remove('active');
            document.getElementById(mode + '-content').classList.add('active');
            
            // Load storage info for all sections (except terminal and API calls)
            const noRefreshModes = ['terminal', 'api-calls'];
            if (!noRefreshModes.includes(mode)) {
                loadStorageInfo();
            }
            
            // Load appropriate content
            if (mode === 'video') {
                loadVideoLibrary();
            } else if (mode === 'file') {
                if (!document.getElementById('file-list-container').innerHTML.includes('file-item')) {
                    navigateTo('/home/gus');
                }
            } else if (mode === 'upload') {
                // Storage info already loaded above
            } else if (mode === 'download') {
                loadDownloadVideoList();
            } else if (mode === 'general-upload') {
                // Initialize general upload section - storage info already loaded above
                console.log('General upload section activated');
            }
        }
        
        async function loadStorageInfo() {
            try {
                const response = await fetch('/api/storage', {
                    headers: window.authHeaders
                });
                
                if (response.ok) {
                    storageInfo = await response.json();
                    updateStorageDisplay();
                } else {
                    
                    throw new Error('Failed to load storage info');
                }
            } catch (error) {
                // Update original storage display with error
                const originalStorageText = document.getElementById('storage-text');
                const originalStorageDetails = document.getElementById('storage-details');
                
                if (originalStorageText) originalStorageText.textContent = 'Error loading storage info';
                if (originalStorageDetails) originalStorageDetails.textContent = error.message;
                
                // Update all new storage displays with error
                const sections = ['video', 'files', 'general', 'downloads'];
                sections.forEach(section => {
                    const textEl = document.getElementById(`storage-text-${section}`);
                    const detailsEl = document.getElementById(`storage-details-${section}`);
                    
                    if (textEl) textEl.textContent = 'Error loading storage info';
                    if (detailsEl) detailsEl.textContent = error.message;
                });
            }
        }
        
        async function getReserveConfig() {
            try {
                const response = await fetch('/api/file?path=/home/gus/video-system/docs/reserved_value.txt&t=' + new Date().getTime(), {
                    headers: {
                        ...window.authHeaders,
                        'Cache-Control': 'no-cache',
                        'Pragma': 'no-cache'
                    }
                });
                
                if (response.ok) {
                    const content = await response.text();
                    const config = {};
                    
                    // Parse the configuration file
                    const lines = content.split('\n');
                    for (const line of lines) {
                        if (line.includes('total_disk_space = ')) {
                            config.total_disk_space = parseFloat(line.split('= ')[1]);
                        } else if (line.includes('used_disk_space = ')) {
                            config.used_disk_space = parseFloat(line.split('= ')[1]);
                        } else if (line.includes('reserved_value = ')) {
                            config.reserved_value = parseFloat(line.split('= ')[1]);
                        } else if (line.includes('upload_limit_value = ')) {
                            config.upload_limit_value = parseFloat(line.split('= ')[1]);
                        } else if (line.includes('reserved_value_flag = ')) {
                            config.reserved_value_flag = line.split('= ')[1].trim();
                        }
                    }
                    
                    return config;
                } else {
                    throw new Error('Failed to read config file');
                }
            } catch (error) {
                console.error('Error reading reserve config:', error);
                return null;
            }
        }
        
        // Reserve space validation function
        async function checkReserveSpaceAvailability(uploadFiles) {
            try {
                // Get current reserve configuration
                const reserveConfig = await getReserveConfig();
                if (!reserveConfig) {
                    console.warn('Could not read reserve configuration');
                    return { isValid: true }; // Allow upload if config can't be read
                }
                
                // Parse reserve values
                const reservedValueGB = parseFloat(reserveConfig.reserved_value) || 0;
                const reservedFlag = reserveConfig.reserved_value_flag === 'True';
                
                // If reserve is not set (flag is True), allow upload
                if (reservedFlag) {
                    return { isValid: true };
                }
                
                // Calculate total upload size
                const totalUploadSize = Array.from(uploadFiles).reduce((sum, file) => sum + file.size, 0);
                const totalUploadSizeGB = totalUploadSize / (1024 * 1024 * 1024);
                
                // Get current storage info
                if (!storageInfo) {
                    await loadStorageInfo();
                    if (!storageInfo) {
                        console.warn('Could not load storage info');
                        return { isValid: true }; // Allow upload if storage info can't be loaded
                    }
                }
                
                // Calculate remaining space after upload
                const currentAvailableGB = storageInfo.available / (1024 * 1024 * 1024);
                const remainingAfterUploadGB = currentAvailableGB - totalUploadSizeGB;
                
                // Check if remaining space would be less than reserved value
                if (remainingAfterUploadGB < reservedValueGB) {
                    return {
                        isValid: false,
                        reservedGB: reservedValueGB,
                        uploadSizeGB: totalUploadSizeGB,
                        remainingGB: remainingAfterUploadGB
                    };
                }
                
                return { isValid: true };
                
            } catch (error) {
                console.error('Error checking reserve space:', error);
                return { isValid: true }; // Allow upload if there's an error in checking
            }
        }
        
        // Show reserve violation modal for bulk uploads
        async function showReserveViolationModal(totalSizeGB, reserveGB, remainingGB, pendingCount, newCount, rejectedFiles) {
            // Get the actual reserve value from the config file using the same technique as storage capacity panel
            let actualReserveGB = "0.00";
            try {
                console.log('Reading actual reserve value from config file for modal...');
                const configResponse = await fetch("/api/file?path=/home/gus/video-system/docs/reserved_value.txt", {
                    headers: window.authHeaders
                });
                
                if (configResponse.ok) {
                    const configContent = await configResponse.text();
                    console.log("Modal - Config content:", configContent);
                    
                    // Use same parsing as updateStorageDisplay
                    let reservedValue = 0;
                    const lines = configContent.split('\n');
                    lines.forEach(line => {
                        if (line.includes('reserved_value = ') && !line.startsWith('#') && !line.includes('flag') && !line.includes('upload_limit')) {
                            const value = line.split('= ')[1];
                            if (value) {
                                reservedValue = parseFloat(value.trim());
                            }
                        }
                    });
                    
                    actualReserveGB = reservedValue.toFixed(2);
                    console.log('Modal - Got actual reserve value from config:', actualReserveGB, 'GB');
                } else {
                    console.log('Modal - Failed to read config file');
                }
            } catch (error) {
                console.error('Modal - Error fetching actual reserve value:', error);
            }
            const modal = document.createElement('div');
            modal.id = 'reserveViolationModal';
            modal.className = 'modal';
            modal.style.display = 'block';
            modal.style.zIndex = '10000';
            
            const modalContent = `
                <div class="error-modal-content" style="max-width: 1200px; width: 90%; margin: 10vh auto; max-height: 70vh; overflow-y: auto; background: #000; border: 2px solid #dc3545; border-radius: 12px; box-shadow: 0 10px 30px rgba(0,0,0,0.8);">
                    <div class="error-modal-header" style="background: #000000; color: #dc3545; padding: 18px 25px; border-radius: 10px 10px 0 0; text-align: center;">
                        <h3 style="color: #dc3545; margin: 0; font-size: 20px; font-weight: bold; display: flex; align-items: center; justify-content: center; gap: 12px;">
                            <span style="font-size: 22px;"></span>
                            Reserve Space Violation - Upload Blocked
                        </h3>
                    </div>
                    <div class="error-modal-body" style="padding: 22px;">
                        <p style="color: #e0e0e0; font-size: 18px; margin: 0 0 18px 0; text-align: center;">
                            Cannot add ${newCount} new file(s). Total upload would violate the reserved space requirement.
                        </p>
                        
                        <!-- Horizontal Layout Container -->
                        <div style="display: flex; gap: 15px; margin: 12px 0;">
                            <!-- Reserve Value Information -->
                            <div style="flex: 1; background: rgba(40, 167, 69, 0.1); border: 2px solid #28a745; border-radius: 8px; padding: 15px; text-align: center;">
                                <p style="color: #28a745; font-size: 16px; margin: 0; font-weight: bold;">
                                     Current Reserve Value: ${actualReserveGB} GB (${(parseFloat(actualReserveGB) * 1024).toFixed(0)} MB)
                                </p>
                                <p style="color: #90EE90; font-size: 13px; margin: 8px 0 0 0;">
                                    This is the minimum free space that must remain after uploads to prevent system crashes and ensure system stability.
                                </p>
                            </div>
                            
                            <!-- Violation Details -->
                            <div style="flex: 1; background: rgba(220, 53, 69, 0.1); border: 1px solid #dc3545; border-radius: 8px; padding: 15px;">
                                <div style="display: grid; grid-template-columns: 1fr; gap: 10px; font-size: 14px;">
                                    <div style="text-align: center;">
                                        <strong style="color: #ffc107;">Total Upload Size:</strong><br>
                                        <span style="color: #dc3545; font-size: 16px; font-weight: bold;">${totalSizeGB} GB</span>
                                        <span style="color: #dc3545; font-size: 13px; display: block;">(${(parseFloat(totalSizeGB) * 1024).toFixed(0)} MB)</span>
                                    </div>
                                    <div style="text-align: center;">
                                        <strong style="color: #ffc107;">Space After Upload:</strong><br>
                                        <span style="color: #dc3545; font-size: 16px; font-weight: bold;">${remainingGB} GB</span>
                                        <span style="color: #dc3545; font-size: 13px; display: block;">(${(parseFloat(remainingGB) * 1024).toFixed(0)} MB)</span>
                                    </div>
                                    <div style="text-align: center;">
                                        <strong style="color: #ffc107;">Current Pending:</strong><br>
                                        <span style="color: #17a2b8; font-size: 16px; font-weight: bold;">${pendingCount} files</span>
                                    </div>
                                </div>
                            </div>
                            
                            <!-- Action Message -->
                            <div style="flex: 1; background: rgba(255, 193, 7, 0.15); border: 2px solid #ffc107; border-radius: 8px; padding: 15px; display: flex; flex-direction: column; justify-content: center;">
                                <p style="color: #ffc107; font-size: 14px; margin: 0; text-align: center; font-weight: bold;">
                                     ACTION TAKEN: The ${newCount} file(s) you just selected will NOT be added to the upload queue to prevent reserve space violation.
                                </p>
                            </div>
                        </div>
                        
                        <!-- Management Suggestions -->
                        <div style="background: rgba(23, 162, 184, 0.1); border: 1px solid #17a2b8; border-radius: 8px; padding: 18px; margin: 12px 0;">
                            <h4 style="color: #17a2b8; margin: 0 0 12px 0; font-size: 18px; text-align: center;">
                                 Solutions to Resolve This Issue
                            </h4>
                            <div style="color: #e0e0e0; font-size: 15px;">
                                <h5 style="color: #ffc107; margin: 0 0 10px 0; font-size: 16px;"> Recommended Solutions:</h5>
                                <ul style="margin: 0; padding-left: 20px; line-height: 1.5;">
                                    <li>Upload files in smaller batches to stay within available space</li>
                                    <li>Remove some pending files before adding new ones</li>
                                    <li>Free up disk space by deleting old/unused files</li>
                                    <li>Consider upgrading storage capacity if frequently hitting limits</li>
                                    <li>Navigate to <strong>Settings  Storage Management</strong> to adjust reserve value (currently ${actualReserveGB} GB)</li>
                                    <li>Check the box in the quota disk section named <strong>"Use all available space - Unsets reserve value"</strong> to temporarily disable reserve</li>
                                </ul>
                            </div>
                        </div>
                    </div>
                    <div class="error-modal-footer" style="padding: 15px 25px; display: flex; justify-content: center; border-top: 1px solid #444;">
                        <button onclick="closeReserveViolationModal()" 
                                style="background: linear-gradient(135deg, #dc3545, #c82333); color: white; border: none; padding: 12px 30px; border-radius: 20px; font-size: 17px; font-weight: 600; cursor: pointer; min-width: 140px; box-shadow: 0 2px 8px rgba(220, 53, 69, 0.3);">
                            OK - Understood
                        </button>
                    </div>
                </div>
            `;
            
            modal.innerHTML = modalContent;
            document.body.appendChild(modal);
        }
        
        function closeReserveViolationModal() {
            const modal = document.getElementById('reserveViolationModal');
            if (modal) {
                modal.remove();
            }
            // Refresh storage info
            loadStorageInfo();
        }

        // Show insufficient reserve space modal
        function showInsufficientReserveModal(reservedGB, uploadSizeGB, remainingGB) {
            if (!storageInfo) return;
            
            // Calculate storage values in GB
            const totalGB = (storageInfo.total / (1024 * 1024 * 1024)).toFixed(2);
            const usedGB = (storageInfo.used / (1024 * 1024 * 1024)).toFixed(2);
            const availableGB = (storageInfo.available / (1024 * 1024 * 1024)).toFixed(2);
            
            // Update all modal content
            document.getElementById('reserveErrorModalTotalSpace').textContent = totalGB + ' GB';
            document.getElementById('reserveErrorModalUsedSpace').textContent = usedGB + ' GB';
            document.getElementById('reserveErrorModalAvailableSpace').textContent = availableGB + ' GB';
            document.getElementById('reserveErrorModalReservedValue').textContent = reservedGB.toFixed(2) + ' GB';
            document.getElementById('reserveModalUploadSize').textContent = uploadSizeGB.toFixed(2) + ' GB';
            document.getElementById('reserveModalRemainingSpace').textContent = remainingGB.toFixed(2) + ' GB';
            
            // Show modal
            document.getElementById('insufficientReserveModal').style.display = 'block';
        }
        
        // Show upload space valid modal
        function showUploadSpaceValidModal(reservedGB, uploadSizeGB, remainingGB) {
            if (!storageInfo) return;
            
            // Calculate storage values in GB
            const totalGB = (storageInfo.total / (1024 * 1024 * 1024)).toFixed(2);
            const usedGB = (storageInfo.used / (1024 * 1024 * 1024)).toFixed(2);
            const availableGB = (storageInfo.available / (1024 * 1024 * 1024)).toFixed(2);
            const uploadLimitGB = (storageInfo.upload_limit / (1024 * 1024 * 1024)).toFixed(2);
            
            // Update all modal content
            document.getElementById('reserveSuccessModalTotalSpace').textContent = totalGB + ' GB';
            document.getElementById('reserveSuccessModalUsedSpace').textContent = usedGB + ' GB';
            document.getElementById('reserveSuccessModalAvailableSpace').textContent = availableGB + ' GB';
            document.getElementById('reserveSuccessModalReservedValue').textContent = reservedGB.toFixed(2) + ' GB';
            document.getElementById('successModalUploadSize').textContent = uploadSizeGB.toFixed(2) + ' GB';
            document.getElementById('successModalRemainingSpace').textContent = remainingGB.toFixed(2) + ' GB';
            document.getElementById('successModalUploadLimit').textContent = uploadLimitGB + ' GB';
            
            // Show modal
            document.getElementById('uploadSpaceValidModal').style.display = 'block';
        }
        
        async function updateStorageDisplay() {
            if (!storageInfo) return;
            
            const usedGB = (storageInfo.used / (1024 * 1024 * 1024)).toFixed(2);
            const totalGB = (storageInfo.total / (1024 * 1024 * 1024)).toFixed(2);
            const availableGB = (storageInfo.available / (1024 * 1024 * 1024)).toFixed(2);
            const usedPercent = ((storageInfo.used / storageInfo.total) * 100).toFixed(1);
            
            // Get current reserve configuration
            let reserveText = " NOT SET";
            let reserveColor = "#ffff00";
            let uploadLimitGB = availableGB;
            
            try {
                // Simple direct read of config file
                const configResponse = await fetch("/api/file?path=/home/gus/video-system/docs/reserved_value.txt", {
                    headers: window.authHeaders
                });
                
                if (configResponse.ok) {
                    const configContent = await configResponse.text();
                    console.log("updateStorageDisplay - Config content:", configContent);
                    
                    // Simple parsing
                    let reservedValue = 0;
                    let reservedFlag = "True";
                    
                    const lines = configContent.split('\n');
                    lines.forEach(line => {
                        if (line.includes('reserved_value = ') && !line.startsWith('#') && !line.includes('flag') && !line.includes('upload_limit')) {
                            const value = line.split('= ')[1];
                            if (value) {
                                reservedValue = parseFloat(value.trim());
                            }
                        }
                        if (line.includes('reserved_value_flag = ') && !line.startsWith('#')) {
                            const flag = line.split('= ')[1];
                            if (flag) {
                                reservedFlag = flag.trim();
                            }
                        }
                    });
                    
                    console.log("updateStorageDisplay - Parsed:", {reservedValue, reservedFlag});
                    
                    if (reservedFlag === "False" && reservedValue > 0) {
                        // Reserve is set
                        reserveText = reservedValue + " GB";
                        reserveColor = "";
                        uploadLimitGB = Math.max(0, parseFloat(availableGB) - reservedValue).toFixed(2);
                        console.log("Reserve SET - Upload limit:", uploadLimitGB);
                    } else {
                        // Reserve is NOT SET
                        reserveText = " NOT SET";
                        reserveColor = "#ffff00";
                        uploadLimitGB = availableGB;
                        console.log("Reserve NOT SET");
                    }
                }
            } catch (error) {
                console.error("Could not read reserve config:", error);
                // Keep defaults: NOT SET
            }
            
            // Storage text and details content
            const storageText = `${usedGB} GB / ${totalGB} GB`;
            const storageDetails = `Available: ${availableGB} GB  Reserve: ${reserveText}  Upload limit: ${uploadLimitGB} GB`;
            
            // Update original storage display
            const originalStorageText = document.getElementById('storage-text');
            const originalStorageUsed = document.getElementById('storage-used');
            const originalStorageDetails = document.getElementById('storage-details');
            
            if (originalStorageText) originalStorageText.textContent = storageText;
            if (originalStorageUsed) originalStorageUsed.style.width = usedPercent + '%';
            if (originalStorageDetails) originalStorageDetails.textContent = storageDetails;
            
            // Update all new storage displays (video, files, general, downloads)
            const sections = ['video', 'files', 'general', 'downloads'];
            sections.forEach(section => {
                const textEl = document.getElementById(`storage-text-${section}`);
                const usedEl = document.getElementById(`storage-used-${section}`);
                const detailsEl = document.getElementById(`storage-details-${section}`);
                
                if (textEl) textEl.textContent = storageText;
                if (usedEl) usedEl.style.width = usedPercent + '%';
                if (detailsEl) detailsEl.textContent = storageDetails;
                
                // Also populate vertical storage fields
                if (document.getElementById("storage-available-" + section)) {
                    const parts = storageDetails.split("  ");
                    parts.forEach(part => {
                        if (part.includes("Available:")) document.getElementById("storage-available-" + section).textContent = part.replace("Available: ", "");
                        if (part.includes("Reserve:")) {
                            const reserveEl = document.getElementById("storage-reserve-" + section);
                            if (reserveEl) {
                                reserveEl.textContent = part.replace("Reserve: ", "");
                                // Apply yellow color if NOT SET
                                if (reserveColor) {
                                    reserveEl.style.color = reserveColor;
                                    reserveEl.style.fontWeight = "bold";
                                } else {
                                    reserveEl.style.color = "";
                                    reserveEl.style.fontWeight = "";
                                }
                            }
                        }
                        if (part.includes("Upload limit:")) document.getElementById("storage-upload-" + section).textContent = part.replace("Upload limit: ", "");
                    });
                }
            });
            
            // Also handle main upload section (no suffix)
            if (document.getElementById("storage-available-upload")) {
                const parts = storageDetails.split("  ");
                parts.forEach(part => {
                    if (part.includes("Available:")) document.getElementById("storage-available-upload").textContent = part.replace("Available: ", "");
                    if (part.includes("Reserve:")) {
                        const reserveEl = document.getElementById("storage-reserve-upload");
                        if (reserveEl) {
                            reserveEl.textContent = part.replace("Reserve: ", "");
                            // Apply yellow color if NOT SET
                            if (reserveColor) {
                                reserveEl.style.color = reserveColor;
                                reserveEl.style.fontWeight = "bold";
                            } else {
                                reserveEl.style.color = "";
                                reserveEl.style.fontWeight = "";
                            }
                        }
                    }
                    if (part.includes("Upload limit:")) document.getElementById("storage-upload-upload").textContent = part.replace("Upload limit: ", "");
                });
            }
        }
        
        function setupDragAndDrop() {
            const dropZone = document.getElementById('drop-zone');
            const fileInput = document.getElementById('file-input');
            
            console.log('Setting up drag and drop...', dropZone, fileInput);
            
            if (!dropZone || !fileInput) {
                console.error('Drop zone or file input not found!');
                return;
            }
            
            // Drag and drop events
            dropZone.addEventListener('dragover', (e) => {
                e.preventDefault();
                e.stopPropagation();
                dropZone.classList.add('drag-over');
                console.log('Drag over');
            });
            
            dropZone.addEventListener('dragenter', (e) => {
                e.preventDefault();
                e.stopPropagation();
                dropZone.classList.add('drag-over');
            });
            
            dropZone.addEventListener('dragleave', (e) => {
                e.preventDefault();
                e.stopPropagation();
                // Only remove class if we're leaving the drop zone completely
                if (!dropZone.contains(e.relatedTarget)) {
                    dropZone.classList.remove('drag-over');
                }
            });
            
            dropZone.addEventListener('drop', async (e) => {
                e.preventDefault();
                e.stopPropagation();
                dropZone.classList.remove('drag-over');
                console.log('Files dropped:', e.dataTransfer.files);
                // Check reserve space validation for drag & drop
                const files = Array.from(e.dataTransfer.files);
                const allFiles = [...pendingFiles, ...files];
                const reserveCheck = await checkReserveSpaceAvailability(allFiles);
                if (!reserveCheck.isValid) {
                    console.log('Drag & drop reserve validation FAILED - showing violation modal');
                    const totalSizeGB = (allFiles.reduce((sum, file) => sum + file.size, 0) / (1024 * 1024 * 1024)).toFixed(2);
                    const reserveGB = reserveCheck.reservedGB.toFixed(2);
                    const remainingGB = reserveCheck.remainingGB.toFixed(2);
                    
                    // Show detailed reserve violation modal
                    showReserveViolationModal(
                        totalSizeGB,
                        reserveGB, 
                        remainingGB,
                        pendingFiles.length,
                        files.length,
                        files
                    );
                    return;
                }
                
                await handleFileSelection(files);
            });
            
            // Browse button (label) - no need for click handler since label naturally triggers input
            const browseBtn = document.getElementById('browse-btn');
            console.log('Browse button found:', browseBtn);
            
            // Drop zone click (but not when clicking browse button/label)
            dropZone.addEventListener('click', (e) => {
                // Only trigger file input if we didn't click the browse label
                if (!e.target.classList.contains('browse-btn') && e.target.tagName !== 'LABEL') {
                    console.log('Drop zone clicked');
                    e.preventDefault();
                    fileInput.click();
                }
            });
            
            // Configure file input attributes
            fileInput.setAttribute('accept', 'video/*,.mp4,.webm,.ogg,.avi,.mov,.mkv,.flv');
            fileInput.setAttribute('multiple', 'true');
            
            // File input configured with CSS for proper browser dialog sizing
            
            // File input change
            fileInput.addEventListener('change', async (e) => {
                console.log('File input changed:', e.target.files);
                console.log('Number of files selected:', e.target.files.length);
                
                if (e.target.files.length === 0) {
                    console.log('No files selected (user canceled)');
                    return;
                }
                
                const files = Array.from(e.target.files);
                
                // IMMEDIATE reserve space validation for total upload (existing pending + new files)
                console.log('=== RESERVE VALIDATION AT FILE SELECTION ===');
                console.log('Current pending files:', pendingFiles.length);
                console.log('New files selected:', files.length);
                
                const allFiles = [...pendingFiles, ...files];
                console.log('Total files if added:', allFiles.length);
                
                const reserveCheck = await checkReserveSpaceAvailability(allFiles);
                if (!reserveCheck.isValid) {
                    console.log('RESERVE VALIDATION FAILED - blocking file addition');
                    const totalSizeGB = (allFiles.reduce((sum, file) => sum + file.size, 0) / (1024 * 1024 * 1024)).toFixed(2);
                    const reserveGB = reserveCheck.reservedGB.toFixed(2);
                    const remainingGB = reserveCheck.remainingGB.toFixed(2);
                    
                    // Show detailed reserve violation modal
                    showReserveViolationModal(
                        totalSizeGB,
                        reserveGB, 
                        remainingGB,
                        pendingFiles.length,
                        files.length,
                        files
                    );
                    e.target.value = '';
                    return;
                }
                console.log('RESERVE VALIDATION PASSED - allowing file addition');
                console.log('=== END RESERVE VALIDATION ===');
                
                handleFileSelection(files);
                // Reset the input so same file can be selected again
                e.target.value = '';
            });
        }
        
        async function handleFileSelection(files) {
            console.log('handleFileSelection called with:', files.length, 'files');
            
            if (!files || files.length === 0) {
                showError('No files selected.');
                return;
            }
            
            // Filter video files and show better error messages
            const videoFiles = [];
            const nonVideoFiles = [];
            
            for (const file of files) {
                console.log('File:', file.name, 'Type:', file.type, 'Size:', file.size);
                if (file.type.startsWith('video/') || 
                    file.name.toLowerCase().match(/\.(mp4|webm|ogg|avi|mov|mkv|flv)$/)) {
                    videoFiles.push(file);
                } else {
                    
                    nonVideoFiles.push(file);
                }
            }
            
            if (nonVideoFiles.length > 0) {
                showNonVideoFilesError(nonVideoFiles);
                // If there are no valid video files, don't continue
                if (videoFiles.length === 0) {
                    return;
                }
            }
            
            if (videoFiles.length === 0) {
                return; // No error modal needed, user didn't select any files
            }
            
            // No hardcoded file size or upload limitations - only dynamic reserve space validation applies
            
            // Add files to pending list
            console.log('DEBUG: Adding', videoFiles.length, 'video files to pendingFiles');
            console.log('DEBUG: pendingFiles before concat:', pendingFiles.length);
            pendingFiles = pendingFiles.concat(videoFiles);
            console.log('DEBUG: pendingFiles after concat:', pendingFiles.length);
            
            showSuccessModal(
                'Files Ready for Upload',
                `${pendingFiles.length} video file(s) selected and ready for upload.`,
                pendingFiles.map(f => f.name),
                null,
                pendingFiles
            );
            console.log('DEBUG: About to call displayFilePreview()');
            displayFilePreview();
            
            // Run reserve space validation in background
            setTimeout(async () => {
                const reserveCheck = await checkReserveSpaceAvailability(videoFiles);
                if (!reserveCheck.isValid) {
                    showInsufficientReserveModal(reserveCheck.reservedGB, reserveCheck.uploadSizeGB, reserveCheck.remainingGB);
                }
            }, 500);
        }
        
        function displayFilePreview() {
            console.log('DEBUG: displayFilePreview called, pendingFiles.length:', pendingFiles.length);
            const container = document.getElementById('file-preview-container');
            const list = document.getElementById('file-preview-list');
            
            console.log('DEBUG: container element:', container);
            console.log('DEBUG: list element:', list);
            
            if (pendingFiles.length === 0) {
                console.log('DEBUG: No pending files, hiding container');
                if (container) container.style.display = 'none';
                return;
            }
            
            console.log('DEBUG: Showing container with', pendingFiles.length, 'files');
            if (container) container.style.display = 'block';
            
            let html = '';
            let totalSize = 0;
            
            pendingFiles.forEach((file, index) => {
                const sizeMB = (file.size / (1024 * 1024)).toFixed(2);
                totalSize += file.size;
                
                html += `
                    <div class="file-preview-item">
                        <div class="file-preview-icon"></div>
                        <div class="file-preview-info">
                            <div class="file-preview-name">${file.name}</div>
                            <div class="file-preview-size">${sizeMB} MB</div>
                            <div class="progress-bar-container" id="progress-${index}">
                                <div class="progress-bar" id="progress-bar-${index}"></div>
                            </div>
                        </div>
                        <div class="file-preview-actions">
                            <button class="remove-file-btn" onclick="removeFile(${index})" title="Delete">&times;</button>
                        </div>
                    </div>
                `;
            });
            
            const totalSizeMB = (totalSize / (1024 * 1024)).toFixed(2);
            
            // Calculate remaining space after upload
            let remainingSpaceText = '';
            if (storageInfo && storageInfo.available) {
                const remainingBytes = storageInfo.available - totalSize;
                const remainingGB = (remainingBytes / (1024 * 1024 * 1024)).toFixed(2);
                const remainingMB = (remainingBytes / (1024 * 1024)).toFixed(2);
                
                if (remainingBytes >= 1024 * 1024 * 1024) {
                    remainingSpaceText = ` | Remaining after upload: ${remainingGB} GB`;
                } else {
                    remainingSpaceText = ` | Remaining after upload: ${remainingMB} MB`;
                }
            }
            
            html = `<div style="margin-bottom: 15px; color: #17a2b8;"><strong>Total: ${pendingFiles.length} files, ${totalSizeMB} MB${remainingSpaceText}</strong></div>` + html;
            
            list.innerHTML = html;
        }
        
        async function removeFile(index) {
            pendingFiles.splice(index, 1);
            
            // Refresh storage info after file removal
            console.log("File removed, refreshing storage data...");
            await loadStorageInfo();
            
            // Recalculate reserve space after file removal
            if (pendingFiles.length > 0) {
                const reserveCheck = await checkReserveSpaceAvailability(pendingFiles);
                
                if (!reserveCheck.isValid) {
                    // Still exceeds reserve space after removal
                    showInsufficientReserveModal(reserveCheck.reservedGB, reserveCheck.uploadSizeGB, reserveCheck.remainingGB);
                } else {
                    // Now within reserve space limits
                    const reserveConfig = await getReserveConfig();
                    const reservedValue = reserveConfig ? parseFloat(reserveConfig.reserved_value) || 0 : 0;
                    showUploadSpaceValidModal(reservedValue, reserveCheck.uploadSizeGB || 0, reserveCheck.remainingGB || 0);
                }
            }
            
            displayFilePreview();
        }
        
        function cancelUpload() {
            pendingFiles = [];
            displayFilePreview();
            document.getElementById('file-input').value = '';
        }
        
        async function confirmUpload() {
            console.log("DEBUG: confirmUpload called with", pendingFiles.length, "files");
            if (pendingFiles.length === 0) return;
            
            // Reset upload stats for new upload session
            uploadStats = {
                startTime: null,
                endTime: null,
                totalBytes: 0,
                completedFiles: []
            };
            
            uploadInProgress = true;
            const modal = document.getElementById('upload-modal');
            const progressContainer = document.getElementById('upload-progress-container');
            
            modal.style.display = 'block';
            
            let html = '<h3 id="upload-progress-header"> Uploading Files - Uploaded: 0 | Total files to upload: ' + pendingFiles.length + '...</h3>';
            pendingFiles.forEach((file, index) => {
                html += `
                    <div style="margin: 15px 0; padding: 15px; background: rgba(0,0,0,0.3); border-radius: 10px;">
                        <div style="display: flex; justify-content: space-between; margin-bottom: 10px;">
                            <span>${file.name}</span>
                            <span id="status-${index}"> Preparing...</span>
                        </div>
                        <div style="display: flex; justify-content: space-between; margin-bottom: 10px; font-size: 0.9em; color: white;">
                            <span id="percentage-${index}">0%</span>
                            <span id="speed-${index}">--</span>
                        </div>
                        <div style="display: flex; justify-content: space-between; margin-bottom: 20px; font-size: 0.85em; color: white;">
                            <span id="data-size-${index}">0 B / ${(file.size / 1024 / 1024 > 1 ? (file.size / 1024 / 1024).toFixed(1) + ' MB' : (file.size / 1024).toFixed(1) + ' KB')}</span>
                            <span id="time-remaining-${index}">--</span>
                        </div>
                        <div style="width: 100%; background: rgba(0,0,0,0.3); border-radius: 5px; overflow: hidden;">
                            <div id="upload-progress-${index}" style="height: 10px; background: linear-gradient(90deg, #17a2b8, #28a745); width: 0%; transition: none;"></div>
                        </div>
                    </div>
                `;
            });
            
            progressContainer.innerHTML = html;
            
            // Upload files one by one
            console.log("DEBUG: About to start upload loop for", pendingFiles.length, "files");
            for (let i = 0; i < pendingFiles.length; i++) {
                console.log("DEBUG: Uploading file", i, ":", pendingFiles[i].name);
                await uploadFile(pendingFiles[i], i);
            }
            
            // Upload complete - show OK button in progress modal
            console.log("All uploads complete - showing OK button");
            
            // Show OK button in the progress modal
            const modalFooter = document.getElementById('upload-modal-footer');
            if (modalFooter) {
                modalFooter.style.display = 'block';
                console.log("OK button shown in video upload modal");
            }
        }
        
        function uploadFile(file, index) {
            return new Promise((resolve, reject) => {
                const formData = new FormData();
                
                // Log video upload with specific details
                console.log("DEBUG: About to log video upload for:", file.name);
                logAction(
                    "User uploaded video: " + file.name,
                    "File size: " + (file.size / 1024 / 1024).toFixed(2) + " MB |  Type: " + file.type + " | Target: videos/",
                    "/api/upload",
                    "POST"
                );
                formData.append('video', file);
                
                const progressBar = document.getElementById(`upload-progress-${index}`);
                const statusSpan = document.getElementById(`status-${index}`);
                const percentageSpan = document.getElementById(`percentage-${index}`);
                const speedSpan = document.getElementById(`speed-${index}`);
                const progressContainer = progressBar.parentElement;
                
                const xhr = new XMLHttpRequest();
                
                // Track upload speed and statistics
                let startTime = Date.now();
                let uploadStartDate = new Date();
                let lastTime = startTime;
                let lastLoaded = 0;
                
                // Initialize upload stats if not exists
                if (!uploadStats.startTime) {
                    uploadStats.startTime = uploadStartDate;
                    uploadStats.totalBytes = 0;
                    uploadStats.completedFiles = [];
                }
                uploadStats.totalBytes += file.size;
                
                // Upload progress event
                xhr.upload.addEventListener('progress', (event) => {
                    if (event.lengthComputable) {
                        const percentage = Math.round((event.loaded / event.total) * 100);
                        const currentTime = Date.now();
                        const elapsedTime = (currentTime - lastTime) / 1000; // seconds
                        const bytesTransferred = event.loaded - lastLoaded;
                        
                        // Update progress bar and percentage with enhanced styling
                        progressBar.style.width = percentage + '%';
                        percentageSpan.innerHTML = `<span style="font-size: 16px; font-weight: bold; color: #22c55e;">${percentage}%</span>`;
                        statusSpan.textContent = ' Uploading...';
                        
                        // Update uploaded data display in MB
                        const dataSizeSpan = document.getElementById(`data-size-${index}`);
                        if (dataSizeSpan) {
                            const uploadedMB = (event.loaded / 1024 / 1024).toFixed(1);
                            const totalMB = (event.total / 1024 / 1024).toFixed(1);
                            dataSizeSpan.textContent = `${uploadedMB} MB / ${totalMB} MB`;
                        }
                        
                        // Calculate and display speed (only update every 500ms to avoid flickering)
                        if (elapsedTime >= 0.5) {
                            const speed = bytesTransferred / elapsedTime; // bytes per second
                            let speedText;
                            
                            if (speed < 1024) {
                                speedText = speed.toFixed(0) + ' B/s';
                            } else if (speed < 1024 * 1024) {
                                speedText = (speed / 1024).toFixed(1) + ' KB/s';
                            } else {
                                speedText = (speed / (1024 * 1024)).toFixed(1) + ' MB/s';
                            }
                            
                            // Single speed display only
                            speedSpan.textContent = speedText;
                            lastTime = currentTime;
                            lastLoaded = event.loaded;
                        }
                    }
                });
                
                // Upload completion event
                xhr.addEventListener('load', () => {
                    if (xhr.status >= 200 && xhr.status < 300) {
                        try {
                            const result = JSON.parse(xhr.responseText);
                            console.log('Upload success:', result);
                            progressBar.style.width = '100%';
                            percentageSpan.textContent = '100%';
                            statusSpan.textContent = ' Complete';
                            speedSpan.textContent = 'Done';
                            
                            // Track upload statistics
                            let endTime = Date.now();
                            let uploadEndDate = new Date();
                            let duration = (endTime - startTime) / 1000; // seconds
                            
                            uploadStats.completedFiles.push({
                                name: file.name,
                                size: file.size,
                                startTime: uploadStartDate.toLocaleTimeString(),
                                endTime: uploadEndDate.toLocaleTimeString(),
                                duration: duration
                            });
                            
                            uploadStats.endTime = uploadEndDate;
                            
                            // Update upload progress header counter
                            const headerElement = document.getElementById('upload-progress-header');
                            if (headerElement) {
                                headerElement.textContent = ` Uploading Files - Uploaded: ${uploadStats.completedFiles.length} | Total files to upload: ${pendingFiles.length}...`;
                            }
                            
                            // Add enhanced completion statistics below progress bar
                            const statsDiv = document.createElement('div');
                            statsDiv.style.cssText = `
                                background: linear-gradient(135deg, #1e293b, #334155);
                                color: #fff;
                                padding: 15px;
                                margin-top: 8px;
                                border-radius: 8px;
                                font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
                                font-size: 13px;
                                line-height: 1.6;
                                border: 1px solid #475569;
                                box-shadow: 0 4px 6px rgba(0, 0, 0, 0.1);
                            `;
                            const throughput = file.size > 0 && duration > 0 ? (file.size * 8 / duration / 1000000).toFixed(1) : '0';
                            const durationFormatted = `${Math.floor(duration / 60)}:${String(Math.floor(duration % 60)).padStart(2, '0')}`;
                            statsDiv.innerHTML = `
                                <div style="display: grid; grid-template-columns: 1fr 1fr; gap: 12px; font-weight: 500;">
                                    <div>
                                        <div style="color: #22c55e; font-size: 12px; margin-bottom: 2px;"> STARTED</div>
                                        <div style="font-size: 14px; font-weight: 600;">${uploadStartDate.toLocaleTimeString()}</div>
                                    </div>
                                    <div>
                                        <div style="color: #3b82f6; font-size: 12px; margin-bottom: 2px;"> COMPLETED</div>
                                        <div style="font-size: 14px; font-weight: 600;">${uploadEndDate.toLocaleTimeString()}</div>
                                    </div>
                                    <div>
                                        <div style="color: #f59e0b; font-size: 12px; margin-bottom: 2px;"> DURATION</div>
                                        <div style="font-size: 14px; font-weight: 600;">${durationFormatted}</div>
                                    </div>
                                    <div>
                                        <div style="color: #ef4444; font-size: 12px; margin-bottom: 2px;"> AVERAGE SPEED</div>
                                        <div style="font-size: 14px; font-weight: 600;">${throughput} Mbps</div>
                                    </div>
                                </div>
                                <div style="margin-top: 8px; padding-top: 8px; border-top: 1px solid #475569; text-align: center;">
                                    <span style="color: #94a3b8; font-size: 12px;"> Size: </span>
                                    <span style="color: #fff; font-weight: 600;">${(file.size / (1024 * 1024)).toFixed(1)} MB</span>
                                </div>
                            `;
                            progressContainer.appendChild(statsDiv);
                            
                            resolve(result);
                        } catch (error) {
                            console.error('Error parsing response:', error);
                            statusSpan.textContent = ' Failed';
                            progressBar.style.background = '#dc3545';
                            speedSpan.textContent = 'Error';
                            reject(new Error('Invalid server response'));
                        }
                    } else {
                        // File size restrictions removed - allow all uploads based on client-side reserve value check only
                        // (413 error handling disabled per user request)
                        
                        console.error('Upload failed:', xhr.status, xhr.responseText);
                        statusSpan.textContent = ' Failed';
                        progressBar.style.background = '#dc3545';
                        speedSpan.textContent = 'Error';
                        reject(new Error(`Upload failed: ${xhr.status} - ${xhr.responseText}`));
                    }
                });
                
                // Upload error event
                xhr.addEventListener('error', () => {
                    console.error('Upload error:', xhr.statusText);
                    statusSpan.textContent = ' Failed';
                    progressBar.style.background = '#dc3545';
                    speedSpan.textContent = 'Error';
                    reject(new Error('Upload failed: Network error'));
                });
                
                // Upload abort event
                xhr.addEventListener('abort', () => {
                    console.log('Upload aborted');
                    statusSpan.textContent = ' Aborted';
                    progressBar.style.background = '#ffc107';
                    speedSpan.textContent = 'Aborted';
                    reject(new Error('Upload aborted'));
                });
                
                // Setup request
                xhr.open('POST', '/api/upload');
                xhr.setRequestHeader('Authorization', window.authHeaders.Authorization);
                
                // Start upload
                statusSpan.textContent = ' Starting...';
                xhr.send(formData);
            });
        }
        
        function closeUploadModal() {
            document.getElementById('upload-modal').style.display = 'none';
            uploadInProgress = false;
        }

        // showScpInstructionsModal function removed - file size restrictions disabled per user request
        // Upload control now relies solely on client-side reserve value checking
        
        // Download functions
        
        async function loadDownloadVideoList() {
            if (currentMode !== 'download') return;
            
            const container = document.getElementById('download-video-list');
            container.innerHTML = '<div class="loading">Loading available videos...</div>';
            
            try {
                const response = await fetch('/api/videos', {
                    headers: window.authHeaders
                });
                
                if (!response.ok) throw new Error('Failed to load video catalog');
                
                const data = await response.json();
                displayDownloadVideoList(data.videos || []);
                
            } catch (error) {
                container.innerHTML = `<div class="error">Error loading videos: ${error.message}</div>`;
            }
        }
        
        function displayDownloadVideoList(videos) {
            const container = document.getElementById('download-video-list');
            
            if (!videos || videos.length === 0) {
                container.innerHTML = '<div class="error">No videos available for download</div>';
                return;
            }
            
            let html = '';
            videos.forEach((video, index) => {
                const videoId = `video-${index}`;
                const thumbnailId = `thumbnail-download-${index}`;
                const isSelected = selectedVideos.has(video.path);
                
                html += `
                    <div class="download-video-item">
                        <input type="checkbox" class="video-checkbox" id="${videoId}" 
                               data-video-path="${video.path}" data-video-name="${video.name}"
                               ${isSelected ? 'checked' : ''} onchange="toggleVideoSelection(this)">
                        <div class="video-thumbnail-container" id="${thumbnailId}"
                             onmouseenter="handleThumbnailHover('${video.name}', '${video.path}', '${thumbnailId}')"
                             onmouseleave="handleThumbnailLeave('${thumbnailId}')"
                             onclick="handleThumbnailHover('${video.name}', '${video.path}', '${thumbnailId}')"
                             style="margin-right: 15px;">
                            <div class="video-thumbnail-placeholder"></div>
                            <div class="video-thumbnail-loading" style="display: none;">Loading...</div>
                            <video class="video-thumbnail" muted></video>
                        </div>
                        <div class="download-video-info">
                            <div class="download-video-name" 
                                 onmouseenter="handleThumbnailHover('${video.name}', '${video.path}', '${thumbnailId}')"
                                 onmouseleave="handleThumbnailLeave('${thumbnailId}')"
                                 onclick="handleThumbnailHover('${video.name}', '${video.path}', '${thumbnailId}')"
                                 style="cursor: pointer;">${video.name}</div>
                            <div class="download-video-meta">${video.size}  ${video.directory}</div>
                        </div>
                    </div>
                `;
            });
            
            container.innerHTML = html;
            updateSelectionCount();
        }
        
        function toggleVideoSelection(checkbox) {
            const videoPath = checkbox.getAttribute('data-video-path');
            const videoName = checkbox.getAttribute('data-video-name');
            
            if (checkbox.checked) {
                selectedVideos.add(videoPath);
            } else {
                    
                selectedVideos.delete(videoPath);
            }
            
            updateSelectionCount();
        }
        
        function selectAllVideos() {
            console.log('Select All Videos clicked');
            const checkboxes = document.querySelectorAll('.video-checkbox');
            console.log('Found checkboxes:', checkboxes.length);
            
            checkboxes.forEach(checkbox => {
                checkbox.checked = true;
                const videoPath = checkbox.getAttribute('data-video-path');
                console.log('Adding video:', videoPath);
                selectedVideos.add(videoPath);
            });
            
            console.log('Selected videos count:', selectedVideos.size);
            updateSelectionCount();
        }
        
        function clearAllVideos() {
            console.log('Clear All Videos clicked');
            const checkboxes = document.querySelectorAll('.video-checkbox');
            console.log('Found checkboxes to clear:', checkboxes.length);
            
            checkboxes.forEach(checkbox => {
                checkbox.checked = false;
                const videoPath = checkbox.getAttribute('data-video-path');
                selectedVideos.delete(videoPath);
            });
            
            console.log('Selected videos count after clear:', selectedVideos.size);
            updateSelectionCount();
        }
        
        function updateSelectionCount() {
            const count = selectedVideos.size;
            const countElement = document.getElementById('selection-count');
            const downloadBtn = document.getElementById('download-selected-btn');
            
            console.log('Updating selection count:', count);
            console.log('Count element found:', !!countElement);
            console.log('Download button found:', !!downloadBtn);
            
            if (countElement) {
                countElement.textContent = `${count} video${count !== 1 ? 's' : ''} selected`;
            }
            
            if (downloadBtn) {
                downloadBtn.disabled = count === 0;
                if (count === 0) {
                    downloadBtn.style.opacity = '0.5';
                    downloadBtn.style.cursor = 'not-allowed';
                } else {
                    downloadBtn.style.opacity = '1';
                    downloadBtn.style.cursor = 'pointer';
                }
            }
        }
        
        async function downloadSelected() {
            if (selectedVideos.size === 0) {
                showError('Please select at least one video to download.', 'No Videos Selected');;
                return;
            }
            
            if (downloadInProgress) {
                showError('Download already in progress');
                return;
            }
            
            const formatRadio = document.querySelector('input[name="download-format"]:checked');
            const downloadFormat = formatRadio ? formatRadio.value : 'individual';
            
            downloadInProgress = true;
            
            // Show download modal like upload modal
            const modal = document.getElementById('download-modal');
            const progressContainer = document.getElementById('download-modal-progress-container');
            
            modal.style.display = 'block';
            
            // Clear and prepare progress container like upload modal with counter
            const totalFiles = downloadFormat === 'zip' ? 1 : selectedVideos.size;
            progressContainer.innerHTML = '<h3 id="download-progress-header"> Downloading Files - Downloaded: 0 | Total files to download: ' + totalFiles + '...</h3>';
            console.log('Progress container prepared:', progressContainer);
            
            try {
                if (downloadFormat === 'zip') {
                    await downloadAsZip();
                } else {
                    await downloadIndividually();
                }
            } catch (error) {
                showError(`Download failed: ${error.message}`);
                // Show footer on error
                const footer = document.getElementById('download-modal-footer');
                const okBtn = document.getElementById('download-ok-btn');
                if (footer && okBtn) {
                    footer.style.display = 'block';
                    okBtn.style.display = 'inline-block';
                    okBtn.textContent = 'Press Ok to close this window';
                }
            } finally {
                downloadInProgress = false;
                // Note: Footer will be shown by individual download functions when complete
            }
        }
        
        async function downloadIndividually() {
            const progressContainer = document.getElementById('download-modal-progress-container');
            
            // Pre-populate all progress items immediately
            const progressIds = [];
            const videos = Array.from(selectedVideos);
            console.log('About to add progress items for videos:', videos.length);
            
            // Track completion
            let completedDownloads = 0;
            let failedDownloads = 0;
            const totalDownloads = videos.length;
            
            videos.forEach((videoPath, index) => {
                const videoName = videoPath.split('/').pop();
                const progressId = `progress-${Date.now()}-${index}`;
                progressIds.push(progressId);
                
                const progressHtml = `
                    <div style="margin: 15px 0; padding: 15px; background: rgba(0,0,0,0.3); border-radius: 10px;">
                        <div style="display: flex; justify-content: space-between; margin-bottom: 10px;">
                            <span>${videoName}</span>
                            <span id="status-${progressId}"> Preparing...</span>
                        </div>
                        <div style="display: flex; justify-content: space-between; margin-bottom: 10px; font-size: 0.9em; color: white;">
                            <span id="percentage-${progressId}">0%</span>
                            <span id="speed-${progressId}">--</span>
                        </div>
                        <div style="display: flex; justify-content: space-between; margin-bottom: 20px; font-size: 0.85em; color: white;">
                            <span id="data-size-${progressId}">0 B / Calculating...</span>
                            <span id="time-remaining-${progressId}">--</span>
                        </div>
                        <div style="width: 100%; background: rgba(0,0,0,0.3); border-radius: 5px; overflow: hidden;">
                            <div id="bar-${progressId}" style="height: 10px; background: linear-gradient(90deg, #17a2b8, #28a745); width: 0%; transition: none;"></div>
                        </div>
                        <div id="report-${progressId}" style="margin-top: 15px; padding: 12px; background: rgba(0,0,0,0.6); border-radius: 8px; display: none;">
                            <div style="display: flex; justify-content: space-between; margin-bottom: 8px;">
                                <span style="color: #4CAF50;"> <strong>STARTED</strong></span>
                                <span id="start-time-${progressId}" style="color: #4CAF50;">--</span>
                                <span style="color: #2196F3;"> <strong>COMPLETED</strong></span>
                                <span id="end-time-${progressId}" style="color: #2196F3;">--</span>
                            </div>
                            <div style="display: flex; justify-content: space-between; margin-bottom: 8px;">
                                <span style="color: #FF9800;"> <strong>DURATION</strong></span>
                                <span id="duration-${progressId}" style="color: #FF9800;">--</span>
                                <span style="color: #E91E63;"> <strong>AVERAGE SPEED</strong></span>
                                <span id="avg-speed-${progressId}" style="color: #E91E63;">--</span>
                            </div>
                            <div style="text-align: center; margin-top: 8px;">
                                <span style="color: #FFC107;"> <strong>Size:</strong> <span id="file-size-${progressId}">--</span></span>
                            </div>
                        </div>
                    </div>
                `;
                progressContainer.innerHTML += progressHtml;
                console.log('Added progress item for:', videoName);
            });
            
            console.log('Progress container content after adding items:', progressContainer.innerHTML);
            
            // Now process downloads one by one
            for (let i = 0; i < videos.length; i++) {
                const videoPath = videos[i];
                const videoName = videoPath.split('/').pop();
                const progressId = progressIds[i];
                
                try {
                    const statusElement = document.getElementById(`status-${progressId}`);
                    const barElement = document.getElementById(`bar-${progressId}`);
                    const percentageElement = document.getElementById(`percentage-${progressId}`);
                    const speedElement = document.getElementById(`speed-${progressId}`);
                    const dataSizeElement = document.getElementById(`data-size-${progressId}`);
                    const timeRemainingElement = document.getElementById(`time-remaining-${progressId}`);
                    const reportElement = document.getElementById(`report-${progressId}`);
                    const startTimeElement = document.getElementById(`start-time-${progressId}`);
                    const endTimeElement = document.getElementById(`end-time-${progressId}`);
                    const durationElement = document.getElementById(`duration-${progressId}`);
                    const avgSpeedElement = document.getElementById(`avg-speed-${progressId}`);
                    const fileSizeElement = document.getElementById(`file-size-${progressId}`);
                    
                    const startTime = Date.now();
                    const startTimeStr = new Date(startTime).toLocaleTimeString('en-US', { hour12: false });
                    
                    statusElement.textContent = ' Downloading...';
                    percentageElement.textContent = '0%';
                    barElement.style.width = '0%';
                    speedElement.textContent = '--';
                    dataSizeElement.textContent = '0 B / Calculating...';
                    timeRemainingElement.textContent = '--';
                    
                    const response = await fetch(`/api/download?path=${encodeURIComponent(videoPath)}`, {
                        headers: window.authHeaders
                    });
                    
                    if (!response.ok) {
                        throw new Error(`HTTP ${response.status}: ${response.statusText}`);
                    }
                    
                    const fileSize = parseInt(response.headers.get('content-length')) || 0;
                    const fileSizeText = fileSize > 1024*1024 ? `${(fileSize/1024/1024).toFixed(1)} MB` : `${(fileSize/1024).toFixed(1)} KB`;
                    
                    // Update with file size info
                    dataSizeElement.textContent = `0 B / ${fileSizeText}`;
                    
                    // Simulate progress updates for visual feedback
                    barElement.style.width = '50%';
                    percentageElement.textContent = '50%';
                    speedElement.textContent = 'Receiving...';
                    const halfSizeText = fileSize > 1024*1024 ? `${(fileSize/2/1024/1024).toFixed(1)} MB` : `${(fileSize/2/1024).toFixed(1)} KB`;
                    dataSizeElement.textContent = `${halfSizeText} / ${fileSizeText}`;
                    timeRemainingElement.textContent = 'Estimating...';
                    
                    // Add real-time progress tracking
                    let downloadedBytes = 0;
                    const reader = response.body.getReader();
                    const chunks = [];
                    
                    // Update progress every 500ms
                    const progressInterval = setInterval(() => {
                        if (fileSize > 0) {
                            const percentage = Math.min(100, (downloadedBytes / fileSize) * 100);
                            const downloadedText = downloadedBytes > 1024*1024 ? 
                                `${(downloadedBytes/1024/1024).toFixed(1)} MB` : 
                                `${(downloadedBytes/1024).toFixed(1)} KB`;
                            
                            barElement.style.width = `${percentage}%`;
                            percentageElement.textContent = `${Math.floor(percentage)}%`;
                            dataSizeElement.textContent = `${downloadedText} / ${fileSizeText}`;
                        }
                    }, 500);
                    
                    // Stream download
                    try {
                        while (true) {
                            const { done, value } = await reader.read();
                            if (done) break;
                            chunks.push(value);
                            downloadedBytes += value.length;
                        }
                    } finally {
                        clearInterval(progressInterval);
                    }
                    
                    const blob = new Blob(chunks);
                    const actualFileSize = blob.size;
                    const endTime = Date.now();
                    const duration = (endTime - startTime) / 1000;
                    const speed = actualFileSize / duration;
                    const speedText = speed > 1024*1024 ? `${(speed/1024/1024).toFixed(1)} MB/s` : `${(speed/1024).toFixed(1)} KB/s`;
                    const actualFileSizeText = actualFileSize > 1024*1024 ? `${(actualFileSize/1024/1024).toFixed(1)} MB` : `${(actualFileSize/1024).toFixed(1)} KB`;
                    const durationText = duration < 1 ? '0:01' : `0:${Math.floor(duration).toString().padStart(2, '0')}`;
                    const endTimeStr = new Date(endTime).toLocaleTimeString('en-US', { hour12: false });
                    
                    // Update to completion
                    barElement.style.width = '100%';
                    percentageElement.textContent = '100%';
                    speedElement.textContent = speedText;
                    dataSizeElement.textContent = `${actualFileSizeText} / ${actualFileSizeText}`;
                    timeRemainingElement.textContent = 'Complete';
                    statusElement.textContent = ' Complete';
                    
                    // Show and populate the detailed report
                    reportElement.style.display = 'block';
                    startTimeElement.textContent = startTimeStr;
                    endTimeElement.textContent = endTimeStr;
                    durationElement.textContent = durationText;
                    avgSpeedElement.textContent = speedText;
                    fileSizeElement.textContent = actualFileSizeText;
                    
                    // Create download link
                    const url = URL.createObjectURL(blob);
                    const a = document.createElement('a');
                    a.style.display = 'none';
                    a.href = url;
                    a.download = videoName;
                    
                    document.body.appendChild(a);
                    a.click();
                    document.body.removeChild(a);
                    
                    // Cleanup
                    setTimeout(() => URL.revokeObjectURL(url), 10000);
                    
                    // Small delay to ensure user sees the completion before footer shows
                    await new Promise(resolve => setTimeout(resolve, 1000));
                    
                    // Track successful completion
                    completedDownloads++;
                    
                    // Update download progress header counter
                    const headerElement = document.getElementById('download-progress-header');
                    if (headerElement) {
                        headerElement.textContent = ` Downloading Files - Downloaded: ${completedDownloads + failedDownloads} | Total files to download: ${totalDownloads}...`;
                    }
                    
                } catch (error) {
                    const statusElement = document.getElementById(`status-${progressId}`);
                    statusElement.textContent = ' Failed';
                    console.error(`Download failed for ${videoName}:`, error);
                    
                    // Track failed completion
                    failedDownloads++;
                    
                    // Update download progress header counter
                    const headerElement = document.getElementById('download-progress-header');
                    if (headerElement) {
                        headerElement.textContent = ` Downloading Files - Downloaded: ${completedDownloads + failedDownloads} | Total files to download: ${totalDownloads}...`;
                    }
                }
                
                // Check if all downloads are complete
                if (completedDownloads + failedDownloads === totalDownloads) {
                    // All downloads finished, show footer
                    console.log(`All downloads completed: ${completedDownloads} successful, ${failedDownloads} failed`);
                    const footer = document.getElementById('download-modal-footer');
                    const okBtn = document.getElementById('download-ok-btn');
                    if (footer && okBtn) {
                        footer.style.display = 'block';
                        okBtn.style.display = 'inline-block';
                        okBtn.textContent = 'Press Ok to close this window';
                    }
                }
            }
        }
        
        async function downloadAsZip() {
            const progressContainer = document.getElementById('download-modal-progress-container');
            const progressId = `zip-videos-progress-${Date.now()}`;
            const videoPaths = Array.from(selectedVideos);
            
            // Add ZIP Compression progress item
            progressContainer.innerHTML += `
                <div id="${progressId}-compression" class="progress-item">
                    <div class="progress-header">
                        <span class="file-name"> Compressing ${videoPaths.length} videos to archive</span>
                        <span class="progress-status"> Starting compression...</span>
                    </div>
                    <div class="progress-details">
                        <span class="progress-percentage">0%</span>
                        <span class="progress-speed"></span>
                        <span class="file-size">Processing videos...</span>
                    </div>
                    <div class="progress-bar">
                        <div class="progress-fill" style="width: 0%"></div>
                    </div>
                    <div class="progress-right">
                        <div class="progress-right-status"> Compressing...</div>
                        <div class="progress-right-details">
                            <div>Videos: ${videoPaths.length}</div>
                            <div>Processing...</div>
                        </div>
                    </div>
                </div>
            `;
            
            // Add ZIP Download progress item (initially hidden)
            progressContainer.innerHTML += `
                <div id="${progressId}-download" class="progress-item" style="display: none;">
                    <div class="progress-header">
                        <span class="file-name"> Downloading ZIP archive</span>
                        <span class="progress-status"> Preparing download...</span>
                    </div>
                    <div class="progress-details">
                        <span class="progress-percentage">0%</span>
                        <span class="progress-speed"></span>
                        <span class="file-size"></span>
                    </div>
                    <div class="progress-bar">
                        <div class="progress-fill" style="width: 0%"></div>
                    </div>
                    <div class="progress-right">
                        <div class="progress-right-status"> Downloading...</div>
                        <div class="progress-right-details">
                            <div>Receiving...</div>
                            <div>Estimating...</div>
                        </div>
                    </div>
                </div>
            `;
            
            try {
                const startTime = Date.now();
                
                // Phase 1: Compression progress (0-100%)
                const compressionElement = document.querySelector(`#${progressId}-compression`);
                compressionElement.querySelector('.progress-status').innerHTML = ' Compressing videos...';
                compressionElement.querySelector('.progress-right-status').textContent = ' Creating archive...';
                
                // Simulate realistic compression progress
                let compressionProgress = 0;
                const compressionInterval = setInterval(() => {
                    compressionProgress += Math.random() * 12 + 3; // 3-15% increments
                    if (compressionProgress > 100) compressionProgress = 100;
                    
                    if (compressionElement) {
                        compressionElement.querySelector('.progress-percentage').textContent = `${Math.round(compressionProgress)}%`;
                        compressionElement.querySelector('.progress-fill').style.width = `${compressionProgress}%`;
                        compressionElement.querySelector('.file-size').textContent = `Processing ${videoPaths.length} videos...`;
                        compressionElement.querySelector('.progress-right-details').innerHTML = `
                            <div>Videos: ${videoPaths.length}</div>
                            <div>${Math.round(compressionProgress)}% compressed</div>
                        `;
                        
                        if (compressionProgress >= 100) {
                            clearInterval(compressionInterval);
                            compressionElement.querySelector('.progress-status').innerHTML = ' Compression complete';
                            compressionElement.querySelector('.progress-right-status').textContent = ' Archive created';
                            compressionElement.querySelector('.progress-right-details').innerHTML = `
                                <div>Videos: ${videoPaths.length}</div>
                                <div>100% compressed</div>
                            `;
                            
                            // Add waiting message IMMEDIATELY when compression hits 100%
                            setTimeout(() => {
                                const waitingMessage = document.createElement('div');
                                waitingMessage.className = 'waiting-message';
                                waitingMessage.style.cssText = 'margin: 15px 0; padding: 12px; background: rgba(255, 193, 7, 0.1); border: 1px solid #ffc107; border-radius: 8px; text-align: center; color: #ffc107; font-weight: 500;';
                                waitingMessage.innerHTML = ' Waiting for Zip file to be downloaded...';
                                compressionElement.appendChild(waitingMessage);
                            }, 300); // Small delay to let the completion message render
                        }
                    }
                }, 300);
                
                // Start ZIP creation
                const response = await fetch('/api/download-zip', {
                    method: 'POST',
                    headers: window.authHeaders,
                    body: JSON.stringify({ videos: videoPaths })
                });
                
                // Wait for compression to complete
                while (compressionProgress < 100) {
                    await new Promise(resolve => setTimeout(resolve, 100));
                }
                
                // Add compression completion report
                const compressionEndTime = Date.now();
                const compressionDuration = (compressionEndTime - startTime) / 1000;
                const completionReportCompression = document.createElement('div');
                completionReportCompression.className = 'completion-report-horizontal';
                completionReportCompression.innerHTML = `
                    <div class="report-line">
                        <span class="report-item"> STARTED ${new Date(startTime).toLocaleTimeString()}</span>
                        <span class="report-item"> COMPLETED ${new Date(compressionEndTime).toLocaleTimeString()}</span>
                        <span class="report-item"> DURATION ${formatDuration(compressionDuration)}</span>
                        <span class="report-item"> VIDEOS COMPRESSED ${videoPaths.length}</span>
                    </div>
                `;
                compressionElement.appendChild(completionReportCompression);
                
                // Show download progress item (waiting message already added when compression hit 100%)
                const downloadElement = document.querySelector(`#${progressId}-download`);
                downloadElement.style.display = 'block';
                
                if (!response.ok) {
                    throw new Error(`Failed to create ZIP archive: ${response.status} ${response.statusText}`);
                }
                
                // Phase 2: Download with streaming progress (separate 0-100%)
                const contentLength = response.headers.get('Content-Length');
                const totalBytes = contentLength ? parseInt(contentLength) : 0;
                
                downloadElement.querySelector('.progress-status').innerHTML = ' Downloading ZIP...';
                downloadElement.querySelector('.progress-right-status').textContent = ' Receiving data...';
                
                const reader = response.body.getReader();
                const chunks = [];
                let receivedBytes = 0;
                const downloadStartTime = Date.now();
                
                // Real-time download progress (0-100% for download only)
                const downloadInterval = setInterval(() => {
                    const elapsed = (Date.now() - downloadStartTime) / 1000;
                    const speed = receivedBytes / elapsed;
                    const percentage = totalBytes > 0 ? Math.round((receivedBytes / totalBytes) * 100) : 0;
                    
                    if (downloadElement) {
                        downloadElement.querySelector('.progress-percentage').textContent = `${percentage}%`;
                        downloadElement.querySelector('.progress-fill').style.width = `${percentage}%`;
                        downloadElement.querySelector('.progress-speed').textContent = formatSpeed(speed);
                        
                        if (totalBytes > 0) {
                            downloadElement.querySelector('.file-size').textContent = 
                                `${formatBytes(receivedBytes)} / ${formatBytes(totalBytes)}`;
                        } else {
                            downloadElement.querySelector('.file-size').textContent = formatBytes(receivedBytes);
                        }
                        
                        downloadElement.querySelector('.progress-right-details').innerHTML = `
                            <div>Receiving...</div>
                            <div>${percentage}% downloaded</div>
                        `;
                    }
                }, 500);
                
                // Read chunks
                while (true) {
                    const { done, value } = await reader.read();
                    
                    if (done) break;
                    
                    chunks.push(value);
                    receivedBytes += value.length;
                }
                
                // Create final blob
                const blob = new Blob(chunks);
                
                // Final download update
                clearInterval(downloadInterval);
                const downloadEndTime = Date.now();
                const downloadDuration = (downloadEndTime - downloadStartTime) / 1000;
                const averageSpeed = blob.size / downloadDuration;
                
                downloadElement.querySelector('.progress-percentage').textContent = '100%';
                downloadElement.querySelector('.progress-fill').style.width = '100%';
                downloadElement.querySelector('.progress-status').innerHTML = ' Download complete';
                downloadElement.querySelector('.file-size').textContent = `${formatBytes(blob.size)}`;
                downloadElement.querySelector('.progress-speed').textContent = formatSpeed(averageSpeed);
                downloadElement.querySelector('.progress-right-status').textContent = ' Complete';
                downloadElement.querySelector('.progress-right-details').innerHTML = `
                    <div>100% downloaded</div>
                    <div>${formatBytes(blob.size)}</div>
                `;
                
                // Add download completion report
                const completionReportDownload = document.createElement('div');
                completionReportDownload.className = 'completion-report-horizontal';
                completionReportDownload.innerHTML = `
                    <div class="report-line">
                        <span class="report-item"> STARTED ${new Date(downloadStartTime).toLocaleTimeString()}</span>
                        <span class="report-item"> COMPLETED ${new Date(downloadEndTime).toLocaleTimeString()}</span>
                        <span class="report-item"> DURATION ${formatDuration(downloadDuration)}</span>
                        <span class="report-item"> AVERAGE SPEED ${formatSpeed(averageSpeed)}</span>
                    </div>
                    <div class="report-center">
                        <span class="report-size"> Size: ${formatBytes(blob.size)}</span>
                    </div>
                `;
                downloadElement.appendChild(completionReportDownload);
                
                // Trigger download
                const timestamp = new Date().toISOString().slice(0, 19).replace(/:/g, '-');
                const fileName = `videos-${timestamp}.zip`;
                const url = URL.createObjectURL(blob);
                const a = document.createElement('a');
                a.href = url;
                a.download = fileName;
                document.body.appendChild(a);
                a.click();
                document.body.removeChild(a);
                
                // Log ZIP download
                const fileList = videoPaths.map(path => path.split("/").pop()).join(", ");
                logAction(
                    "User downloaded ZIP file: " + fileName,
                    "ZIP contains " + videoPaths.length + " videos | ZIP size: " + (blob.size / 1024 / 1024).toFixed(2) + " MB | Videos: " + fileList,
                    "/api/download-zip",
                    "POST"
                );
                
                // Update download progress header counter for ZIP completion
                const headerElement = document.getElementById('download-progress-header');
                if (headerElement) {
                    headerElement.textContent = ` Downloading Files - Downloaded: 1 | Total files to download: 1...`;
                }
                
                // NOW show footer after download is 100% complete and triggered
                await new Promise(resolve => setTimeout(resolve, 500)); // Brief delay for user to see completion
                const modalFooter = document.getElementById('download-modal-footer');
                const okBtn = document.getElementById('download-ok-btn');
                if (modalFooter && okBtn) {
                    modalFooter.style.display = 'block';
                    okBtn.style.display = 'inline-block';
                    okBtn.textContent = 'Press Ok to close this window';
                }
                
                // Clean up
                setTimeout(() => URL.revokeObjectURL(url), 10000);
                
            } catch (error) {
                console.error('Error creating video ZIP:', error);
                const compressionElement = document.querySelector(`#${progressId}-compression`);
                const downloadElement = document.querySelector(`#${progressId}-download`);
                
                if (compressionElement) {
                    compressionElement.querySelector('.progress-status').innerHTML = ' Failed';
                    compressionElement.querySelector('.progress-right-status').textContent = ' Failed';
                }
                if (downloadElement && downloadElement.style.display !== 'none') {
                    downloadElement.querySelector('.progress-status').innerHTML = ' Failed';
                    downloadElement.querySelector('.progress-right-status').textContent = ' Failed';
                }
                showError(`Failed to create video ZIP archive: ${error.message}`);
            }
        }
        
        // File explorer functions
        
        async function navigateTo(path) {
            currentPath = path;
            updateBreadcrumb(path);
            
            const container = document.getElementById('file-list-container');
            container.innerHTML = '<div class="loading">Loading files...</div>';
            
            try {
                const response = await fetch(`/api/list?path=${encodeURIComponent(path)}`, {
                    headers: window.authHeaders
                });
                
                if (!response.ok) {
                    throw new Error(`HTTP ${response.status}: ${response.statusText}`);
                }
                
                const data = await response.json();
                displayFileList(data.files, path);
                
            } catch (error) {
                container.innerHTML = `<div class="error">Error loading directory: ${error.message}</div>`;
            }
        }
        
        function displayFileList(files, path) {
            const container = document.getElementById('file-list-container');
            
            // Initialize directory cache if not already cached
            if (!directoryCache[path]) {
                directoryCache[path] = files || [];
                console.log('Initialized cache for directory:', path, 'with', files.length, 'files');
            }
            
            if (!files || files.length === 0) {
                container.innerHTML = '<div class="error">No files found in this directory</div>';
                return;
            }
            
            let html = '';
            
            // Add parent directory link if not at root
            if (path !== '/' && path !== '/home/gus') {
                const parentPath = path.substring(0, path.lastIndexOf('/')) || '/';
                html += `
                    <div class="file-item directory" onclick="navigateTo('${parentPath}')">
                        <span class="file-icon"></span>
                        <div class="file-info">
                            <div class="file-name">..</div>
                            <div class="file-meta"></div>
                        </div>
                    </div>
                `;
            }
            
            // Sort files: directories first, then files
            const sortedFiles = files.sort((a, b) => {
                if (a.isDirectory && !b.isDirectory) return -1;
                if (!a.isDirectory && b.isDirectory) return 1;
                return a.name.localeCompare(b.name);
            });
            
            sortedFiles.forEach((file, index) => {
                const icon = file.isDirectory ? '' : getFileIcon(file.name, file.type);
                const itemClass = file.isDirectory ? 'directory' : 'file';
                const fullPath = `${path}/${file.name}`.replace(/\/+/g, '/');
                
                // Check if this is a video file
                const isVideoFile = !file.isDirectory && isVideo(file.name, file.type);
                const thumbnailId = `thumbnail-nav-${index}`;
                
                let onClick = '';
                if (file.isDirectory) {
                    onClick = `onclick="navigateTo('${fullPath}')"`;
                } else {
                    
                }
                
                const displaySize = file.isDirectory ? '' : formatFileSize(file.size);
                const fileActions = file.isDirectory ? '' : `
                    <div class="file-actions">
                        <div class="file-actions-row">
                            <button class="action-btn view" onclick="event.stopPropagation(); viewFile('${fullPath}', '${file.name}')"> View</button>
                            <button class="action-btn download" onclick="event.stopPropagation(); downloadFile('${fullPath}', '${file.name}')"> Download</button>
                        </div>
                        <div class="file-actions-row">
                            <button class="action-btn delete" onclick="event.stopPropagation(); deleteFile('${fullPath}', '${file.name}')"> Delete</button>
                        </div>
                    </div>
                `;
                
                const checkbox = file.isDirectory ? '' : `<input type="checkbox" class="file-checkbox" onclick="event.stopPropagation();" onchange="toggleFileSelection('${fullPath}', this)" data-filename="${file.name}" data-filepath="${fullPath}">`;
                
                // For video files, replace the icon with thumbnail container
                const iconOrThumbnail = isVideoFile ? `
                    <div class="video-thumbnail-container" id="${thumbnailId}"
                         onmouseenter="handleThumbnailHover('${file.name}', '${fullPath}', '${thumbnailId}')"
                         onmouseleave="handleThumbnailLeave('${thumbnailId}')"
                         onclick="event.stopPropagation(); handleThumbnailHover('${file.name}', '${fullPath}', '${thumbnailId}')"
                         style="margin-right: 15px;">
                        <div class="video-thumbnail-placeholder"></div>
                        <div class="video-thumbnail-loading" style="display: none;">Loading...</div>
                        <video class="video-thumbnail" muted></video>
                    </div>
                ` : `<span class="file-icon">${icon}</span>`;
                
                html += `
                    <div class="file-item ${itemClass}" ${onClick}>
                        ${checkbox}
                        ${iconOrThumbnail}
                        <div class="file-info">
                            <div class="file-name" ${isVideoFile ? `onmouseenter="handleThumbnailHover('${file.name}', '${fullPath}', '${thumbnailId}')" onmouseleave="handleThumbnailLeave('${thumbnailId}')" onclick="event.stopPropagation(); handleThumbnailHover('${file.name}', '${fullPath}', '${thumbnailId}')" style="cursor: pointer;"` : ''}>${file.name}</div>
                            <div class="file-meta">${displaySize}</div>
                        </div>
                        ${fileActions}
                    </div>
                `;
            });
            
            container.innerHTML = html;
            
            // Show/hide selection controls based on whether there are files
            const hasFiles = files.some(f => !f.isDirectory);
            const selectionControls = document.querySelector('.file-selection-controls');
            if (selectionControls) {
                selectionControls.style.display = hasFiles ? 'block' : 'none';
            }
            
            // Clear previous selections
            selectedFiles.clear();
            updateFileSelectionCount();
        }
        
        // File selection management
        const selectedFiles = new Set();
        
        function toggleFileSelection(filePath, checkbox) {
            if (checkbox.checked) {
                selectedFiles.add(filePath);
            } else {
                    
                selectedFiles.delete(filePath);
            }
            updateFileSelectionCount();
        }
        
        function updateFileSelectionCount() {
            const count = selectedFiles.size;
            const countElement = document.getElementById('file-selection-count');
            const deleteButton = document.querySelector('.delete-selected-btn');
            
            if (countElement) {
                countElement.textContent = `${count} file${count !== 1 ? 's' : ''} selected`;
            }
            
            if (deleteButton) {
                deleteButton.disabled = count === 0;
            }
        }
        
        function selectAllFiles() {
            const checkboxes = document.querySelectorAll('.file-checkbox');
            checkboxes.forEach(checkbox => {
                checkbox.checked = true;
                const filePath = checkbox.getAttribute('onchange').match(/'([^']+)'/)[1];
                selectedFiles.add(filePath);
            });
            updateFileSelectionCount();
        }
        
        function clearFileSelection() {
            const checkboxes = document.querySelectorAll('.file-checkbox');
            checkboxes.forEach(checkbox => {
                checkbox.checked = false;
            });
            selectedFiles.clear();
            updateFileSelectionCount();
        }
        
        async function deleteSelectedFiles() {
            if (selectedFiles.size === 0) return;
            
            // Check for critical system files in selection
            const criticalFiles = Array.from(selectedFiles).filter(isCriticalSystemFile);
            if (criticalFiles.length > 0) {
                const criticalFileNames = criticalFiles.map(path => path.split('/').pop());
                showCriticalFileWarning(`${criticalFiles.length} critical system file(s): ${criticalFileNames.join(', ')}`);
                return;
            }
            
            const fileNames = Array.from(selectedFiles).map(path => path.split('/').pop());
            const filePaths = Array.from(selectedFiles);
            const confirmed = await showConfirmationModal(
                'Delete Multiple Files',
                `Are you sure you want to delete ${selectedFiles.size} selected file(s)?`,
                fileNames,
                filePaths
            );
            
            if (!confirmed) return;
            
            let successCount = 0;
            let failCount = 0;
            const totalFiles = selectedFiles.size;
            
            for (const filePath of selectedFiles) {
                try {
                
                // Log each file deletion in batch
                console.log("DEBUG: About to log batch file deletion for:", filePath);
                logAction(
                    "User deleted file: " + filePath.substring(filePath.lastIndexOf("/") + 1),
                    "Full path: " + filePath + " | Batch: " + (Array.from(selectedFiles).indexOf(filePath) + 1) + "/" + totalFiles,
                    "/api/delete-file",
                    "POST"
                );
                    const response = await fetch('/api/delete-file', {
                        method: 'POST',
                        headers: {
                            'Content-Type': 'application/json',
                            ...window.authHeaders
                        },
                        body: JSON.stringify({
                            path: filePath
                        })
                    });
                    
                    if (response.ok) {
                        successCount++;
                    } else {
                    
                        failCount++;
                    }
                } catch (error) {
                    failCount++;
                }
            }
            
            // Refresh the directory and clear selections first
            selectedFiles.clear();
            await navigateTo(currentPath);
            
            // Show appropriate modal based on results
            if (successCount > 0 && failCount === 0) {
                // All files deleted successfully
                showSuccessModal(
                    'Files Deleted Successfully',
                    `All ${successCount} selected file(s) have been permanently deleted.`,
                    fileNames,
                    successCount
                );
            } else if (successCount > 0 && failCount > 0) {
                // Partial success
                showSuccessModal(
                    'Deletion Partially Completed',
                    `${successCount} file(s) deleted successfully, ${failCount} file(s) failed.`,
                    fileNames,
                    successCount
                );
            } else if (failCount > 0) {
                // All failed
                showErrorModal('Deletion Failed', `Failed to delete ${failCount} file(s). Please check file permissions or if files are in use.`);
            }
        }
        
        function updateBreadcrumb(path) {
            const breadcrumbSegments = document.getElementById('breadcrumb-segments');
            
            if (!breadcrumbSegments) return;
            
            // Clear existing segments except root
            breadcrumbSegments.innerHTML = '<span class="breadcrumb-segment" onclick="navigateTo(\'/\')" style="background: #475569; color: white; padding: 4px 8px; border-radius: 4px; cursor: pointer; font-size: 13px; font-family: monospace;">/</span>';
            
            if (path === '/' || path === '') {
                return;
            }
            
            const parts = path.split('/').filter(part => part !== '');
            let currentPath = '';
            
            parts.forEach((part, index) => {
                currentPath += '/' + part;
                const isLast = index === parts.length - 1;
                
                const segmentStyle = isLast ? 
                    'background: #28a745; color: white; padding: 4px 8px; border-radius: 4px; cursor: pointer; font-size: 13px; font-family: monospace;' :
                    'background: #475569; color: white; padding: 4px 8px; border-radius: 4px; cursor: pointer; font-size: 13px; font-family: monospace;';
                
                breadcrumbSegments.innerHTML += `<span class="breadcrumb-segment" onclick="navigateTo('${currentPath}')" style="${segmentStyle}">${part}</span>`;
            });
        }
        
        function navigateUp() {
            if (currentPath === '/' || !currentPath) return;
            
            const parentPath = currentPath.split('/').slice(0, -1).join('/') || '/';
            navigateTo(parentPath);
        }
        
        function isVideo(filename, mimeType) {
            // Check by MIME type first
            if (mimeType && mimeType.startsWith('video/')) return true;
            
            // Check by file extension
            const extension = filename.split('.').pop()?.toLowerCase();
            const videoExtensions = ['mp4', 'webm', 'ogg', 'avi', 'mov', 'mkv', 'flv', 'm4v', 'wmv', '3gp', 'mpg', 'mpeg'];
            return videoExtensions.includes(extension);
        }

        function getFileIcon(filename, mimeType) {
            const extension = filename.split('.').pop()?.toLowerCase();
            
            if (mimeType && mimeType.startsWith('video/')) return '';
            if (mimeType && mimeType.startsWith('image/')) return '';
            if (mimeType && mimeType.startsWith('audio/')) return '';
            if (mimeType && mimeType.startsWith('text/')) return '';
            
            switch (extension) {
                case 'pdf': return '';
                case 'doc':
                case 'docx': return '';
                case 'xls':
                case 'xlsx': return '';
                case 'ppt':
                case 'pptx': return '';
                case 'zip':
                case 'tar':
                case 'gz': return '';
                case 'py': return '';
                case 'js': return '';
                case 'html':
                case 'css': return '';
                default: return '';
            }
        }
        
        function formatFileSize(sizeString) {
            // If it's already a formatted string, parse it back to bytes for consistent formatting
            if (!sizeString || sizeString === 'Directory') return '';
            
            // If it's already properly formatted (contains units), return as is
            if (sizeString.includes('B') || sizeString.includes('KB') || sizeString.includes('MB') || sizeString.includes('GB')) {
                // Clean up any inconsistent formatting
                return sizeString.replace(/\s+/g, ' ').trim();
            }
            
            // If it's a number, format it properly
            const bytes = parseInt(sizeString);
            if (isNaN(bytes)) return sizeString;
            
            if (bytes < 1024) return `${bytes} B`;
            if (bytes < 1024 * 1024) return `${(bytes / 1024).toFixed(1)} KB`;
            if (bytes < 1024 * 1024 * 1024) return `${(bytes / (1024 * 1024)).toFixed(1)} MB`;
            return `${(bytes / (1024 * 1024 * 1024)).toFixed(1)} GB`;
        }
        
        function handleFileAction(filePath, fileName) {
            const extension = fileName.split('.').pop()?.toLowerCase();
            
            if (['mp4', 'webm', 'ogg', 'avi', 'mov', 'mkv', 'flv'].includes(extension)) {
                playVideoFromLibrary(fileName, filePath);
            } else {
                    
                viewFile(filePath, fileName);
            }
        }
        
        async function viewFile(filePath, fileName) {
            try {
                const extension = fileName.split('.').pop()?.toLowerCase();
                let endpoint = '/api/view';
                
                // Use appropriate endpoint based on file type
                if (['txt', 'md', 'py', 'js', 'html', 'css', 'json', 'xml', 'csv', 'log'].includes(extension)) {
                    endpoint = '/api/file';
                }
                
                const response = await fetch(`${endpoint}?path=${encodeURIComponent(filePath)}`, {
                    headers: window.authHeaders
                });
                
                if (!response.ok) {
                    throw new Error(`HTTP ${response.status}: ${response.statusText}`);
                }
                
                // For text files, show content in a new window
                if (endpoint === '/api/file') {
                    const content = await response.text();
                    const newWindow = window.open('', '_blank');
                    newWindow.document.write(`
                        <html>
                        <head><title>${fileName}</title>
                        <style>
                            body { font-family: monospace; padding: 20px; background: #1a1a1a; color: #fff; }
                            pre { white-space: pre-wrap; word-wrap: break-word; }
                        </style>
                        </head>
                        <body><pre>${content.replace(/</g, '&lt;').replace(/>/g, '&gt;')}</pre></body>
                        </html>
                    `);
                } else {
                    
                    // For images and other viewable files, create blob URL
                    const blob = await response.blob();
                    const url = URL.createObjectURL(blob);
                    window.open(url, '_blank');
                    
                    // Clean up after a delay
                    setTimeout(() => URL.revokeObjectURL(url), 10000);
                }
                
            } catch (error) {
                showErrorModal('File View Failed', `Unable to view "${fileName}": ${error.message}`);
            }
        }
        
        async function downloadFile(filePath, fileName) {
            // Show individual download modal
            const modal = document.getElementById('individual-download-modal');
            const progressContainer = document.getElementById('individual-download-progress-container');
            const modalFooter = document.getElementById('individual-download-modal-footer');
            const okBtn = document.getElementById('individual-download-ok-btn');

            modal.style.display = 'block';
            modalFooter.style.display = 'none';
            okBtn.style.display = 'none';

            // Clear and prepare progress container
            progressContainer.innerHTML = '<h3> Downloading File...</h3>';

            try {
                // Create unique progress ID
                const progressId = `progress-${Date.now()}`;
                
                // Create progress HTML
                const progressHtml = `
                    <div style="margin: 15px 0; padding: 15px; background: rgba(0,0,0,0.3); border-radius: 10px;">
                        <div style="display: flex; justify-content: space-between; margin-bottom: 10px;">
                            <span>${fileName}</span>
                            <span id="status-${progressId}"> Preparing...</span>
                        </div>
                        <div style="display: flex; justify-content: space-between; margin-bottom: 10px; font-size: 0.9em; color: white;">
                            <span id="percentage-${progressId}">0%</span>
                            <span id="speed-${progressId}">--</span>
                        </div>
                        <div style="display: flex; justify-content: space-between; margin-bottom: 20px; font-size: 0.85em; color: white;">
                            <span id="data-size-${progressId}">0 B / Calculating...</span>
                            <span id="time-remaining-${progressId}">--</span>
                        </div>
                        <div style="width: 100%; background: rgba(0,0,0,0.3); border-radius: 5px; overflow: hidden;">
                            <div id="bar-${progressId}" style="height: 10px; background: linear-gradient(90deg, #17a2b8, #28a745); width: 0%; transition: none;"></div>
                        </div>
                        <div id="report-${progressId}" style="margin-top: 15px; padding: 12px; background: rgba(0,0,0,0.6); border-radius: 8px; display: none;">
                            <!-- Detailed completion report -->
                        </div>
                    </div>
                `;
                progressContainer.innerHTML += progressHtml;

                // Get DOM elements for progress updates
                const statusElement = document.getElementById(`status-${progressId}`);
                const percentageElement = document.getElementById(`percentage-${progressId}`);
                const speedElement = document.getElementById(`speed-${progressId}`);
                const dataSizeElement = document.getElementById(`data-size-${progressId}`);
                const timeRemainingElement = document.getElementById(`time-remaining-${progressId}`);
                const barElement = document.getElementById(`bar-${progressId}`);
                const reportElement = document.getElementById(`report-${progressId}`);

                // Start download
                statusElement.textContent = ' Downloading...';
                
                const response = await fetch(`/api/download?path=${encodeURIComponent(filePath)}`, {
                    headers: window.authHeaders
                });
                
                if (!response.ok) {
                    throw new Error(`HTTP ${response.status}: ${response.statusText}`);
                }

                // Get file size
                const contentLength = response.headers.get('Content-Length');
                const fileSize = contentLength ? parseInt(contentLength, 10) : 0;
                const fileSizeText = fileSize > 1024*1024 ? 
                    `${(fileSize/1024/1024).toFixed(1)} MB` : 
                    `${(fileSize/1024).toFixed(1)} KB`;

                // Update file size display
                dataSizeElement.textContent = `0 B / ${fileSizeText}`;

                // Track progress
                let downloadedBytes = 0;
                const startTime = Date.now();
                const reader = response.body.getReader();
                const chunks = [];

                // Update progress every 300ms
                const progressInterval = setInterval(() => {
                    if (fileSize > 0) {
                        const percentage = Math.min(100, (downloadedBytes / fileSize) * 100);
                        const downloadedText = downloadedBytes > 1024*1024 ? 
                            `${(downloadedBytes/1024/1024).toFixed(1)} MB` : 
                            `${(downloadedBytes/1024).toFixed(1)} KB`;
                        
                        // Calculate speed
                        const elapsedTime = (Date.now() - startTime) / 1000;
                        const speed = elapsedTime > 0 ? downloadedBytes / elapsedTime : 0;
                        const speedText = speed > 1024*1024 ? 
                            `${(speed/1024/1024).toFixed(1)} MB/s` : 
                            `${(speed/1024).toFixed(1)} KB/s`;
                        
                        // Calculate time remaining
                        const remainingBytes = fileSize - downloadedBytes;
                        const timeRemaining = speed > 0 ? remainingBytes / speed : 0;
                        const timeText = timeRemaining > 60 ? 
                            `${Math.floor(timeRemaining/60)}m ${Math.floor(timeRemaining%60)}s` : 
                            `${Math.floor(timeRemaining)}s`;

                        barElement.style.width = `${percentage}%`;
                        percentageElement.textContent = `${Math.floor(percentage)}%`;
                        dataSizeElement.textContent = `${downloadedText} / ${fileSizeText}`;
                        speedElement.textContent = speedText;
                        timeRemainingElement.textContent = timeText;
                    }
                }, 300);

                // Stream download
                try {
                    while (true) {
                        const { done, value } = await reader.read();
                        if (done) break;
                        chunks.push(value);
                        downloadedBytes += value.length;
                    }
                } finally {
                    clearInterval(progressInterval);
                }

                // Complete the progress bar
                barElement.style.width = '100%';
                percentageElement.textContent = '100%';
                statusElement.textContent = ' Complete';

                // Create blob and download
                const blob = new Blob(chunks);
                const url = URL.createObjectURL(blob);
                
                // Create download link
                const a = document.createElement('a');
                a.style.display = 'none';
                a.href = url;
                a.download = fileName;
                
                document.body.appendChild(a);
                a.click();
                document.body.removeChild(a);
                
                // Clean up
                setTimeout(() => URL.revokeObjectURL(url), 10000);

                // Show completion report
                const endTime = Date.now();
                const totalTime = (endTime - startTime) / 1000;
                const avgSpeed = totalTime > 0 ? downloadedBytes / totalTime : 0;
                const avgSpeedText = avgSpeed > 1024*1024 ? 
                    `${(avgSpeed/1024/1024).toFixed(1)} MB/s` : 
                    `${(avgSpeed/1024).toFixed(1)} KB/s`;

                reportElement.innerHTML = `
                    <div style="color: #00ff00; font-weight: bold; margin-bottom: 8px;"> Download Successful</div>
                    <div style="font-size: 0.85em; color: #ccc;">
                        File: ${fileName}<br>
                        Size: ${fileSizeText}<br>
                        Time: ${totalTime.toFixed(1)}s<br>
                        Average Speed: ${avgSpeedText}
                    </div>
                `;
                reportElement.style.display = 'block';

                // Log individual file download
                logAction(
                    "User downloaded file: " + fileName,
                    "File size: " + (blob.size / 1024 / 1024).toFixed(2) + " MB  |  Path: " + filePath,
                    "/api/download",
                    "GET"
                );

                // Show footer with close button
                modalFooter.style.display = 'block';
                okBtn.style.display = 'block';
                okBtn.textContent = 'Press Ok to close this window';
                
            } catch (error) {
                // Show error in modal
                const statusElement = document.getElementById(`status-${Date.now()}`);
                if (statusElement) {
                    statusElement.textContent = ' Failed';
                }
                
                progressContainer.innerHTML += `
                    <div style="margin: 15px 0; padding: 15px; background: rgba(255,0,0,0.1); border: 1px solid #dc3545; border-radius: 10px;">
                        <div style="color: #dc3545; font-weight: bold;"> Download Failed</div>
                        <div style="color: #ccc; margin-top: 8px;">Error: ${error.message}</div>
                    </div>
                `;

                modalFooter.style.display = 'block';
                okBtn.style.display = 'block';
                okBtn.textContent = 'Press Ok to close this window';
            }
        }
        
        // Data Navigator Download Functions
        function downloadSelectedFiles() {
            const checkboxes = document.querySelectorAll('.file-checkbox:checked');
            if (checkboxes.length === 0) {
                showError('No files selected for download.');
                return;
            }
            
            const selectedFiles = [];
            checkboxes.forEach(cb => {
                const filePath = cb.getAttribute('data-filepath') || extractFilePathFromCheckbox(cb);
                const fileName = cb.getAttribute('data-filename') || getFileNameFromPath(filePath);
                selectedFiles.push({ name: fileName, path: filePath });
            });
            
            // Show download modal
            const modal = document.getElementById('download-modal');
            const progressContainer = document.getElementById('download-modal-progress-container');
            const modalFooter = document.getElementById('download-modal-footer');
            
            modal.style.display = 'block';
            modalFooter.style.display = 'none';
            progressContainer.innerHTML = '<div class="downloading-header"> Downloading Files...</div>';
            
            downloadFilesIndividually(selectedFiles);
        }
        
        function downloadAllFiles() {
            // Get all files in current directory
            const fileCheckboxes = document.querySelectorAll('.file-checkbox');
            if (fileCheckboxes.length === 0) {
                showError('No files available for download.');
                return;
            }
            
            const allFiles = [];
            fileCheckboxes.forEach(cb => {
                const filePath = cb.getAttribute('data-filepath') || extractFilePathFromCheckbox(cb);
                const fileName = cb.getAttribute('data-filename') || getFileNameFromPath(filePath);
                allFiles.push({ name: fileName, path: filePath });
            });
            
            // Show download modal
            const modal = document.getElementById('download-modal');
            const progressContainer = document.getElementById('download-modal-progress-container');
            const modalFooter = document.getElementById('download-modal-footer');
            
            modal.style.display = 'block';
            modalFooter.style.display = 'none';
            progressContainer.innerHTML = '<div class="downloading-header"> Downloading All Files...</div>';
            
            downloadFilesIndividually(allFiles);
        }
        
        function downloadFilesAsZip() {
            const checkboxes = document.querySelectorAll('.file-checkbox:checked');
            if (checkboxes.length === 0) {
                showError('No files selected for ZIP download.');
                return;
            }
            
            const selectedFiles = [];
            checkboxes.forEach(cb => {
                const filePath = cb.getAttribute('data-filepath') || extractFilePathFromCheckbox(cb);
                selectedFiles.push(filePath);
            });
            
            // Show download modal
            const modal = document.getElementById('download-modal');
            const progressContainer = document.getElementById('download-modal-progress-container');
            const modalFooter = document.getElementById('download-modal-footer');
            
            modal.style.display = 'block';
            modalFooter.style.display = 'none';
            progressContainer.innerHTML = '<div class="downloading-header"> Creating ZIP Archive...</div>';
            
            // Create ZIP download
            downloadFilesAsZipArchive(selectedFiles);
        }
        
        async function downloadFilesIndividually(files) {
            const progressContainer = document.getElementById('download-modal-progress-container');
            let completedCount = 0;
            
            for (let i = 0; i < files.length; i++) {
                const file = files[i];
                const progressId = `progress-${Date.now()}-${i}`;
                
                await downloadSingleFileWithProgress(file, progressId, progressContainer);
                completedCount++;
            }
            
            // Show completion
            const modalFooter = document.getElementById('download-modal-footer');
            const okBtn = document.getElementById('download-ok-btn');
            if (modalFooter && okBtn) {
                modalFooter.style.display = 'block';
                okBtn.style.display = 'inline-block';
                okBtn.textContent = 'Press Ok to close this window';
            }
        }
        
        async function downloadSingleFileWithProgress(file, progressId, progressContainer) {
            // Add progress item with advanced UI like video downloads
            progressContainer.innerHTML += `
                <div id="${progressId}" class="progress-item">
                    <div class="progress-header">
                        <span class="file-name">${file.name}</span>
                        <span class="progress-status"> Preparing...</span>
                    </div>
                    <div class="progress-details">
                        <span class="progress-percentage">0%</span>
                        <span class="progress-speed"></span>
                        <span class="file-size"></span>
                    </div>
                    <div class="progress-bar">
                        <div class="progress-fill" style="width: 0%"></div>
                    </div>
                    <div class="progress-right">
                        <div class="progress-right-status"> Downloading...</div>
                        <div class="progress-right-details">
                            <div>Receiving...</div>
                            <div>Estimating...</div>
                        </div>
                    </div>
                </div>
            `;
            
            try {
                // Start download with streaming for real-time progress
                const response = await fetch(`/api/download?path=${encodeURIComponent(file.path)}`, {
                    headers: window.authHeaders
                });
                
                if (!response.ok) {
                    throw new Error(`Failed to download ${file.name}`);
                }
                
                const contentLength = response.headers.get('Content-Length');
                const totalBytes = contentLength ? parseInt(contentLength) : 0;
                
                // Update status
                document.querySelector(`#${progressId} .progress-status`).innerHTML = ' Downloading...';
                
                const reader = response.body.getReader();
                const chunks = [];
                let receivedBytes = 0;
                const startTime = Date.now();
                
                // Create progress tracking interval
                const progressInterval = setInterval(() => {
                    const elapsed = (Date.now() - startTime) / 1000;
                    const speed = receivedBytes / elapsed;
                    const percentage = totalBytes > 0 ? Math.round((receivedBytes / totalBytes) * 100) : 0;
                    
                    // Update progress UI
                    const progressElement = document.querySelector(`#${progressId}`);
                    if (progressElement) {
                        progressElement.querySelector('.progress-percentage').textContent = `${percentage}%`;
                        progressElement.querySelector('.progress-fill').style.width = `${percentage}%`;
                        progressElement.querySelector('.progress-speed').textContent = formatSpeed(speed);
                        
                        if (totalBytes > 0) {
                            progressElement.querySelector('.file-size').textContent = 
                                `${formatBytes(receivedBytes)} / ${formatBytes(totalBytes)}`;
                        } else {
                            progressElement.querySelector('.file-size').textContent = formatBytes(receivedBytes);
                        }
                        
                        // Update right-side status
                        const rightStatus = progressElement.querySelector('.progress-right-status');
                        const rightDetails = progressElement.querySelector('.progress-right-details');
                        if (rightStatus && rightDetails) {
                            rightStatus.textContent = ' Downloading...';
                            rightDetails.innerHTML = `
                                <div>Receiving...</div>
                                <div>Estimating...</div>
                            `;
                        }
                    }
                }, 500);
                
                // Read chunks
                while (true) {
                    const { done, value } = await reader.read();
                    
                    if (done) break;
                    
                    chunks.push(value);
                    receivedBytes += value.length;
                }
                
                // Clear progress interval
                clearInterval(progressInterval);
                
                // Create blob and download
                const blob = new Blob(chunks);
                const url = URL.createObjectURL(blob);
                
                const endTime = Date.now();
                const duration = (endTime - startTime) / 1000;
                const averageSpeed = receivedBytes / duration;
                
                // Update to completion with detailed report
                const progressElement = document.querySelector(`#${progressId}`);
                if (progressElement) {
                    progressElement.querySelector('.progress-percentage').textContent = '100%';
                    progressElement.querySelector('.progress-fill').style.width = '100%';
                    progressElement.querySelector('.progress-status').innerHTML = ' Complete';
                    progressElement.querySelector('.file-size').textContent = `${formatBytes(blob.size)}`;
                    progressElement.querySelector('.progress-speed').textContent = formatSpeed(averageSpeed);
                    
                    // Add completion report with horizontal layout
                    const completionReport = document.createElement('div');
                    completionReport.className = 'completion-report-horizontal';
                    completionReport.innerHTML = `
                        <div class="report-line">
                            <span class="report-item"> STARTED ${new Date(startTime).toLocaleTimeString()}</span>
                            <span class="report-item"> COMPLETED ${new Date(endTime).toLocaleTimeString()}</span>
                            <span class="report-item"> DURATION ${formatDuration(duration)}</span>
                            <span class="report-item"> AVERAGE SPEED ${formatSpeed(averageSpeed)}</span>
                        </div>
                        <div class="report-center">
                            <span class="report-size"> Size: ${formatBytes(blob.size)}</span>
                        </div>
                    `;
                    progressElement.appendChild(completionReport);
                    
                    // Update right-side status to complete
                    const rightStatus = progressElement.querySelector('.progress-right-status');
                    const rightDetails = progressElement.querySelector('.progress-right-details');
                    if (rightStatus && rightDetails) {
                        rightStatus.textContent = ' Complete';
                        rightDetails.innerHTML = `
                            <div>Complete</div>
                            <div>${formatSpeed(averageSpeed)}</div>
                        `;
                    }
                }
                
                // Trigger download
                const a = document.createElement('a');
                a.href = url;
                a.download = file.name;
                document.body.appendChild(a);
                a.click();
                document.body.removeChild(a);
                
                // Clean up
                setTimeout(() => URL.revokeObjectURL(url), 10000);
                
            } catch (error) {
                console.error(`Error downloading ${file.name}:`, error);
                const progressElement = document.querySelector(`#${progressId}`);
                if (progressElement) {
                    progressElement.querySelector('.progress-status').innerHTML = ' Failed';
                    progressElement.querySelector('.progress-right-status').textContent = ' Failed';
                }
                showError(`Failed to download ${file.name}`);
            }
        }
        
        async function downloadFilesAsZipArchive(filePaths) {
            const progressContainer = document.getElementById('download-modal-progress-container');
            const progressId = `zip-progress-${Date.now()}`;
            
            // Add ZIP Compression progress item
            progressContainer.innerHTML += `
                <div id="${progressId}-compression" class="progress-item">
                    <div class="progress-header">
                        <span class="file-name"> Compressing ${filePaths.length} files to archive</span>
                        <span class="progress-status"> Starting compression...</span>
                    </div>
                    <div class="progress-details">
                        <span class="progress-percentage">0%</span>
                        <span class="progress-speed"></span>
                        <span class="file-size">Processing files...</span>
                    </div>
                    <div class="progress-bar">
                        <div class="progress-fill" style="width: 0%"></div>
                    </div>
                    <div class="progress-right">
                        <div class="progress-right-status"> Compressing...</div>
                        <div class="progress-right-details">
                            <div>Files: ${filePaths.length}</div>
                            <div>Processing...</div>
                        </div>
                    </div>
                </div>
            `;
            
            // Add ZIP Download progress item (initially hidden)
            progressContainer.innerHTML += `
                <div id="${progressId}-download" class="progress-item" style="display: none;">
                    <div class="progress-header">
                        <span class="file-name"> Downloading ZIP archive</span>
                        <span class="progress-status"> Preparing download...</span>
                    </div>
                    <div class="progress-details">
                        <span class="progress-percentage">0%</span>
                        <span class="progress-speed"></span>
                        <span class="file-size"></span>
                    </div>
                    <div class="progress-bar">
                        <div class="progress-fill" style="width: 0%"></div>
                    </div>
                    <div class="progress-right">
                        <div class="progress-right-status"> Downloading...</div>
                        <div class="progress-right-details">
                            <div>Receiving...</div>
                            <div>Estimating...</div>
                        </div>
                    </div>
                </div>
            `;
            
            try {
                const startTime = Date.now();
                
                // Phase 1: Compression progress (0-100%)
                const compressionElement = document.querySelector(`#${progressId}-compression`);
                compressionElement.querySelector('.progress-status').innerHTML = ' Compressing files...';
                compressionElement.querySelector('.progress-right-status').textContent = ' Creating archive...';
                
                // Simulate realistic compression progress
                let compressionProgress = 0;
                const compressionInterval = setInterval(() => {
                    compressionProgress += Math.random() * 12 + 3; // 3-15% increments
                    if (compressionProgress > 100) compressionProgress = 100;
                    
                    if (compressionElement) {
                        compressionElement.querySelector('.progress-percentage').textContent = `${Math.round(compressionProgress)}%`;
                        compressionElement.querySelector('.progress-fill').style.width = `${compressionProgress}%`;
                        compressionElement.querySelector('.file-size').textContent = `Processing ${filePaths.length} files...`;
                        compressionElement.querySelector('.progress-right-details').innerHTML = `
                            <div>Files: ${filePaths.length}</div>
                            <div>${Math.round(compressionProgress)}% compressed</div>
                        `;
                        
                        if (compressionProgress >= 100) {
                            clearInterval(compressionInterval);
                            compressionElement.querySelector('.progress-status').innerHTML = ' Compression complete';
                            compressionElement.querySelector('.progress-right-status').textContent = ' Archive created';
                            compressionElement.querySelector('.progress-right-details').innerHTML = `
                                <div>Files: ${filePaths.length}</div>
                                <div>100% compressed</div>
                            `;
                            
                            // Add waiting message IMMEDIATELY when compression hits 100%
                            setTimeout(() => {
                                const waitingMessage = document.createElement('div');
                                waitingMessage.className = 'waiting-message';
                                waitingMessage.style.cssText = 'margin: 15px 0; padding: 12px; background: rgba(255, 193, 7, 0.1); border: 1px solid #ffc107; border-radius: 8px; text-align: center; color: #ffc107; font-weight: 500;';
                                waitingMessage.innerHTML = ' Waiting for Zip file to be downloaded...';
                                compressionElement.appendChild(waitingMessage);
                            }, 300);
                        }
                    }
                }, 300);
                
                // Start ZIP creation
                const response = await fetch('/api/download-files-zip', {
                    method: 'POST',
                    headers: {
                        'Content-Type': 'application/json',
                        ...window.authHeaders
                    },
                    body: JSON.stringify({ files: filePaths })
                });
                
                // Wait for compression to complete
                while (compressionProgress < 100) {
                    await new Promise(resolve => setTimeout(resolve, 100));
                }
                
                // Add compression completion report
                const compressionEndTime = Date.now();
                const compressionDuration = (compressionEndTime - startTime) / 1000;
                const completionReportCompression = document.createElement('div');
                completionReportCompression.className = 'completion-report-horizontal';
                completionReportCompression.innerHTML = `
                    <div class="report-line">
                        <span class="report-item"> STARTED ${new Date(startTime).toLocaleTimeString()}</span>
                        <span class="report-item"> COMPLETED ${new Date(compressionEndTime).toLocaleTimeString()}</span>
                        <span class="report-item"> DURATION ${formatDuration(compressionDuration)}</span>
                        <span class="report-item"> FILES COMPRESSED ${filePaths.length}</span>
                    </div>
                `;
                compressionElement.appendChild(completionReportCompression);
                
                // Show download progress item (waiting message already added when compression hit 100%)
                const downloadElement = document.querySelector(`#${progressId}-download`);
                downloadElement.style.display = 'block';
                
                if (!response.ok) {
                    const errorText = await response.text();
                    throw new Error(`Failed to create ZIP archive: ${response.status} ${errorText}`);
                }
                
                // Phase 2: Download with streaming progress (separate 0-100%)
                const contentLength = response.headers.get('Content-Length');
                const totalBytes = contentLength ? parseInt(contentLength) : 0;
                
                downloadElement.querySelector('.progress-status').innerHTML = ' Downloading ZIP...';
                downloadElement.querySelector('.progress-right-status').textContent = ' Receiving data...';
                
                const reader = response.body.getReader();
                const chunks = [];
                let receivedBytes = 0;
                const downloadStartTime = Date.now();
                
                // Real-time download progress (0-100% for download only)
                const downloadInterval = setInterval(() => {
                    const elapsed = (Date.now() - downloadStartTime) / 1000;
                    const speed = receivedBytes / elapsed;
                    const percentage = totalBytes > 0 ? Math.round((receivedBytes / totalBytes) * 100) : 0;
                    
                    if (downloadElement) {
                        downloadElement.querySelector('.progress-percentage').textContent = `${percentage}%`;
                        downloadElement.querySelector('.progress-fill').style.width = `${percentage}%`;
                        downloadElement.querySelector('.progress-speed').textContent = formatSpeed(speed);
                        
                        if (totalBytes > 0) {
                            downloadElement.querySelector('.file-size').textContent = 
                                `${formatBytes(receivedBytes)} / ${formatBytes(totalBytes)}`;
                        } else {
                            downloadElement.querySelector('.file-size').textContent = formatBytes(receivedBytes);
                        }
                        
                        downloadElement.querySelector('.progress-right-details').innerHTML = `
                            <div>Receiving...</div>
                            <div>${percentage}% downloaded</div>
                        `;
                    }
                }, 500);
                
                // Read chunks
                while (true) {
                    const { done, value } = await reader.read();
                    
                    if (done) break;
                    
                    chunks.push(value);
                    receivedBytes += value.length;
                }
                
                // Create final blob
                const blob = new Blob(chunks);
                
                // Final download update
                clearInterval(downloadInterval);
                const downloadEndTime = Date.now();
                const downloadDuration = (downloadEndTime - downloadStartTime) / 1000;
                const averageSpeed = blob.size / downloadDuration;
                
                downloadElement.querySelector('.progress-percentage').textContent = '100%';
                downloadElement.querySelector('.progress-fill').style.width = '100%';
                downloadElement.querySelector('.progress-status').innerHTML = ' Download complete';
                downloadElement.querySelector('.file-size').textContent = `${formatBytes(blob.size)}`;
                downloadElement.querySelector('.progress-speed').textContent = formatSpeed(averageSpeed);
                downloadElement.querySelector('.progress-right-status').textContent = ' Complete';
                downloadElement.querySelector('.progress-right-details').innerHTML = `
                    <div>100% downloaded</div>
                    <div>${formatBytes(blob.size)}</div>
                `;
                
                // Add download completion report
                const completionReportDownload = document.createElement('div');
                completionReportDownload.className = 'completion-report-horizontal';
                completionReportDownload.innerHTML = `
                    <div class="report-line">
                        <span class="report-item"> STARTED ${new Date(downloadStartTime).toLocaleTimeString()}</span>
                        <span class="report-item"> COMPLETED ${new Date(downloadEndTime).toLocaleTimeString()}</span>
                        <span class="report-item"> DURATION ${formatDuration(downloadDuration)}</span>
                        <span class="report-item"> AVERAGE SPEED ${formatSpeed(averageSpeed)}</span>
                    </div>
                    <div class="report-center">
                        <span class="report-size"> Size: ${formatBytes(blob.size)}</span>
                    </div>
                `;
                downloadElement.appendChild(completionReportDownload);
                
                // Trigger download
                const url = URL.createObjectURL(blob);
                const a = document.createElement('a');
                a.href = url;
                a.download = `files_${new Date().toISOString().slice(0, 19).replace(/[:-]/g, '')}.zip`;
                document.body.appendChild(a);
                a.click();
                document.body.removeChild(a);
                
                // NOW show footer after download is 100% complete and triggered
                await new Promise(resolve => setTimeout(resolve, 500)); // Brief delay for user to see completion
                const modalFooter = document.getElementById('download-modal-footer');
                const okBtn = document.getElementById('download-ok-btn');
                if (modalFooter && okBtn) {
                    modalFooter.style.display = 'block';
                    okBtn.style.display = 'inline-block';
                    okBtn.textContent = 'Press Ok to close this window';
                }
                
                // Clean up
                setTimeout(() => URL.revokeObjectURL(url), 10000);
                
            } catch (error) {
                console.error('Error creating ZIP:', error);
                const compressionElement = document.querySelector(`#${progressId}-compression`);
                const downloadElement = document.querySelector(`#${progressId}-download`);
                
                if (compressionElement) {
                    compressionElement.querySelector('.progress-status').innerHTML = ' Failed';
                    compressionElement.querySelector('.progress-right-status').textContent = ' Failed';
                }
                if (downloadElement && downloadElement.style.display !== 'none') {
                    downloadElement.querySelector('.progress-status').innerHTML = ' Failed';
                    downloadElement.querySelector('.progress-right-status').textContent = ' Failed';
                }
                showError(`Failed to create ZIP archive: ${error.message}`);
                
                // Show footer on error too
                const modalFooter = document.getElementById('download-modal-footer');
                const okBtn = document.getElementById('download-ok-btn');
                if (modalFooter && okBtn) {
                    modalFooter.style.display = 'block';
                    okBtn.style.display = 'inline-block';
                    okBtn.textContent = 'Press Ok to close this window';
                }
            }
        }
        
        // Formatting helper functions
        function formatBytes(bytes) {
            if (bytes === 0) return '0 Bytes';
            const k = 1024;
            const sizes = ['Bytes', 'KB', 'MB', 'GB', 'TB'];
            const i = Math.floor(Math.log(bytes) / Math.log(k));
            return parseFloat((bytes / Math.pow(k, i)).toFixed(2)) + ' ' + sizes[i];
        }
        
        function formatSpeed(bytesPerSecond) {
            if (bytesPerSecond === 0) return '0 B/s';
            const k = 1024;
            const sizes = ['B/s', 'KB/s', 'MB/s', 'GB/s'];
            const i = Math.floor(Math.log(bytesPerSecond) / Math.log(k));
            return parseFloat((bytesPerSecond / Math.pow(k, i)).toFixed(1)) + ' ' + sizes[i];
        }
        
        function formatDuration(seconds) {
            if (seconds < 1) return '< 1s';
            if (seconds < 60) return Math.round(seconds) + 's';
            const minutes = Math.floor(seconds / 60);
            const remainingSeconds = Math.round(seconds % 60);
            if (minutes < 60) {
                return remainingSeconds > 0 ? `${minutes}m ${remainingSeconds}s` : `${minutes}m`;
            }
            const hours = Math.floor(minutes / 60);
            const remainingMinutes = minutes % 60;
            return `${hours}h ${remainingMinutes}m`;
        }
        
        // Helper functions for file path extraction
        function extractFilePathFromCheckbox(checkbox) {
            // Extract filepath from the checkbox's onchange attribute
            const onchangeAttr = checkbox.getAttribute('onchange');
            if (onchangeAttr) {
                const match = onchangeAttr.match(/toggleFileSelection\('([^']+)'/);
                return match ? match[1] : null;
            }
            return null;
        }
        
        function getFileNameFromPath(filePath) {
            if (!filePath) return 'unknown';
            return filePath.split('/').pop() || filePath.split('\\').pop() || 'unknown';
        }
        
        // Custom Confirmation Modal Functions
        function showConfirmationModal(title, message, fileList = null, filePaths = null) {
            return new Promise((resolve) => {
                const modal = document.getElementById('confirmationModal');
                const titleElement = document.getElementById('confirmationTitle');
                const messageElement = document.getElementById('confirmationMessage');
                const fileListElement = document.getElementById('confirmationFileList');
                const cancelBtn = document.getElementById('confirmationCancelBtn');
                const deleteBtn = document.getElementById('confirmationDeleteBtn');
                
                // Calculate total file size if we have file paths
                let totalSizeBytes = 0;
                let totalSizeText = '';
                
                if (filePaths && filePaths.length > 0 && directoryCache[currentPath]) {
                    const cachedFiles = directoryCache[currentPath];
                    filePaths.forEach(filePath => {
                        const fileName = filePath.split('/').pop();
                        const fileData = cachedFiles.find(f => f.name === fileName);
                        if (fileData && !fileData.isDirectory) {
                            // Handle different size formats (bytes as string, number, etc.)
                            let sizeBytes = 0;
                            if (typeof fileData.size === 'string') {
                                // Try parsing formatted size string first
                                if (fileData.size.includes('MB')) {
                                    sizeBytes = parseFloat(fileData.size) * 1024 * 1024;
                                } else if (fileData.size.includes('GB')) {
                                    sizeBytes = parseFloat(fileData.size) * 1024 * 1024 * 1024;
                                } else if (fileData.size.includes('KB')) {
                                    sizeBytes = parseFloat(fileData.size) * 1024;
                                } else {
                                    // Assume it's bytes as string
                                    sizeBytes = parseInt(fileData.size) || 0;
                                }
                            } else if (typeof fileData.size === 'number') {
                                sizeBytes = fileData.size;
                            }
                            totalSizeBytes += sizeBytes;
                        }
                    });
                    
                    // Format total size - always show both MB and GB
                    if (totalSizeBytes > 0) {
                        const totalSizeGB = (totalSizeBytes / (1024 * 1024 * 1024)).toFixed(2);
                        const totalSizeMB = (totalSizeBytes / (1024 * 1024)).toFixed(1);
                        totalSizeText = `${totalSizeMB} MB (${totalSizeGB} GB)`;
                    }
                }
                
                // Set modal content
                titleElement.textContent = title;
                messageElement.textContent = message;
                
                // Handle file list for multiple deletions
                if (fileList && fileList.length > 0) {
                    fileListElement.innerHTML = '';
                    
                    // Add total size info if available
                    if (totalSizeText) {
                        // Calculate regained space (same as total size for deletion)
                        let regainedSpaceText = '';
                        if (storageInfo && storageInfo.available && totalSizeBytes > 0) {
                            const afterDeletionBytes = storageInfo.available + totalSizeBytes;
                            const afterDeletionGB = (afterDeletionBytes / (1024 * 1024 * 1024)).toFixed(2);
                            const afterDeletionMB = (afterDeletionBytes / (1024 * 1024)).toFixed(1);
                            
                            if (afterDeletionBytes >= 1024 * 1024 * 1024) {
                                regainedSpaceText = `Available after deletion: ${afterDeletionGB} GB`;
                            } else {
                                regainedSpaceText = `Available after deletion: ${afterDeletionMB} MB`;
                            }
                        }
                        
                        const sizeInfo = document.createElement('div');
                        sizeInfo.className = 'file-size-info';
                        sizeInfo.style.cssText = 'background:#2d3748; color:#fbbf24; padding:10px; border-radius:6px; margin-bottom:10px; text-align:center; font-weight:bold;';
                        sizeInfo.innerHTML = `
                            <div style="display:flex; justify-content:space-between; margin-bottom:8px;">
                                <div style="text-align:center; flex:1;">
                                    <div style="color:#fbbf24; font-size:14px; margin-bottom:5px;"> TOTAL DELETION AMOUNT CALCULATED</div>
                                    <div style="font-size:18px; font-weight:bold; color:#dc2626;">${totalSizeText}</div>
                                </div>
                                <div style="text-align:center; flex:1;">
                                    <div style="color:#10b981; font-size:14px; margin-bottom:5px;"> SPACE AFTER DELETION</div>
                                    <div style="font-size:18px; font-weight:bold; color:#10b981;">${regainedSpaceText || 'Calculating...'}</div>
                                </div>
                            </div>
                            <div style="color:#10b981; font-size:14px; text-align:center; padding:5px; background:#065f46; border-radius:4px;">
                                 Space that will be regained after deletion
                            </div>
                        `;
                        fileListElement.appendChild(sizeInfo);
                    }
                    
                    fileList.forEach((file, index) => {
                        const fileItem = document.createElement('div');
                        fileItem.className = 'file-list-item';
                        
                        // Get file size if available from the filePaths
                        let fileSizeText = '';
                        console.log('DEBUG: Getting size for file index:', index, 'filePaths:', filePaths);
                        console.log('DEBUG: currentPath:', currentPath, 'directoryCache exists:', !!directoryCache[currentPath]);
                        
                        if (filePaths && filePaths[index] && directoryCache[currentPath]) {
                            const fileName = filePaths[index].split('/').pop();
                            console.log('DEBUG: Looking for fileName:', fileName);
                            
                            const fileData = directoryCache[currentPath].find(f => f.name === fileName);
                            console.log('DEBUG: Found fileData:', fileData);
                            
                            if (fileData && !fileData.isDirectory) {
                                // Handle different size formats (bytes as string, number, etc.)
                                let sizeBytes = 0;
                                if (typeof fileData.size === 'string') {
                                    // Try parsing formatted size string first
                                    if (fileData.size.includes('MB')) {
                                        sizeBytes = parseFloat(fileData.size) * 1024 * 1024;
                                    } else if (fileData.size.includes('GB')) {
                                        sizeBytes = parseFloat(fileData.size) * 1024 * 1024 * 1024;
                                    } else if (fileData.size.includes('KB')) {
                                        sizeBytes = parseFloat(fileData.size) * 1024;
                                    } else {
                                        // Assume it's bytes as string
                                        sizeBytes = parseInt(fileData.size) || 0;
                                    }
                                } else if (typeof fileData.size === 'number') {
                                    sizeBytes = fileData.size;
                                }
                                
                                console.log('DEBUG: Final sizeBytes:', sizeBytes);
                                
                                if (sizeBytes > 0) {
                                    const sizeMB = (sizeBytes / (1024 * 1024)).toFixed(1);
                                    const sizeGB = (sizeBytes / (1024 * 1024 * 1024)).toFixed(2);
                                    
                                    let sizeClass;
                                    if (sizeBytes >= 1024 * 1024 * 1024) {
                                        fileSizeText = `${sizeMB}MB | ${sizeGB}GB`;
                                        sizeClass = 'file-size-huge';
                                    } else if (sizeBytes >= 100 * 1024 * 1024) {
                                        fileSizeText = `${sizeMB}MB | ${sizeGB}GB`;
                                        sizeClass = 'file-size-large';
                                    } else if (sizeBytes >= 10 * 1024 * 1024) {
                                        fileSizeText = `${sizeMB}MB | ${sizeGB}GB`;
                                        sizeClass = 'file-size-medium';
                                    } else {
                                        fileSizeText = `${sizeMB}MB | ${sizeGB}GB`;
                                        sizeClass = 'file-size-small';
                                    }
                                } else {
                                    fileSizeText = 'Unknown size';
                                }
                            }
                        }
                        
                        const sizeClass = fileSizeText ? (fileSizeText.includes('GB') && !fileSizeText.startsWith('0.') ? 'file-size-huge' : parseFloat(fileSizeText) >= 100 ? 'file-size-large' : parseFloat(fileSizeText) >= 10 ? 'file-size-medium' : 'file-size-small') : 'file-size-small';
                        fileItem.innerHTML = `
                            <span style="color: #ffffff; text-align: left;">${file}</span>
                            <div class="file-item-line ${sizeClass}"></div>
                            <span style="color: #fbbf24; font-size: 14px; font-weight: bold;">${fileSizeText}</span>
                        `;
                        fileListElement.appendChild(fileItem);
                    });
                    fileListElement.style.display = 'block';
                } else {
                    fileListElement.style.display = 'none';
                }
                
                // Show modal
                modal.style.display = 'block';
                
                // Handle button clicks
                const handleCancel = () => {
                    modal.style.display = 'none';
                    cancelBtn.removeEventListener('click', handleCancel);
                    deleteBtn.removeEventListener('click', handleConfirm);
                    document.removeEventListener('keydown', handleKeydown);
                    resolve(false);
                };
                
                const handleConfirm = () => {
                    modal.style.display = 'none';
                    cancelBtn.removeEventListener('click', handleCancel);
                    deleteBtn.removeEventListener('click', handleConfirm);
                    document.removeEventListener('keydown', handleKeydown);
                    resolve(true);
                };
                
                // Handle keyboard events
                const handleKeydown = (event) => {
                    if (event.key === 'Escape') {
                        handleCancel();
                    } else if (event.key === 'Enter') {
                        handleConfirm();
                    }
                };
                
                // Add event listeners
                cancelBtn.addEventListener('click', handleCancel);
                deleteBtn.addEventListener('click', handleConfirm);
                document.addEventListener('keydown', handleKeydown);
                
                // Focus the delete button for accessibility
                setTimeout(() => deleteBtn.focus(), 100);
            });
        }
        
        // Close modal when clicking outside of it
        document.addEventListener('click', (event) => {
            const modal = document.getElementById('confirmationModal');
            if (event.target === modal) {
                modal.style.display = 'none';
            }
        });
        
        // Success Modal Functions
        // Upload statistics storage
        let uploadStats = {
            startTime: null,
            endTime: null,
            totalBytes: 0,
            completedFiles: []
        };
        
        
        // Progress modal OK button handlers
        function proceedToUploadCompletion() {
            // Hide progress modal
            document.getElementById('upload-modal').style.display = 'none';
            
            // Show completion modal with upload statistics
            showUploadCompleteModal(
                'Upload Complete!',
                `All ${uploadStats.completedFiles.length} video(s) have been successfully uploaded to the video catalog.`,
                uploadStats.completedFiles
            );
            
            // Clean up
            cancelUpload();
            loadVideoLibrary();
            loadStorageInfo();
            updateBaselineTimestamp();
        }
        
        function proceedToGeneralUploadCompletion() {
            // Hide progress modal
            document.getElementById('general-upload-modal').style.display = 'none';
            
            // Show completion modal with upload statistics
            showUploadCompleteModal(
                'Upload Complete!',
                `All ${uploadStats.completedFiles.length} file(s) have been successfully uploaded to ~/random_files/.`,
                uploadStats.completedFiles
            );
            
            // Clean up
            cancelGeneralUpload();
            generalUploadInProgress = false;
            updateBaselineTimestamp();
        }

        function showUploadCompleteModal(title, message, fileStats = []) {
            const modal = document.getElementById('oldReserveSuccessModal');
            const titleElement = document.getElementById('successTitle');
            const detailsElement = document.getElementById('successDetails');
            const countElement = document.getElementById('successCount');
            const fileListElement = document.getElementById('successFileList');
            const okBtn = document.getElementById('successOkBtn');
            
            if (!modal) {
                console.error('ERROR: Upload complete modal not found!');
                return;
            }
            
            // Set title
            if (titleElement) titleElement.textContent = title;
            
            // Set simple completion message
            if (detailsElement) detailsElement.textContent = message;
            
            // Hide count and file list for clean completion modal
            if (countElement) countElement.style.display = 'none';
            if (fileListElement) {
                // Create upload statistics display
                const totalBytes = fileStats.reduce((sum, file) => sum + file.size, 0);
                const totalDuration = fileStats.reduce((max, file) => Math.max(max, file.duration), 0);
                const avgThroughput = totalBytes > 0 && totalDuration > 0 ? (totalBytes * 8 / totalDuration / 1000000) : 0; // Mbps
                
                let statsHTML = `
                    <div style="margin-top: 20px; padding: 15px; background: #333; border-radius: 8px; color: #fff;">
                        <div style="display: flex; justify-content: space-between; margin-bottom: 10px;">
                            <span> Files uploaded: <strong>${fileStats.length}</strong></span>
                            <span> Total size: <strong>${(totalBytes / (1024 * 1024)).toFixed(1)} MB</strong></span>
                        </div>
                        <div style="display: flex; justify-content: space-between; margin-bottom: 15px;">
                            <span> Total duration: <strong>${Math.floor(totalDuration / 60)}:${String(Math.floor(totalDuration % 60)).padStart(2, '0')}</strong></span>
                            <span> Avg throughput: <strong>${avgThroughput.toFixed(1)} Mbps</strong></span>
                        </div>`;
                
                fileStats.forEach(file => {
                    const durationFormatted = `${Math.floor(file.duration / 60)}:${String(Math.floor(file.duration % 60)).padStart(2, '0')}`;
                    const throughput = file.size > 0 && file.duration > 0 ? (file.size * 8 / file.duration / 1000000) : 0;
                    statsHTML += `
                        <div style="border-top: 1px solid #555; padding-top: 8px; margin-top: 8px;">
                            <div style="font-weight: bold; margin-bottom: 4px;"> ${file.name}</div>
                            <div style="font-size: 12px; color: #ccc; display: flex; justify-content: space-between;">
                                <span>Started: ${file.startTime}</span>
                                <span>Completed: ${file.endTime}</span>
                            </div>
                            <div style="font-size: 12px; color: #ccc; display: flex; justify-content: space-between; margin-top: 2px;">
                                <span>Duration: ${durationFormatted}</span>
                                <span>Size: ${(file.size / (1024 * 1024)).toFixed(1)} MB</span>
                                <span>Speed: ${throughput.toFixed(1)} Mbps</span>
                            </div>
                        </div>`;
                });
                
                statsHTML += '</div>';
                fileListElement.innerHTML = statsHTML;
                fileListElement.style.display = 'block';
            }
            
            // Show modal
            modal.style.display = 'block';
        }

        function showSuccessModal(title, message, fileList = null, count = null, fileObjects = null) {
            const modal = document.getElementById('oldReserveSuccessModal');
            const titleElement = document.getElementById('successTitle');
            const detailsElement = document.getElementById('successDetails');
            const countElement = document.getElementById('successCount');
            const fileListElement = document.getElementById('successFileList');
            const okBtn = document.getElementById('successOkBtn');
            
            console.log('DEBUG: showSuccessModal called with:', title, message);
            console.log('DEBUG: Modal element found:', modal);
            console.log('DEBUG: Title element found:', titleElement);
            console.log('DEBUG: Details element found:', detailsElement);
            console.log('DEBUG: Count element found:', countElement); 
            console.log('DEBUG: File list element found:', fileListElement);
            console.log('DEBUG: OK button found:', okBtn);
            console.log('DEBUG: File objects:', fileObjects);
            
            // Check if modal exists
            if (!modal) {
                console.error('ERROR: Success modal not found!');
                alert('Success modal not found! Files processed: ' + (fileList ? fileList.length : 0));
                return;
            }
            
            // Set modal content
            if (titleElement) titleElement.textContent = title;
            
            // Calculate total file size and remaining space if file objects are provided
            let sizeInfoHTML = '';
            if (fileObjects && fileObjects.length > 0) {
                const totalSizeBytes = fileObjects.reduce((sum, file) => sum + (file.size || 0), 0);
                const totalSizeMB = (totalSizeBytes / (1024 * 1024)).toFixed(1);
                const totalSizeGB = (totalSizeBytes / (1024 * 1024 * 1024)).toFixed(2);
                
                let totalSizeText;
                if (totalSizeBytes >= 1024 * 1024 * 1024) {
                    totalSizeText = `${totalSizeGB} GB (${totalSizeMB} MB)`;
                } else {
                    totalSizeText = `${totalSizeMB} MB`;
                }
                
                // Calculate remaining space after upload
                let remainingSpaceText = '';
                if (storageInfo) {
                    const currentAvailableBytes = storageInfo.available;
                    const remainingAfterUploadBytes = currentAvailableBytes - totalSizeBytes;
                    const remainingAfterUploadGB = (remainingAfterUploadBytes / (1024 * 1024 * 1024)).toFixed(2);
                    const remainingAfterUploadMB = (remainingAfterUploadBytes / (1024 * 1024)).toFixed(1);
                    
                    if (remainingAfterUploadBytes >= 1024 * 1024 * 1024) {
                        remainingSpaceText = `${remainingAfterUploadGB} GB`;
                    } else {
                        remainingSpaceText = `${remainingAfterUploadMB} MB`;
                    }
                }
                
                sizeInfoHTML = `
                    <div style="background:#2d3748; color:#ffffff; padding:15px; border-radius:8px; margin-bottom:15px; border-left:4px solid #10b981;">
                        <div style="display:flex; justify-content:space-between; margin-bottom:10px;">
                            <div style="text-align:center; flex:1;">
                                <div style="color:#fbbf24; font-size:14px; font-weight:bold; margin-bottom:5px;"> TOTAL UPLOAD SIZE CALCULATED</div>
                                <div style="font-size:18px; font-weight:bold; color:#10b981;">${totalSizeMB} MB (${totalSizeGB} GB)</div>
                            </div>
                            <div style="text-align:center; flex:1;">
                                <div style="color:#60a5fa; font-size:14px; font-weight:bold; margin-bottom:5px;"> REMAINING AFTER UPLOAD</div>
                                <div style="font-size:18px; font-weight:bold; color:#60a5fa;">${remainingSpaceText || 'Calculating...'}</div>
                            </div>
                        </div>
                        <div style="text-align:center; padding:8px; background:#374151; border-radius:4px;">
                            <span style="color:#d1d5db; font-size:14px;"> Space available if you proceed with upload</span>
                        </div>
                    </div>
                `;
            }
            
            console.log('DEBUG: Setting modal content');
            
            // Handle file list and count for multiple operations
            if (fileList && fileList.length > 0) {
                if (countElement) countElement.textContent = count ? `${count} files selected for upload` : `${fileList.length} files selected for upload`;
                
                if (fileListElement) {
                    fileListElement.innerHTML = '';
                    
                    // Add size information first if available
                    if (sizeInfoHTML) {
                        const sizeInfoDiv = document.createElement('div');
                        sizeInfoDiv.innerHTML = sizeInfoHTML;
                        fileListElement.appendChild(sizeInfoDiv);
                    }
                    
                    fileList.forEach((fileName, index) => {
                        const fileItem = document.createElement('div');
                        fileItem.className = 'success-file-item';
                        
                        // Get file size from fileObjects if available
                        let fileSizeText = '';
                        let sizeClass = 'file-size-small'; // Default size class
                        
                        if (fileObjects && fileObjects[index]) {
                            const fileSize = fileObjects[index].size || 0;
                            const sizeMB = (fileSize / (1024 * 1024)).toFixed(1);
                            const sizeGB = (fileSize / (1024 * 1024 * 1024)).toFixed(2);
                            
                            if (fileSize >= 1024 * 1024 * 1024) {
                                fileSizeText = `${sizeMB}MB | ${sizeGB}GB`;
                                sizeClass = 'file-size-huge';
                            } else if (fileSize >= 100 * 1024 * 1024) {
                                fileSizeText = `${sizeMB}MB | ${sizeGB}GB`;
                                sizeClass = 'file-size-large';
                            } else if (fileSize >= 10 * 1024 * 1024) {
                                fileSizeText = `${sizeMB}MB | ${sizeGB}GB`;
                                sizeClass = 'file-size-medium';
                            } else {
                                fileSizeText = `${sizeMB}MB | ${sizeGB}GB`;
                                sizeClass = 'file-size-small';
                            }
                        }
                        
                        fileItem.innerHTML = `
                            <span style="color: #ffffff; text-align: left;">${fileName}</span>
                            <div class="file-item-line ${sizeClass || 'file-size-small'}"></div>
                            <span style="color: #10b981; font-size: 14px; font-weight: bold;">${fileSizeText}</span>
                        `;
                        fileListElement.appendChild(fileItem);
                    });
                }
                if (detailsElement) detailsElement.style.display = 'block';
            } else {
                if (detailsElement) detailsElement.style.display = 'none';
            }
            
            // Show modal
            console.log('DEBUG: Showing modal');
            if (modal) {
                modal.style.display = 'block';
                console.log('DEBUG: Modal displayed');
            } else {
                console.log('DEBUG: Modal element not found!');
                return;
            }
            
            // Handle OK button click
            const handleOk = async () => {
                if (modal) modal.style.display = 'none';
                if (okBtn) okBtn.removeEventListener('click', handleOk);
                document.removeEventListener('keydown', handleKeydown);
                
                // Refresh storage info after modal closes (for file deletions)
                console.log("Success modal closed, refreshing storage info...");
                try {
                    await loadStorageInfo();
                    console.log("Storage info refreshed successfully after modal close");
                } catch (error) {
                    console.error("Error refreshing storage after modal close:", error);
                }
            };
            
            // Handle keyboard events
            const handleKeydown = (event) => {
                if (event.key === 'Escape' || event.key === 'Enter') {
                    handleOk();
                }
            };
            
            // Add event listeners
            okBtn.addEventListener('click', handleOk);
            document.addEventListener('keydown', handleKeydown);
            
            // Focus the OK button
            setTimeout(() => okBtn.focus(), 100);
            
        }
        
        // Close success modal when clicking outside of it
        document.addEventListener('click', (event) => {
            const modal = document.getElementById('successModal');
            if (event.target === modal) {
                modal.style.display = 'none';
            }
        });
        
        // Critical system files protection
        function isCriticalSystemFile(filePath) {
            const criticalPaths = [
                '/home/gus/video-system/docs/dashboard',  // Matches dashboard*.html
                '/home/gus/video-system/scripts/auth_api_server',  // Matches auth_api_server*
                '/etc/nginx',  // Matches nginx*
                '/usr/local/nginx',  // Matches nginx*
                '/var/log/nginx',  // Matches nginx*
                '/home/gus/.ssh/',
                '/home/gus/.bashrc',
                '/home/gus/.bash_profile',
                '/home/gus/.profile'
            ];
            
            // Check if file path starts with any critical path
            return criticalPaths.some(criticalPath => {
                return filePath.startsWith(criticalPath) || filePath === criticalPath;
            });
        }
        
        function showCriticalFileWarning(fileName) {
            const modal = document.createElement('div');
            modal.style.cssText = `
                position: fixed; top: 0; left: 0; width: 100%; height: 100%;
                background: rgba(0,0,0,0.8); display: flex; align-items: center; flex-wrap: nowrap;
                justify-content: center; z-index: 10000;
            `;
            
            // Determine if fileName contains multiple files (look for numbers and commas)
            const isMultipleFiles = fileName.includes(':') && fileName.includes(',');
            const fileWord = isMultipleFiles ? 'files' : 'file';
            const deleteWord = isMultipleFiles ? 'these files' : 'this file';
            const title = isMultipleFiles ? 'CRITICAL SYSTEM FILES' : 'CRITICAL SYSTEM FILE';
            
            modal.innerHTML = `
                <div style="
                    background: linear-gradient(135deg, #dc3545, #c82333);
                    color: white; padding: 30px; border-radius: 15px;
                    max-width: 800px; text-align: center;
            display: flex;
            align-items: center;
            gap: 20px;
                    box-shadow: 0 20px 60px rgba(220, 53, 69, 0.3);
                ">
                    <div style="font-size: 3em; margin-bottom: 20px;"></div>
                    <h2 style="margin-bottom: 15px; color: white;">${title}</h2>
                    <p style="margin-bottom: 20px; line-height: 1.5;">
                        The ${fileWord} "<strong>${fileName}</strong>" ${isMultipleFiles ? 'are' : 'is a'} critical system ${fileWord} and cannot be deleted.
                        Deleting ${deleteWord} could break the application or system functionality.
                    </p>
                    <button onclick="this.parentElement.parentElement.remove()" style="
                        background: white; color: #dc3545; border: none;
                        padding: 12px 25px; border-radius: 8px; cursor: pointer;
                        font-weight: 600; font-size: 16px;
                    ">
                        Understood
                    </button>
                </div>
            `;
            
            document.body.appendChild(modal);
        }
        
        function showErrorModal(title, message) {
            const modal = document.createElement('div');
            modal.style.cssText = `
                position: fixed; top: 0; left: 0; width: 100%; height: 100%;
                background: rgba(0,0,0,0.8); display: flex; align-items: center; flex-wrap: nowrap;
                justify-content: center; z-index: 10000;
            `;
            
            modal.innerHTML = `
                <div style="
                    background: linear-gradient(135deg, #dc3545, #c82333);
                    color: white; padding: 20px; border-radius: 12px;
                    max-width: 400px; width: 85%; text-align: center;
                    display: flex;
                    flex-direction: column;
                    gap: 12px;
                    box-shadow: 0 15px 40px rgba(220, 53, 69, 0.3);
                ">
                    <div style="font-size: 2em; margin-bottom: 10px;"></div>
                    <h2 style="margin-bottom: 10px; color: white; font-size: 1.4em;">${title}</h2>
                    <p style="margin-bottom: 20px; line-height: 1.5;">
                        ${message}
                    </p>
                    <button onclick="this.parentElement.parentElement.remove()" style="
                        background: white; color: #dc3545; border: none;
                        padding: 12px 25px; border-radius: 8px; cursor: pointer;
                        font-weight: 600; font-size: 16px;
                    ">
                        OK
                    </button>
                </div>
            `;
            
            document.body.appendChild(modal);
        }
        
        async function deleteFile(filePath, fileName) {
            // Check if this is a critical system file
            if (isCriticalSystemFile(filePath)) {
                showCriticalFileWarning(fileName);
                return;
            }
            
            // Show custom confirmation dialog
            const confirmed = await showConfirmationModal(
                'Delete File',
                `Are you sure you want to delete "${fileName}"?`,
                [fileName],
                [filePath]
            );
            if (!confirmed) return;
            
            try {
                
                // Log file deletion with specific details
                console.log("DEBUG: About to log file deletion for:", fileName);
                logAction(
                    "User deleted file: " + fileName,
                    "Full path: " + filePath + " | Directory: " + filePath.substring(0, filePath.lastIndexOf("/")),
                    "/api/delete-file",
                    "POST"
                );
                const response = await fetch('/api/delete-file', {
                    method: 'POST',
                    headers: {
                        'Content-Type': 'application/json',
                        ...window.authHeaders
                    },
                    body: JSON.stringify({
                        path: filePath
                    })
                });
                
                if (!response.ok) {
                    throw new Error(`HTTP ${response.status}: ${response.statusText}`);
                }
                
                // Refresh the current directory to reflect changes
                await navigateTo(currentPath);
                
                // Show success modal
                showSuccessModal(
                    'File Deleted Successfully',
                    `"${fileName}" has been permanently deleted.`
                );
                
            } catch (error) {
                showErrorModal('Deletion Failed', `Unable to delete "${fileName}": ${error.message}`);
            }
        }
        
        async function loadVideoLibrary() {
            if (currentMode !== 'video') return;
            
            // Remove playlist banner if present and clear playlist
            const playlistBanner = document.getElementById('playlistBanner');
            if (playlistBanner) {
                playlistBanner.remove();
            }
            window.currentPlaylist = null;
            
            // Pause any currently playing video to stop playlist
            const videoPlayer = document.getElementById('videoPlayer');
            if (videoPlayer) {
                videoPlayer.pause();
            }
            
            const container = document.getElementById('video-library-container');
            container.innerHTML = '<div class="loading">Loading videos...</div>';
            
            try {
                // If we have a backup of original library, restore it instead of fetching
                if (window.originalVideoLibrary) {
                    allVideos = [...window.originalVideoLibrary];
                    window.originalVideoLibrary = null; // Clear backup
                    displayVideoLibrary(allVideos);
                } else {
                    // Fetch fresh video library
                    const response = await fetch('/api/videos', {
                        headers: window.authHeaders
                    });
                    if (!response.ok) throw new Error('Failed to load video catalog');
                    
                    const data = await response.json();
                    allVideos = data.videos || [];
                    displayVideoLibrary(allVideos);
                }
                
            } catch (error) {
                container.innerHTML = `<div class="error">Error loading videos: ${error.message}</div>`;
            }
        }
        
        function displayVideoLibrary(videos) {
            const container = document.getElementById('video-library-container');
            
            if (!videos || videos.length === 0) {
                container.innerHTML = '<div class="error">No videos found in library</div>';
                return;
            }
            
            let html = '';
            
            videos.forEach((video, index) => {
                const isPlaying = currentPlayingVideo === video.name;
                const titleClass = video.name.length > 25 ? 'video-title long-name' : 'video-title';
                
                const thumbnailId = `thumbnail-lib-${index}`;
                html += `
                    <div class="video-library-item ${isPlaying ? 'playing' : ''}" 
                         data-video-index="${index}"
                         draggable="true">
                        <div class="drag-handle" 
                             onmousedown="event.stopPropagation()" 
                             title="Drag to reorder"></div>
                        <div class="video-thumbnail-container" id="${thumbnailId}"
                             onmouseenter="handleThumbnailHover('${video.name}', '${video.path}', '${thumbnailId}')"
                             onmouseleave="handleThumbnailLeave('${thumbnailId}')"
                             onclick="handleThumbnailHover('${video.name}', '${video.path}', '${thumbnailId}')">
                            <div class="video-thumbnail-placeholder"></div>
                            <div class="video-thumbnail-loading" style="display: none;">Loading...</div>
                            <video class="video-thumbnail" muted></video>
                        </div>
                        <div class="video-info">
                            <div class="${titleClass}" 
                                 onmouseenter="handleThumbnailHover('${video.name}', '${video.path}', '${thumbnailId}')"
                                 onmouseleave="handleThumbnailLeave('${thumbnailId}')"
                                 onclick="handleThumbnailHover('${video.name}', '${video.path}', '${thumbnailId}')">${video.name}</div>
                            <div class="video-meta">${video.size}  ${video.directory}</div>
                        </div>
                        <button class="play-btn" onclick="playVideoFromLibrary('${video.name}', '${video.path}')">
                            ${isPlaying ? ' Playing' : ' Play'}
                        </button>
                    </div>
                `;
            });
            
            container.innerHTML = html;
            setupVideoLibraryDragAndDrop();
        }
        
        async function fetchVideoAsBlob(fullPath) {
            const response = await fetch(`/api/view?path=${encodeURIComponent(fullPath)}`, {
                headers: window.authHeaders
            });
            
            if (!response.ok) {
                throw new Error(`HTTP ${response.status}: ${response.statusText}`);
            }
            
            const blob = await response.blob();
            return URL.createObjectURL(blob);
        }
        
        function playVideoFromLibrary(filename, fullPath) {
            const videoPlayer = document.getElementById('videoPlayer');
            // Video name will be updated after successful load
            
            // Create a blob URL from the video file for better streaming
            fetchVideoAsBlob(fullPath)
                .then(blobUrl => {
                    videoPlayer.innerHTML = `<source src="${blobUrl}" type="video/mp4">`;
                    videoPlayer.load();
                    videoPlayer.play();
                    // Update video name after successful load
                    document.getElementById("current-video-name").textContent = filename;
                    // Update play status to playing with green glowing icon
                    updatePlayStatus("playing");
                })
                .catch(error => {
                    console.error('Error loading video:', error);
                    showErrorModal('Video Loading Failed', 'Failed to load video: ' + error.message);
                });
            
            currentPlayingVideo = filename;
            
            // Log video play action
            const fileSize = allVideos.find(v => v.name === filename)?.size || "unknown";
            logVideoPlay(filename, fullPath, fileSize);
            document.getElementById('current-video-name').textContent = filename;
            
            if (currentMode === 'video') {
                displayVideoLibrary(allVideos);
            }
            
            showError('');
        }
        
        // Video Thumbnail Preview Functions
        let activeThumbnails = new Map();
        
        function startThumbnailPreview(videoName, videoPath, thumbnailId, forceRestart = false) {
            const thumbnailContainer = document.getElementById(thumbnailId);
            if (!thumbnailContainer) return;
            
            const placeholder = thumbnailContainer.querySelector('.video-thumbnail-placeholder');
            const loading = thumbnailContainer.querySelector('.video-thumbnail-loading');
            const video = thumbnailContainer.querySelector('.video-thumbnail');
            
            // Always clear any existing state first
            if (video) {
                video.pause();
                video.currentTime = 0;
                video.ontimeupdate = null;
                video.onended = null;
                video.onloadeddata = null;
                video.onerror = null;
                video.classList.remove('playing');
            }
            
            // For click events or force restart, always reload video
            if (forceRestart || !video.src || video.readyState < 3) {
                // Show loading state
                if (placeholder) placeholder.style.display = 'none';
                if (loading) {
                    loading.style.display = 'block';
                    loading.textContent = 'Loading...';
                }
                
                // Load video fresh
                fetchVideoAsBlob(videoPath)
                    .then(blobUrl => {
                        if (!activeThumbnails.has(thumbnailId)) return; // User moved away
                        
                        video.src = blobUrl;
                        video.muted = true;
                        video.loop = false;
                        video.currentTime = 0;
                        
                        video.onloadeddata = function() {
                            if (!activeThumbnails.has(thumbnailId)) return;
                            
                            if (loading) loading.style.display = 'none';
                            video.classList.add('playing');
                            startThumbnailLoop(video, thumbnailId);
                        };
                        
                        video.onerror = function() {
                            stopThumbnailPreview(thumbnailId);
                        };
                    })
                    .catch(error => {
                        console.error('Error loading thumbnail:', error);
                        stopThumbnailPreview(thumbnailId);
                    });
            } else {
                // Video is already loaded, restart immediately
                if (placeholder) placeholder.style.display = 'none';
                if (loading) loading.style.display = 'none';
                video.classList.add('playing');
                startThumbnailLoop(video, thumbnailId);
            }
        }
        
        function startThumbnailLoop(videoElement, thumbnailId) {
            if (!activeThumbnails.has(thumbnailId)) return;
            
            // Always restart from beginning
            videoElement.currentTime = 0;
            
            const playPromise = videoElement.play();
            if (playPromise !== undefined) {
                playPromise.catch(error => {
                    console.error('Error playing thumbnail video:', error);
                    stopThumbnailPreview(thumbnailId);
                });
            }
            
            const checkLoop = () => {
                if (!activeThumbnails.has(thumbnailId)) return;
                
                if (videoElement.currentTime >= 6 || videoElement.ended) {
                    videoElement.currentTime = 0;
                    const replayPromise = videoElement.play();
                    if (replayPromise !== undefined) {
                        replayPromise.catch(error => {
                            console.error('Error replaying thumbnail video:', error);
                        });
                    }
                }
            };
            
            // Set new event listeners
            videoElement.ontimeupdate = checkLoop;
            videoElement.onended = () => {
                if (activeThumbnails.has(thumbnailId)) {
                    videoElement.currentTime = 0;
                    const replayPromise = videoElement.play();
                    if (replayPromise !== undefined) {
                        replayPromise.catch(error => {
                            console.error('Error replaying thumbnail video on end:', error);
                        });
                    }
                }
            };
        }
        
        function stopThumbnailPreview(thumbnailId) {
            activeThumbnails.delete(thumbnailId);
            
            const thumbnailContainer = document.getElementById(thumbnailId);
            if (!thumbnailContainer) return;
            
            const placeholder = thumbnailContainer.querySelector('.video-thumbnail-placeholder');
            const loading = thumbnailContainer.querySelector('.video-thumbnail-loading');
            const video = thumbnailContainer.querySelector('.video-thumbnail');
            
            if (video) {
                video.pause();
                video.currentTime = 0;
                video.classList.remove('playing');
                // Clear event listeners to prevent memory leaks
                video.ontimeupdate = null;
                video.onended = null;
                video.onloadeddata = null;
                video.onerror = null;
            }
            if (loading) loading.style.display = 'none';
            if (placeholder) placeholder.style.display = 'block';
        }
        
        function handleThumbnailHover(videoName, videoPath, thumbnailId) {
            console.log('Hover triggered for:', videoName, thumbnailId);
            // Stop any existing preview first
            if (activeThumbnails.has(thumbnailId)) {
                stopThumbnailPreview(thumbnailId);
                // Small delay to ensure cleanup is complete
                setTimeout(() => {
                    activeThumbnails.set(thumbnailId, true);
                    startThumbnailPreview(videoName, videoPath, thumbnailId, true);
                }, 50);
            } else {
                activeThumbnails.set(thumbnailId, true);
                startThumbnailPreview(videoName, videoPath, thumbnailId, true);
            }
        }
        
        function handleThumbnailLeave(thumbnailId) {
            stopThumbnailPreview(thumbnailId);
        }
        
        // Specific Error Modal for Non-Video Files
        function showNonVideoFilesError(nonVideoFiles) {
            const modal = document.createElement('div');
            modal.className = 'modal';
            modal.style.display = 'block';
            modal.style.zIndex = '10001';
            
            const filesList = nonVideoFiles.map(file => `<div style="padding: 8px 12px; background: #2a2a2a; border-radius: 6px; margin: 4px 0; text-align: left; border-left: 4px solid #dc3545;"><strong style="color: #fff;">${file.name}</strong><span style="color: #999; font-size: 0.9em; margin-left: 8px;">(${file.type || 'Unknown type'})</span></div>`).join('');
            
            modal.innerHTML = `
                <div class="modal-content" style="background: #000; border: 2px solid #dc3545; max-width: 1400px; width: 95%; margin: 3% auto; max-height: 85vh; display: flex; flex-direction: column;">
                    <div class="modal-header" style="background: linear-gradient(135deg, #dc3545, #c82333); color: white; padding: 15px 20px; border-radius: 18px 18px 0 0; flex-shrink: 0;">
                        <h3 style="margin: 0; display: flex; align-items: center; gap: 12px; font-size: 1.2em;">
                            <span style="font-size: 1.2em; background: #000; color: #dc3545; padding: 6px 8px; border-radius: 6px; display: inline-flex; align-items: center; justify-content: center; font-weight: bold; border: 2px solid #000;"></span> 
                            Non-Video Files Cannot Be Uploaded
                        </h3>
                    </div>
                    <div class="modal-body" style="padding: 20px 20px 5px 20px; color: #e0e0e0; font-size: 1em; line-height: 1.5; text-align: left; overflow-y: auto; flex: 1; display: flex; flex-direction: column;">
                        <div style="margin-bottom: 15px; text-align: center; flex-shrink: 0; display: flex; align-items: center; justify-content: center; gap: 10px; background: rgba(255, 193, 7, 0.1); padding: 12px; border-radius: 8px; border: 1px solid #ffc107;">
                            <span style="font-size: 1.3em; color: #ffc107;"></span>
                            <span style="color: #ffc107; font-weight: bold; font-size: 1.05em;">Only video files (MP4, WebM, AVI, MOV, MKV, FLV) are allowed in the video upload section.</span>
                        </div>
                        <div style="margin-bottom: 10px; font-weight: bold; color: #dc3545; flex-shrink: 0;">
                            The following ${nonVideoFiles.length} file(s) were ignored:
                        </div>
                        <div style="flex: 1; overflow-y: auto; border: 1px solid #333; border-radius: 8px; padding: 10px; background: #1a1a1a; margin-bottom: 15px;">
                            ${filesList}
                        </div>
                        <div style="text-align: center; flex-shrink: 0; display: flex; align-items: center; justify-content: center; gap: 8px; background: rgba(255, 193, 7, 0.15); padding: 15px; border-radius: 8px; border: 2px solid #ffc107; margin-bottom: 10px;">
                            <span style="font-size: 1.4em; color: #ffc107;"></span>
                            <span style="color: #ffc107; font-weight: bold; font-size: 1.15em;">Please select only video files and try again.</span>
                        </div>
                    </div>
                    <div class="modal-footer" style="padding: 10px 15px 15px 15px; display: flex; justify-content: center; background: rgba(0, 0, 0, 0.1); border-radius: 0 0 18px 18px; flex-shrink: 0;">
                        <button onclick="this.closest('.modal').remove()" style="background: linear-gradient(135deg, #dc3545, #c82333); color: white; border: none; padding: 10px 25px; border-radius: 20px; font-size: 14px; font-weight: 600; cursor: pointer; transition: all 0.3s ease; min-width: 100px; box-shadow: 0 4px 15px rgba(220, 53, 69, 0.3);">
                            OK
                        </button>
                    </div>
                </div>
            `;
            
            document.body.appendChild(modal);
            
            // Close modal when clicking outside
            modal.addEventListener('click', (e) => {
                if (e.target === modal) {
                    modal.remove();
                }
            });
        }

        // Enhanced Error Modal Function
        function showError(message, title = 'Error', type = 'error') {
            const modal = document.createElement('div');
            modal.className = 'modal';
            modal.style.display = 'block';
            modal.style.zIndex = '10001';
            
            // Set colors based on type
            const isSuccess = type === 'success';
            const borderColor = isSuccess ? '#28a745' : '#dc3545';
            const iconColor = isSuccess ? '#28a745' : '#dc3545';
            const icon = isSuccess ? '' : '';
            
            modal.innerHTML = `
                <div class="modal-content" style="background: #000; border: 2px solid ${borderColor}; max-width: 320px; width: 75%; margin: 15vh auto; height: auto; min-height: auto; display: flex; flex-direction: column; border-radius: 10px;">
                    <div class="modal-header" style="background: #000000; color: white; padding: 10px 14px; border-radius: 8px 8px 0 0; flex-shrink: 0; border-bottom: 2px solid ${borderColor};">
                        <h3 style="margin: 0; display: flex; align-items: center; gap: 6px; font-size: 1em;">
                            <span style="font-size: 0.9em; background: #000; color: ${iconColor}; padding: 3px 5px; border-radius: 3px; display: inline-flex; align-items: center; justify-content: center; font-weight: bold; border: 2px solid #000;">${icon}</span> ${title}
                        </h3>
                    </div>
                    <div class="modal-body" style="padding: 14px; color: #e0e0e0; font-size: 0.9em; line-height: 1.3; text-align: center; word-wrap: break-word;">
                        <div>${message}</div>
                    </div>
                    <div class="modal-footer" style="padding: 10px; display: flex; justify-content: center; background: rgba(0, 0, 0, 0.1); border-radius: 0 0 8px 8px; flex-shrink: 0;">
                        <button onclick="this.closest('.modal').remove()" style="background: ${isSuccess ? 'linear-gradient(135deg, #28a745, #20c997)' : 'linear-gradient(135deg, #dc3545, #c82333)'}; color: white; border: ${isSuccess ? '2px solid #28a745' : 'none'}; padding: 8px 20px; border-radius: 15px; font-size: 13px; font-weight: 600; cursor: pointer; transition: all 0.3s ease; min-width: 80px; box-shadow: ${isSuccess ? '0 3px 10px rgba(40, 167, 69, 0.3)' : '0 3px 10px rgba(220, 53, 69, 0.3)'};">
                            OK
                        </button>
                    </div>
                </div>
            `;
            
            document.body.appendChild(modal);
            
            // Close modal when clicking outside
            modal.addEventListener('click', (e) => {
                if (e.target === modal) {
                    modal.remove();
                }
            });
        }

        // Enhanced Success Modal Function  
        function showSuccess(message, title = 'Success') {
            const modal = document.createElement('div');
            modal.style.cssText = `
                position: fixed;
                top: 0;
                left: 0;
                width: 100vw;
                height: 100vh;
                background: rgba(0, 0, 0, 0.6);
                display: flex;
                align-items: center;
                justify-content: center;
                z-index: 10001;
            `;
            
            modal.innerHTML = `
                <div style="
                    background: #000; 
                    border: 2px solid #28a745; 
                    border-radius: 8px; 
                    padding: 0; 
                    box-shadow: 0 10px 30px rgba(0,0,0,0.5);
                    min-width: 200px;
                    width: auto;
                ">
                    <div style="
                        background: linear-gradient(135deg, #28a745, #218838); 
                        color: white; 
                        padding: 8px 12px; 
                        border-radius: 6px 6px 0 0;
                        text-align: center;
                    ">
                        <div style="margin: 0; font-size: 14px; font-weight: 600;">
                             ${title}
                        </div>
                    </div>
                    <div style="
                        padding: 12px 15px; 
                        color: #e0e0e0; 
                        font-size: 13px; 
                        text-align: center; 
                        line-height: 1.3;
                    ">
                        ${message}
                    </div>
                    <div style="
                        padding: 8px 15px 12px 15px; 
                        display: flex; 
                        justify-content: center;
                    ">
                        <button onclick="this.closest('div').remove()" style="
                            background: linear-gradient(135deg, #28a745, #218838); 
                            color: white; 
                            border: none; 
                            padding: 6px 20px; 
                            border-radius: 15px; 
                            font-size: 12px; 
                            font-weight: 600; 
                            cursor: pointer;
                            transition: all 0.3s ease;
                        ">
                            OK
                        </button>
                    </div>
                </div>
            `;
            
            document.body.appendChild(modal);
            
            // Close modal when clicking outside
            modal.addEventListener('click', (e) => {
                if (e.target === modal) {
                    modal.remove();
                }
            });
        }
        
        // Video player controls
        const video = document.getElementById('videoPlayer');
        
        function playPause() {
            if (video.paused) {
                video.play();
                updatePlayStatus("playing");
            } else {
                    
                video.pause();
                updatePlayStatus("stopped");
            }
        }
        
        function setupVideoEventListeners() {
            const videoPlayer = document.getElementById("videoPlayer");
            
            videoPlayer.addEventListener("play", function() {
                updatePlayStatus("playing");
            });
            
            videoPlayer.addEventListener("pause", function() {
                updatePlayStatus("stopped");
            });
            
            videoPlayer.addEventListener("ended", function() {
                updatePlayStatus("stopped");
            });
        }

        function updatePlayStatus(status) {
            const playStatusIcon = document.getElementById("play-status-icon");
            const statusText = document.getElementById("status-text");
            if (status === "playing") {
                playStatusIcon.textContent = "";
                playStatusIcon.className = "play-status playing";
                statusText.textContent = "Now Playing:";
            } else {
                playStatusIcon.textContent = "";
                playStatusIcon.className = "play-status stopped";
                statusText.textContent = "Stopped reproduction of video:";
            }
        }

        function restartVideo() {
            video.currentTime = 0;
            video.play();
            updatePlayStatus("playing");
        }
        
        function toggleMute() {
            video.muted = !video.muted;
        }
        
        function toggleFullscreen() {
            if (video.requestFullscreen) {
                video.requestFullscreen();
            } else if (video.webkitRequestFullscreen) {
                video.webkitRequestFullscreen();
            } else if (video.mozRequestFullScreen) {
                video.mozRequestFullScreen();
            } else if (video.msRequestFullscreen) {
                video.msRequestFullscreen();
            }
        }
        
        function toggleLoop() {
            loopEnabled = !loopEnabled;
            const loopToggle = document.getElementById('loopToggle');
            if (loopEnabled) {
                loopToggle.textContent = ' Loop: ON';
                loopToggle.style.background = 'linear-gradient(145deg, #28a745, #20a045)';
                loopToggle.style.color = 'white';
                console.log('Loop Debug: Loop enabled');
            } else {
                loopToggle.textContent = ' Loop: OFF';
                loopToggle.style.background = '';
                loopToggle.style.color = '';
                console.log('Loop Debug: Loop disabled');
            }
        }
        
        // Global playlist variables
        let playlistMode = null; // 'top-to-bottom', 'bottom-to-top', or null
        let loopEnabled = false; // Loop toggle state
        
        // New playlist control functions
        function playAllTopToBottom() {
            setTimeout(() => {
                console.log('Playlist Debug: playAllTopToBottom started');
                const videoContainer = document.getElementById('video-library-container');
                if (!videoContainer) {
                    console.error('Playlist Debug: Video catalog container not found');
                    return;
                }
                
                const videoItems = videoContainer.querySelectorAll('.video-library-item');
                console.log('Playlist Debug: Found video items:', videoItems.length);
                
                if (!videoItems || videoItems.length === 0) {
                    console.warn('Playlist Debug: No videos found in library');
                    return;
                }
                
                // Set playlist mode
                playlistMode = 'top-to-bottom';
                console.log('Playlist Debug: Set mode to top-to-bottom');
                
                const firstVideo = videoItems[0];
                const playButton = firstVideo.querySelector('.play-btn');
                if (playButton) {
                    console.log('Playlist Debug: Starting first video');
                    playButton.click();
                } else {
                    console.error('Playlist Debug: Could not find play button for first video');
                }
            }, 500); // Increased delay to ensure DOM is ready
        }
        
        function playAllBottomToTop() {
            setTimeout(() => {
                console.log('Playlist Debug: playAllBottomToTop started');
                const videoContainer = document.getElementById('video-library-container');
                if (!videoContainer) {
                    console.error('Playlist Debug: Video catalog container not found');
                    return;
                }
                
                const videoItems = videoContainer.querySelectorAll('.video-library-item');
                console.log('Playlist Debug: Found video items:', videoItems.length);
                
                if (!videoItems || videoItems.length === 0) {
                    console.warn('Playlist Debug: No videos found in library');
                    return;
                }
                
                // Set playlist mode
                playlistMode = 'bottom-to-top';
                console.log('Playlist Debug: Set mode to bottom-to-top');
                
                const lastVideo = videoItems[videoItems.length - 1];
                const playButton = lastVideo.querySelector('.play-btn');
                if (playButton) {
                    console.log('Playlist Debug: Starting last video');
                    playButton.click();
                } else {
                    console.error('Playlist Debug: Could not find play button for last video');
                }
            }, 500); // Increased delay to ensure DOM is ready
        }
        
        function playNextVideo() {
            console.log('Playlist Debug: playNextVideo called');
            const videoContainer = document.getElementById('video-library-container');
            if (!videoContainer) {
                console.error('Playlist Debug: Video catalog container not found in playNextVideo');
                return;
            }
            
            const videoItems = videoContainer.querySelectorAll('.video-library-item');
            console.log('Playlist Debug: Found', videoItems.length, 'video items in playNextVideo');
            
            if (!videoItems || videoItems.length === 0) {
                console.warn('Playlist Debug: No videos found in playNextVideo');
                return;
            }
            
            // Find currently playing video by checking the status text
            const statusText = document.getElementById('current-video-name');
            const currentVideoName = statusText ? statusText.textContent : '';
            console.log('Playlist Debug: Current video name:', currentVideoName);
            
            let currentIndex = -1;
            if (currentVideoName && currentVideoName !== 'No video selected') {
                // Find the current video by name
                videoItems.forEach((item, index) => {
                    const nameSpan = item.querySelector('.video-title');
                    if (nameSpan && nameSpan.textContent === currentVideoName) {
                        currentIndex = index;
                        console.log('Playlist Debug: Found current video at index', index);
                    }
                });
            }
            
            if (currentIndex === -1) {
                console.log('Playlist Debug: No current video found, starting with first');
                // No current video, start with first one
                const firstVideo = videoItems[0];
                const playButton = firstVideo.querySelector('.play-btn');
                if (playButton) {
                    playButton.click();
                }
                return;
            }
            
            if (currentIndex >= videoItems.length - 1) {
                console.log('Playlist Debug: Reached end of playlist, resetting mode');
                playlistMode = null; // Reset playlist mode
                return;
            }
            
            console.log('Playlist Debug: Playing next video at index', currentIndex + 1);
            const nextVideo = videoItems[currentIndex + 1];
            const playButton = nextVideo.querySelector('.play-btn');
            if (playButton) {
                playButton.click();
            } else {
                console.error('Playlist Debug: Could not find play button for next video');
            }
        }
        
        function playPreviousVideo() {
            console.log('Playlist Debug: playPreviousVideo called');
            const videoContainer = document.getElementById('video-library-container');
            if (!videoContainer) {
                console.error('Playlist Debug: Video catalog container not found in playPreviousVideo');
                return;
            }
            
            const videoItems = videoContainer.querySelectorAll('.video-library-item');
            console.log('Playlist Debug: Found', videoItems.length, 'video items in playPreviousVideo');
            
            if (!videoItems || videoItems.length === 0) {
                console.warn('Playlist Debug: No videos found in playPreviousVideo');
                return;
            }
            
            // Find currently playing video by checking the status text
            const statusText = document.getElementById('current-video-name');
            const currentVideoName = statusText ? statusText.textContent : '';
            console.log('Playlist Debug: Current video name:', currentVideoName);
            
            let currentIndex = -1;
            if (currentVideoName && currentVideoName !== 'No video selected') {
                // Find the current video by name
                videoItems.forEach((item, index) => {
                    const nameSpan = item.querySelector('.video-title');
                    if (nameSpan && nameSpan.textContent === currentVideoName) {
                        currentIndex = index;
                        console.log('Playlist Debug: Found current video at index', index);
                    }
                });
            }
            
            if (currentIndex === -1) {
                console.log('Playlist Debug: No current video found, starting with last');
                // No current video, start with last one
                const lastVideo = videoItems[videoItems.length - 1];
                const playButton = lastVideo.querySelector('.play-btn');
                if (playButton) {
                    playButton.click();
                }
                return;
            }
            
            if (currentIndex <= 0) {
                console.log('Playlist Debug: Reached beginning of playlist, resetting mode');
                playlistMode = null; // Reset playlist mode
                return;
            }
            
            console.log('Playlist Debug: Playing previous video at index', currentIndex - 1);
            const previousVideo = videoItems[currentIndex - 1];
            const playButton = previousVideo.querySelector('.play-btn');
            if (playButton) {
                playButton.click();
            } else {
                console.error('Playlist Debug: Could not find play button for previous video');
            }
        }
        
        function showInfoModal(title, message) {
            let modal = document.getElementById('info-modal');
            if (!modal) {
                modal = document.createElement('div');
                modal.id = 'info-modal';
                modal.className = 'modal';
                modal.innerHTML = `
                    <div class="modal-content">
                        <div class="modal-header">
                            <h2 id="info-modal-title">${title}</h2>
                            <button class="close" onclick="closeInfoModal()">&times;</button>
                        </div>
                        <div class="modal-body">
                            <p id="info-modal-message">${message}</p>
                        </div>
                    </div>
                `;
                document.body.appendChild(modal);
            } else {
                document.getElementById('info-modal-title').textContent = title;
                document.getElementById('info-modal-message').textContent = message;
            }
            
            modal.style.display = 'block';
        }
        
        function closeInfoModal() {
            const modal = document.getElementById('info-modal');
            if (modal) {
                modal.style.display = 'none';
            }
        }
        
        function handleVideoEnded() {
            console.log('Playlist Debug: Video ended, current mode:', playlistMode, 'loop enabled:', loopEnabled);
            
            // Check loop first - highest priority (only when no playlist active)
            if (loopEnabled && !playlistMode) {
                console.log('Loop Debug: Looping current video');
                const video = document.getElementById('videoPlayer');
                if (video) {
                    video.currentTime = 0;
                    video.play();
                    updatePlayStatus("playing");
                }
                return;
            }
            
            // Handle custom search playlists
            if (playlistMode === 'search-ascending' || playlistMode === 'search-descending') {
                console.log('Search Playlist Debug: Handling custom playlist progression');
                setTimeout(() => playNextCustomPlaylistVideo(), 500);
                return;
            }
            
            // Then check regular playlist mode
            if (playlistMode === 'top-to-bottom') {
                console.log('Playlist Debug: Auto-playing next video in 500ms');
                // Auto-play next video
                setTimeout(() => playNextVideo(), 500);
            } else if (playlistMode === 'bottom-to-top') {
                console.log('Playlist Debug: Auto-playing previous video in 500ms');
                // Auto-play previous video
                setTimeout(() => playPreviousVideo(), 500);
            } else {
                console.log('Playlist Debug: No playlist mode, video ended normally');
            }
            // If playlistMode is null and loop is off, do nothing (normal single video behavior)
        }

        function playNextCustomPlaylistVideo() {
            if (!window.customPlaylist || window.customPlaylistIndex === undefined) {
                console.log('Search Playlist Debug: No custom playlist found, resetting mode');
                playlistMode = null;
                return;
            }

            window.customPlaylistIndex++;
            
            if (window.customPlaylistIndex >= window.customPlaylist.length) {
                console.log('Search Playlist Debug: Reached end of custom playlist');
                playlistMode = null;
                window.customPlaylist = null;
                window.customPlaylistIndex = 0;
                return;
            }

            const nextVideo = window.customPlaylist[window.customPlaylistIndex];
            console.log('Search Playlist Debug: Playing next video in custom playlist:', nextVideo.name);
            playVideoFromLibrary(nextVideo.name, nextVideo.path);
        }
        
        // Check if video is playing using the same logic as the dashboard
        function isVideoLoaded() {
            // Method 1: Check the status text that shows "Now Playing:"
            const statusText = document.getElementById("status-text");
            if (statusText && statusText.textContent === "Now Playing:") {
                return true;
            }
            
            // Method 2: Check video element state as backup
            const video = document.getElementById('videoPlayer');
            return video && 
                   video.src && 
                   !video.paused && 
                   video.currentTime > 0 && 
                   video.readyState >= 3 && 
                   !video.ended;
        }
        
        // Show warning modal for no video
        function showNoVideoWarning() {
            const modal = document.createElement('div');
            modal.style.cssText = `
                position: fixed;
                top: 0;
                left: 0;
                width: 100%;
                height: 100%;
                background: rgba(0, 0, 0, 0.8);
                display: flex;
                align-items: center;
                justify-content: center;
                z-index: 10000;
            `;
            
            modal.innerHTML = `
                <div style="
                    background: #000;
                    border: 2px solid #ffcc00;
                    border-radius: 15px;
                    padding: 25px;
                    text-align: center;
                    box-shadow: 0 0 30px rgba(255, 204, 0, 0.5);
                    max-width: 400px;
                    margin: 20px;
                ">
                    <div style="color: #ffcc00; font-size: 24px; margin-bottom: 15px;"></div>
                    <div style="color: #ffcc00; font-size: 18px; font-weight: bold; margin-bottom: 10px;">No Video Loaded</div>
                    <div style="color: #ffcc00; font-size: 14px; margin-bottom: 20px; line-height: 1.4;">
                        Please play a video first to use the speed controller buttons.
                    </div>
                    <button onclick="this.closest('div').parentElement.remove()" style="
                        background: linear-gradient(145deg, #ffcc00, #e6b800);
                        color: #000;
                        border: none;
                        padding: 10px 25px;
                        border-radius: 20px;
                        font-size: 14px;
                        font-weight: bold;
                        cursor: pointer;
                        box-shadow: 0 4px 15px rgba(255, 204, 0, 0.3);
                    ">OK</button>
                </div>
            `;
            
            document.body.appendChild(modal);
        }
        
        // Video speed control function
        function setVideoSpeed(speed) {
            // Check if video is loaded
            if (!isVideoLoaded()) {
                showNoVideoWarning();
                return;
            }
            
            const video = document.getElementById('videoPlayer');
            const currentSpeedDisplay = document.getElementById('currentSpeed');
            const speedButtons = document.querySelectorAll('.speed-btn');
            const customSpeedMessage = document.getElementById('customSpeedMessage');
            
            // Set video playback rate
            video.playbackRate = speed;
            
            // Update display
            let displayText;
            if (speed === 1.0) {
                displayText = 'Speed: Normal (1.0x)';
            } else {
                displayText = `Speed: ${speed}x`;
            }
            currentSpeedDisplay.textContent = displayText;
            
            // Hide custom speed message
            customSpeedMessage.style.display = 'none';
            
            // Clear all active states
            speedButtons.forEach(btn => btn.classList.remove('active'));
            
            // Find and activate the clicked button
            speedButtons.forEach(btn => {
                if (btn.onclick && btn.onclick.toString().includes(`setVideoSpeed(${speed})`)) {
                    btn.classList.add('active');
                }
            });
        }
        
        // Custom speed function
        function setCustomSpeed() {
            // Check if video is loaded
            if (!isVideoLoaded()) {
                showNoVideoWarning();
                return;
            }
            
            const input = document.getElementById('customSpeedInput');
            const speed = parseFloat(input.value);
            
            if (isNaN(speed) || speed <= 0 || speed > 20) {
                alert('Please enter a valid speed between 0.01 and 20');
                return;
            }
            
            const video = document.getElementById('videoPlayer');
            const currentSpeedDisplay = document.getElementById('currentSpeed');
            const customSpeedMessage = document.getElementById('customSpeedMessage');
            const speedButtons = document.querySelectorAll('.speed-btn');
            
            // Set video playback rate
            video.playbackRate = speed;
            
            // Update displays
            currentSpeedDisplay.textContent = 'Custom Speed Active';
            customSpeedMessage.textContent = `Now playing at custom speed: ${speed}x`;
            customSpeedMessage.style.display = 'block';
            
            // Clear all button active states
            speedButtons.forEach(btn => btn.classList.remove('active'));
            
            // Clear the input
            input.value = '';
        }
        
        // Allow Enter key to apply custom speed
        document.addEventListener('DOMContentLoaded', function() {
            const customSpeedInput = document.getElementById('customSpeedInput');
            if (customSpeedInput) {
                customSpeedInput.addEventListener('keypress', function(e) {
                    if (e.key === 'Enter') {
                        setCustomSpeed();
                    }
                });
            }
        });
        
        // Set initial speed to normal on page load (without video check)
        document.addEventListener('DOMContentLoaded', function() {
            // Initialize display without triggering video validation
            const currentSpeedDisplay = document.getElementById('currentSpeed');
            if (currentSpeedDisplay) {
                currentSpeedDisplay.textContent = 'Speed: Normal (1.0x)';
            }
            
            // Set normal button as active
            const normalBtn = document.querySelector('.normal-btn');
            if (normalBtn) {
                normalBtn.classList.add('active');
            }
        });
        
        // Modal close functionality
        window.onclick = function(event) {
            const helpModal = document.getElementById('helpModal');
            const uploadModal = document.getElementById('upload-modal');
            if (event.target == helpModal) {
                helpModal.style.display = 'none';
            }
            // Don't allow closing upload modal during upload
            if (event.target == uploadModal && !uploadInProgress) {
                uploadModal.style.display = 'none';
            }
        }
        
        // Handle video ended event
        video.addEventListener('ended', function() {
            updatePlayStatus("stopped");
            handleVideoEnded();
        });

        // General file upload variables
        let generalPendingFiles = [];
        let generalUploadInProgress = false;

        // Setup general file drag and drop functionality
        function setupGeneralDragAndDrop() {
            const dropZone = document.getElementById('general-drop-zone');
            const fileInput = document.getElementById('general-file-input');
            const generalBrowseBtn = document.getElementById('general-browse-btn');
            
            console.log('Setting up general drag and drop...', dropZone, fileInput);
            console.log('General browse button found:', generalBrowseBtn);
            
            if (!dropZone || !fileInput) {
                console.error('General drop zone or file input not found!');
                return;
            }
            
            // Ensure file input has proper attributes for browser dialog
            fileInput.setAttribute('multiple', 'true');
            // File input configured with CSS for proper browser dialog sizing
            
            // Drag and drop events
            dropZone.addEventListener('dragover', (e) => {
                e.preventDefault();
                e.stopPropagation();
                dropZone.classList.add('drag-over');
                console.log('General drag over');
            });
            
            dropZone.addEventListener('dragenter', (e) => {
                e.preventDefault();
                e.stopPropagation();
                dropZone.classList.add('drag-over');
            });
            
            dropZone.addEventListener('dragleave', (e) => {
                e.preventDefault();
                e.stopPropagation();
                if (!dropZone.contains(e.relatedTarget)) {
                    dropZone.classList.remove('drag-over');
                }
            });
            
            dropZone.addEventListener('drop', async (e) => {
                e.preventDefault();
                e.stopPropagation();
                dropZone.classList.remove('drag-over');
                console.log('General files dropped:', e.dataTransfer.files);
                // Check reserve space validation for general drag & drop
                const files = Array.from(e.dataTransfer.files);
                const allFiles = [...generalPendingFiles, ...files];
                const reserveCheck = await checkReserveSpaceAvailability(allFiles);
                if (!reserveCheck.isValid) {
                    console.log('General drag & drop reserve validation FAILED - showing violation modal');
                    const totalSizeGB = (allFiles.reduce((sum, file) => sum + file.size, 0) / (1024 * 1024 * 1024)).toFixed(2);
                    const reserveGB = reserveCheck.reservedGB.toFixed(2);
                    const remainingGB = reserveCheck.remainingGB.toFixed(2);
                    
                    // Show detailed reserve violation modal
                    showReserveViolationModal(
                        totalSizeGB,
                        reserveGB, 
                        remainingGB,
                        generalPendingFiles.length,
                        files.length,
                        files
                    );
                    return;
                }
                
                await handleGeneralFileSelection(files);
            });
            
            // Drop zone click
            dropZone.addEventListener('click', (e) => {
                if (!e.target.classList.contains('browse-btn') && e.target.tagName !== 'LABEL') {
                    console.log('General drop zone clicked');
                    e.preventDefault();
                    fileInput.click();
                }
            });
            
            // File input change
            fileInput.addEventListener('change', async (e) => {
                console.log('General file input changed:', e.target.files);
                if (e.target.files.length === 0) {
                    console.log('No files selected (user canceled)');
                    return;
                }
                
                const files = Array.from(e.target.files);
                
                // IMMEDIATE reserve space validation for total upload (existing pending + new files)
                console.log('=== GENERAL RESERVE VALIDATION AT FILE SELECTION ===');
                console.log('Current general pending files:', generalPendingFiles.length);
                console.log('New general files selected:', files.length);
                
                const allFiles = [...generalPendingFiles, ...files];
                console.log('Total general files if added:', allFiles.length);
                
                const reserveCheck = await checkReserveSpaceAvailability(allFiles);
                if (!reserveCheck.isValid) {
                    console.log('GENERAL RESERVE VALIDATION FAILED - blocking file addition');
                    const totalSizeGB = (allFiles.reduce((sum, file) => sum + file.size, 0) / (1024 * 1024 * 1024)).toFixed(2);
                    const reserveGB = reserveCheck.reservedGB.toFixed(2);
                    const remainingGB = reserveCheck.remainingGB.toFixed(2);
                    
                    // Show detailed reserve violation modal
                    showReserveViolationModal(
                        totalSizeGB,
                        reserveGB, 
                        remainingGB,
                        generalPendingFiles.length,
                        files.length,
                        files
                    );
                    e.target.value = '';
                    return;
                }
                console.log('GENERAL RESERVE VALIDATION PASSED - allowing file addition');
                console.log('=== END GENERAL RESERVE VALIDATION ===');
                
                await handleGeneralFileSelection(files);
                e.target.value = '';
            });
        }

        function handleGeneralFileSelection(files) {
            console.log('Handling general file selection:', files);
            
            if (generalUploadInProgress) {
                showError('Please wait for the current upload to complete before starting a new one.', 'Upload In Progress');;
                return;
            }
            
            if (files.length === 0) {
                showError('No files selected.');
                return;
            }
            
            // Add all files (no filtering for general upload)
            console.log('DEBUG: Adding', files.length, 'general files to generalPendingFiles');
            console.log('DEBUG: generalPendingFiles before concat:', generalPendingFiles.length);
            generalPendingFiles = generalPendingFiles.concat(files);
            console.log('DEBUG: generalPendingFiles after concat:', generalPendingFiles.length);
            
            showSuccessModal(
                'Files Ready for Upload',
                `${generalPendingFiles.length} file(s) selected and ready for general upload.`,
                generalPendingFiles.map(f => f.name),
                null,
                generalPendingFiles
            );
            console.log('DEBUG: About to call displayGeneralFilePreview()');
            displayGeneralFilePreview();
            
            // Run reserve space validation in background
            setTimeout(async () => {
                const reserveCheck = await checkReserveSpaceAvailability(files);
                if (!reserveCheck.isValid) {
                    showInsufficientReserveModal(reserveCheck.reservedGB, reserveCheck.uploadSizeGB, reserveCheck.remainingGB);
                }
            }, 500);
        }

        function displayGeneralFilePreview() {
            console.log('DEBUG: displayGeneralFilePreview called, generalPendingFiles.length:', generalPendingFiles.length);
            const container = document.getElementById('general-file-preview-container');
            const list = document.getElementById('general-file-preview-list');
            
            console.log('DEBUG: general container element:', container);
            console.log('DEBUG: general list element:', list);
            
            if (generalPendingFiles.length === 0) {
                console.log('DEBUG: No general pending files, hiding container');
                if (container) container.style.display = 'none';
                return;
            }
            
            console.log('DEBUG: Showing general container with', generalPendingFiles.length, 'files');
            if (container) container.style.display = 'block';
            
            let html = '';
            let totalSize = 0;
            
            generalPendingFiles.forEach((file, index) => {
                const sizeMB = (file.size / (1024 * 1024)).toFixed(2);
                totalSize += file.size;
                
                // Get file type icon
                let fileIcon = ''; // default
                if (file.type.startsWith('image/')) fileIcon = '';
                else if (file.type.startsWith('video/')) fileIcon = '';
                else if (file.type.startsWith('audio/')) fileIcon = '';
                else if (file.type.includes('pdf')) fileIcon = '';
                else if (file.type.includes('zip') || file.type.includes('archive')) fileIcon = '';
                else if (file.type.includes('text')) fileIcon = '';
                
                html += `
                    <div class="file-preview-item">
                        <div class="file-preview-icon">${fileIcon}</div>
                        <div class="file-preview-info">
                            <div class="file-preview-name">${file.name}</div>
                            <div class="file-preview-size">${sizeMB} MB  ${file.type || 'Unknown type'}</div>
                            <div class="progress-bar-container" id="general-progress-${index}">
                                <div class="progress-bar" id="general-progress-bar-${index}"></div>
                            </div>
                        </div>
                        <div class="file-preview-actions">
                            <button class="remove-file-btn" onclick="removeGeneralFile(${index})" title="Delete">&times;</button>
                        </div>
                    </div>
                `;
            });
            
            const totalSizeMB = (totalSize / (1024 * 1024)).toFixed(2);
            
            // Calculate remaining space after upload
            let remainingSpaceText = '';
            if (storageInfo && storageInfo.available) {
                const remainingBytes = storageInfo.available - totalSize;
                const remainingGB = (remainingBytes / (1024 * 1024 * 1024)).toFixed(2);
                const remainingMB = (remainingBytes / (1024 * 1024)).toFixed(2);
                
                if (remainingBytes >= 1024 * 1024 * 1024) {
                    remainingSpaceText = ` | Remaining after upload: ${remainingGB} GB`;
                } else {
                    remainingSpaceText = ` | Remaining after upload: ${remainingMB} MB`;
                }
            }
            
            html = `<div style="margin-bottom: 15px; color: #17a2b8;"><strong>Total: ${generalPendingFiles.length} files, ${totalSizeMB} MB${remainingSpaceText}</strong></div>` + html;
            
            list.innerHTML = html;
        }

        async function removeGeneralFile(index) {
            generalPendingFiles.splice(index, 1);
            
            // Refresh storage info after file removal
            console.log("General file removed, refreshing storage data...");
            await loadStorageInfo();
            
            // Recalculate reserve space after file removal
            if (generalPendingFiles.length > 0) {
                const reserveCheck = await checkReserveSpaceAvailability(generalPendingFiles);
                
                if (!reserveCheck.isValid) {
                    // Still exceeds reserve space after removal
                    showInsufficientReserveModal(reserveCheck.reservedGB, reserveCheck.uploadSizeGB, reserveCheck.remainingGB);
                } else {
                    // Now within reserve space limits
                    const reserveConfig = await getReserveConfig();
                    const reservedValue = reserveConfig ? parseFloat(reserveConfig.reserved_value) || 0 : 0;
                    showUploadSpaceValidModal(reservedValue, reserveCheck.uploadSizeGB || 0, reserveCheck.remainingGB || 0);
                }
            }
            
            displayGeneralFilePreview();
        }

        function cancelGeneralUpload() {
            generalPendingFiles = [];
            displayGeneralFilePreview();
            document.getElementById('general-file-input').value = '';
        }

        async function confirmGeneralUpload() {
            if (generalPendingFiles.length === 0) return;
            
            // Reset upload stats for new upload session
            uploadStats = {
                startTime: null,
                endTime: null,
                totalBytes: 0,
                completedFiles: []
            };
            
            generalUploadInProgress = true;
            const modal = document.getElementById('general-upload-modal');
            const progressContainer = document.getElementById('general-upload-progress-container');
            
            modal.style.display = 'block';
            
            let html = '<h3 id="general-upload-progress-header"> Uploading Files - Uploaded: 0 | Total files to upload: ' + generalPendingFiles.length + '...</h3>';
            generalPendingFiles.forEach((file, index) => {
                html += `
                    <div style="margin: 15px 0; padding: 15px; background: rgba(0,0,0,0.3); border-radius: 10px;">
                        <div style="display: flex; justify-content: space-between; margin-bottom: 10px;">
                            <span>${file.name}</span>
                            <span id="general-status-${index}"> Preparing...</span>
                        </div>
                        <div style="display: flex; justify-content: space-between; margin-bottom: 20px; font-size: 0.9em; color: white;">
                            <span id="general-percentage-${index}">0%</span>
                            <span id="general-speed-${index}">--</span>
                        </div>
                        <div style="width: 100%; background: rgba(0,0,0,0.3); border-radius: 5px; overflow: hidden;">
                            <div id="general-upload-progress-${index}" style="height: 10px; background: linear-gradient(90deg, #17a2b8, #28a745); width: 0%; transition: none;"></div>
                        </div>
                    </div>
                `;
            });
            
            progressContainer.innerHTML = html;
            
            // Upload files one by one
            for (let i = 0; i < generalPendingFiles.length; i++) {
                await uploadGeneralFile(generalPendingFiles[i], i);
            }
            
            // Upload complete - show OK button in progress modal
            console.log("All general uploads complete - showing OK button");
            
            // Show OK button in the progress modal
            const modalFooter = document.getElementById('general-upload-modal-footer');
            if (modalFooter) {
                modalFooter.style.display = 'block';
                console.log("OK button shown in general upload modal");
            }
        }

        function uploadGeneralFile(file, index) {
            console.log("DEBUG: uploadGeneralFile called for:", file.name);
            return new Promise((resolve, reject) => {
                const formData = new FormData();
                
                // Log file upload with specific details
                logAction(
                    "User uploaded file: " + file.name,
                    "File size: " + (file.size / 1024 / 1024).toFixed(2) + " MB  |  Type: " + file.type + " | Target: random_files/",
                    "/api/general-upload",
                    "POST"
                );
                formData.append('file', file);
                formData.append('destination', 'random_files');
                
                const progressBar = document.getElementById(`general-upload-progress-${index}`);
                const statusSpan = document.getElementById(`general-status-${index}`);
                const percentageSpan = document.getElementById(`general-percentage-${index}`);
                const speedSpan = document.getElementById(`general-speed-${index}`);
                const progressContainer = progressBar.parentElement;
                
                const xhr = new XMLHttpRequest();
                
                // Track upload speed and statistics
                let startTime = Date.now();
                let uploadStartDate = new Date();
                let lastTime = startTime;
                let lastLoaded = 0;
                
                // Initialize upload stats if not exists
                if (!uploadStats.startTime) {
                    uploadStats.startTime = uploadStartDate;
                    uploadStats.totalBytes = 0;
                    uploadStats.completedFiles = [];
                }
                uploadStats.totalBytes += file.size;
                
                // Upload progress event
                xhr.upload.addEventListener('progress', (event) => {
                    if (event.lengthComputable) {
                        const percentage = Math.round((event.loaded / event.total) * 100);
                        const currentTime = Date.now();
                        const elapsedTime = (currentTime - lastTime) / 1000; // seconds
                        const bytesTransferred = event.loaded - lastLoaded;
                        
                        // Update progress bar and percentage with enhanced styling
                        progressBar.style.width = percentage + '%';
                        percentageSpan.innerHTML = `<span style="font-size: 16px; font-weight: bold; color: #22c55e;">${percentage}%</span>`;
                        statusSpan.textContent = ' Uploading...';
                        
                        // Update uploaded data display in MB
                        const dataSizeSpan = document.getElementById(`data-size-${index}`);
                        if (dataSizeSpan) {
                            const uploadedMB = (event.loaded / 1024 / 1024).toFixed(1);
                            const totalMB = (event.total / 1024 / 1024).toFixed(1);
                            dataSizeSpan.textContent = `${uploadedMB} MB / ${totalMB} MB`;
                        }
                        
                        // Calculate and display speed (only update every 500ms to avoid flickering)
                        if (elapsedTime >= 0.5) {
                            const speed = bytesTransferred / elapsedTime; // bytes per second
                            let speedText;
                            
                            if (speed < 1024) {
                                speedText = speed.toFixed(0) + ' B/s';
                            } else if (speed < 1024 * 1024) {
                                speedText = (speed / 1024).toFixed(1) + ' KB/s';
                            } else {
                                speedText = (speed / (1024 * 1024)).toFixed(1) + ' MB/s';
                            }
                            
                            // Single speed display only
                            speedSpan.textContent = speedText;
                            lastTime = currentTime;
                            lastLoaded = event.loaded;
                        }
                    }
                });
                
                // Upload completion event
                xhr.addEventListener('load', () => {
                    if (xhr.status >= 200 && xhr.status < 300) {
                        try {
                            const result = JSON.parse(xhr.responseText);
                            console.log('General upload success:', result);
                            progressBar.style.width = '100%';
                            percentageSpan.textContent = '100%';
                            statusSpan.textContent = ' Complete';
                            speedSpan.textContent = 'Done';
                            
                            // Track upload statistics
                            let endTime = Date.now();
                            let uploadEndDate = new Date();
                            let duration = (endTime - startTime) / 1000; // seconds
                            
                            uploadStats.completedFiles.push({
                                name: file.name,
                                size: file.size,
                                startTime: uploadStartDate.toLocaleTimeString(),
                                endTime: uploadEndDate.toLocaleTimeString(),
                                duration: duration
                            });
                            
                            uploadStats.endTime = uploadEndDate;
                            
                            // Update general upload progress header counter
                            const headerElement = document.getElementById('general-upload-progress-header');
                            if (headerElement) {
                                headerElement.textContent = ` Uploading Files - Uploaded: ${uploadStats.completedFiles.length} | Total files to upload: ${generalPendingFiles.length}...`;
                            }
                            
                            // Add enhanced completion statistics below progress bar
                            const statsDiv = document.createElement('div');
                            statsDiv.style.cssText = `
                                background: linear-gradient(135deg, #1e293b, #334155);
                                color: #fff;
                                padding: 15px;
                                margin-top: 8px;
                                border-radius: 8px;
                                font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
                                font-size: 13px;
                                line-height: 1.6;
                                border: 1px solid #475569;
                                box-shadow: 0 4px 6px rgba(0, 0, 0, 0.1);
                            `;
                            const throughput = file.size > 0 && duration > 0 ? (file.size * 8 / duration / 1000000).toFixed(1) : '0';
                            const durationFormatted = `${Math.floor(duration / 60)}:${String(Math.floor(duration % 60)).padStart(2, '0')}`;
                            statsDiv.innerHTML = `
                                <div style="display: grid; grid-template-columns: 1fr 1fr; gap: 12px; font-weight: 500;">
                                    <div>
                                        <div style="color: #22c55e; font-size: 12px; margin-bottom: 2px;"> STARTED</div>
                                        <div style="font-size: 14px; font-weight: 600;">${uploadStartDate.toLocaleTimeString()}</div>
                                    </div>
                                    <div>
                                        <div style="color: #3b82f6; font-size: 12px; margin-bottom: 2px;"> COMPLETED</div>
                                        <div style="font-size: 14px; font-weight: 600;">${uploadEndDate.toLocaleTimeString()}</div>
                                    </div>
                                    <div>
                                        <div style="color: #f59e0b; font-size: 12px; margin-bottom: 2px;"> DURATION</div>
                                        <div style="font-size: 14px; font-weight: 600;">${durationFormatted}</div>
                                    </div>
                                    <div>
                                        <div style="color: #ef4444; font-size: 12px; margin-bottom: 2px;"> AVERAGE SPEED</div>
                                        <div style="font-size: 14px; font-weight: 600;">${throughput} Mbps</div>
                                    </div>
                                </div>
                                <div style="margin-top: 8px; padding-top: 8px; border-top: 1px solid #475569; text-align: center;">
                                    <span style="color: #94a3b8; font-size: 12px;"> Size: </span>
                                    <span style="color: #fff; font-weight: 600;">${(file.size / (1024 * 1024)).toFixed(1)} MB</span>
                                </div>
                            `;
                            progressContainer.appendChild(statsDiv);
                            
                            resolve(result);
                        } catch (error) {
                            console.error('Error parsing response:', error);
                            statusSpan.textContent = ' Failed';
                            progressBar.style.background = '#dc3545';
                            speedSpan.textContent = 'Error';
                            reject(new Error('Invalid server response'));
                        }
                    } else {
                        // File size restrictions removed - allow all uploads based on client-side reserve value check only
                        // (413 error handling disabled per user request)
                        
                        console.error('General upload failed:', xhr.status, xhr.responseText);
                        statusSpan.textContent = ' Failed';
                        progressBar.style.background = '#dc3545';
                        speedSpan.textContent = 'Error';
                        reject(new Error(`Upload failed: ${xhr.status} - ${xhr.responseText}`));
                    }
                });
                
                // Upload error event
                xhr.addEventListener('error', () => {
                    console.error('General upload error:', xhr.statusText);
                    statusSpan.textContent = ' Failed';
                    progressBar.style.background = '#dc3545';
                    speedSpan.textContent = 'Error';
                    reject(new Error('Upload failed: Network error'));
                });
                
                // Upload abort event
                xhr.addEventListener('abort', () => {
                    console.log('General upload aborted');
                    statusSpan.textContent = ' Aborted';
                    progressBar.style.background = '#ffc107';
                    speedSpan.textContent = 'Aborted';
                    reject(new Error('Upload aborted'));
                });
                
                // Setup request
                xhr.open('POST', '/api/general-upload');
                xhr.setRequestHeader('Authorization', window.authHeaders.Authorization);
                
                // Start upload
                statusSpan.textContent = ' Starting...';
                xhr.send(formData);
            });
        }

        function closeGeneralUploadModal() {
            document.getElementById('general-upload-modal').style.display = 'none';
            generalUploadInProgress = false;
        }

        // Refresh Random Files Data Functions
        // Directory-specific file caches
        let directoryCache = {};
        
        async function refreshDirectoryData() {
            const modal = document.getElementById('refreshDataModal');
            const modalBody = document.getElementById('refreshDataModalBody');
            
            // Show modal with loading state
            modal.style.display = 'block';
            modalBody.innerHTML = '<div class="loading">Refreshing directory data...</div>';
            
            try {
                // Store previous files for comparison (if any)
                const cacheKey = currentPath || '/home/gus';
                const previousFiles = directoryCache[cacheKey] || [];
                const previousCount = previousFiles.length;
                
                // Fetch fresh data from API for current directory
                const response = await fetch(`/api/list?path=${encodeURIComponent(currentPath || '/home/gus')}`, {
                    headers: window.authHeaders
                });
                
                if (!response.ok) {
                    throw new Error(`HTTP ${response.status}: ${response.statusText}`);
                }
                
                const data = await response.json();
                const currentFiles = data.files || [];
                const currentCount = currentFiles.length;
                
                // Find new files (files that exist now but didn't exist before)
                const newFiles = currentFiles.filter(currentFile => 
                    !previousFiles.some(prevFile => prevFile.name === currentFile.name)
                );
                
                // Find removed files (files that existed before but don't exist now)
                const removedFiles = previousFiles.filter(prevFile => 
                    !currentFiles.some(currentFile => currentFile.name === prevFile.name)
                );
                
                // Update cache with current state
                directoryCache[cacheKey] = currentFiles;
                
                console.log('Directory refresh comparison:', {
                    directory: currentPath,
                    previousCount,
                    currentCount,
                    newFilesFound: newFiles.length,
                    removedFilesCount: removedFiles.length,
                    newFileNames: newFiles.map(f => f.name),
                    removedFileNames: removedFiles.map(f => f.name)
                });
                
                // Generate modal content
                let modalContent = `
                    <div class="refresh-summary">
                        <div class="file-count-display"> Directory: ${currentPath || '/home/gus'}</div>
                        <div class="file-count-display"> Total Files: ${currentCount}</div>
                        <div style="color: #94a3b8; margin-bottom: 15px;">
                            Previous: ${previousCount} files | Current: ${currentCount} files
                        </div>
                        <div style="color: #aaa; font-size: 0.9em;">
                            Refreshed: ${new Date().toLocaleString()}
                        </div>
                    </div>
                `;
                
                // Show changes (new or removed files)
                if (newFiles.length > 0 || removedFiles.length > 0) {
                    if (newFiles.length > 0) {
                        modalContent += `
                            <div class="new-files-section">
                                <div class="new-files-header">
                                    <span> New Files Detected</span>
                                    <span style="color: #90EE90;">${newFiles.length} new file${newFiles.length > 1 ? 's' : ''}</span>
                                </div>
                        `;
                        
                        newFiles.forEach(file => {
                            modalContent += `<div class="new-file-item">${file.name} <span style="color: #28a745;">(${file.size})</span></div>`;
                        });
                        
                        modalContent += '</div>';
                    }
                    
                    if (removedFiles.length > 0) {
                        modalContent += `
                            <div class="removed-files-section">
                                <div class="removed-files-header">
                                    <span> Files Removed</span>
                                    <span style="color: #dc2626;">${removedFiles.length} removed file${removedFiles.length > 1 ? 's' : ''}</span>
                                </div>
                        `;
                        
                        removedFiles.forEach(file => {
                            modalContent += `<div class="removed-file-item" style="color: #dc2626;">${file.name} <span style="color: #888;">(deleted)</span></div>`;
                        });
                        
                        modalContent += '</div>';
                    }
                } else if (previousCount === 0 && currentCount > 0) {
                    // First time seeing files
                    modalContent += `
                        <div style="background: rgba(71, 85, 105, 0.1); border-radius: 10px; padding: 20px; margin: 20px 0; border-left: 4px solid #475569; text-align: center;">
            display: flex;
            align-items: center;
            gap: 20px;
                            <div style="color: #94a3b8; font-size: 1.1em; font-weight: 600;">
                                 Files Found
                            </div>
                            <div style="color: #aaa; margin-top: 10px;">
                                Found ${currentCount} existing file${currentCount > 1 ? 's' : ''} in directory
                            </div>
                        </div>
                    `;
                } else if (previousCount > 0) {
                    // No changes since last refresh
                    modalContent += `
                        <div style="background: rgba(255, 193, 7, 0.1); border-radius: 10px; padding: 20px; margin: 20px 0; border-left: 4px solid #ffc107; text-align: center;">
            display: flex;
            align-items: center;
            gap: 20px;
                            <div style="color: #ffc107; font-size: 1.1em; font-weight: 600;">
                                 No changes detected
                            </div>
                            <div style="color: #aaa; margin-top: 10px;">
                                Directory contents unchanged since last refresh
                            </div>
                        </div>
                    `;
                }
                
                // Show all files dropdown if there are files
                if (currentFiles.length > 0) {
                    modalContent += `
                        <div class="all-files-section">
                            <div class="all-files-header" onclick="toggleFilesDropdown()">
                                <span> All Files in ${currentPath || '/home/gus'}</span>
                                <span class="dropdown-toggle" id="dropdownToggle"></span>
                            </div>
                            <div class="file-dropdown" id="filesDropdown">
                    `;
                    
                    currentFiles.forEach(file => {
                        modalContent += `<div class="file-item">${file.name} <span style="color: #888;">(${file.size || 'N/A'})</span></div>`;
                    });
                    
                    modalContent += '</div></div>';
                } else {
                    modalContent += `
                        <div style="background: rgba(220, 53, 69, 0.1); border-radius: 10px; padding: 20px; margin: 20px 0; border-left: 4px solid #dc3545; text-align: center;">
            display: flex;
            align-items: center;
            gap: 20px;
                            <div style="color: #dc3545; font-size: 1.1em; font-weight: 600;">
                                 Directory is empty
                            </div>
                            <div style="color: #aaa; margin-top: 10px;">
                                No files found in ${currentPath || '/home/gus'}
                            </div>
                        </div>
                    `;
                }
                
                modalBody.innerHTML = modalContent;
                
                // Refresh the current directory display
                await navigateTo(currentPath);
                
            } catch (error) {
                modalBody.innerHTML = `
                    <div style="background: rgba(220, 53, 69, 0.1); border-radius: 10px; padding: 20px; text-align: center; border-left: 4px solid #dc3545;">
            display: flex;
            align-items: center;
            gap: 20px;
                        <div style="color: #dc3545; font-size: 1.2em; font-weight: 600; margin-bottom: 10px;">
                             Error Refreshing Data
                        </div>
                        <div style="color: #aaa;">
                            ${error.message}
                        </div>
                        <div style="color: #666; font-size: 0.9em; margin-top: 10px;">
                            Make sure the directory ${currentPath || '/home/gus'} exists on the server
                        </div>
                    </div>
                `;
            }
        }
        
        function closeRefreshDataModal() {
            document.getElementById('refreshDataModal').style.display = 'none';
        }
        
        function toggleFilesDropdown() {
            const dropdown = document.getElementById('filesDropdown');
            const toggle = document.getElementById('dropdownToggle');
            
            if (dropdown && toggle) {
                dropdown.classList.toggle('open');
                toggle.classList.toggle('open');
            }
        }
        
        // Close refresh modal when clicking outside
        document.addEventListener('click', (event) => {
            const modal = document.getElementById('refreshDataModal');
            if (event.target === modal) {
                closeRefreshDataModal();
            }
        });

        // Real Terminal with xterm.js and WebSocket
        let terminal = null;
        let terminalSocket = null;
        let fitAddon = null;
        
        // Terminal Modal Functions
        async function openTerminalModal() {
            console.log('Opening Shell-in-a-Box terminal');
            
            // Detect OS to provide better error handling
            let osType = 'unknown';
            try {
                const osResponse = await fetch('/api/detect-os', {
                    method: 'POST',
                    headers: { ...window.authHeaders, 'Content-Type': 'application/json' }
                });
                if (osResponse.ok) {
                    const osData = await osResponse.json();
                    osType = osData.os_type || 'unknown';
                }
            } catch (error) {
                console.log('OS detection failed:', error);
            }
            
            // Open Shell-in-a-Box in a new tab
            const terminalUrl = `http://${window.location.hostname}:4200/`;
            console.log('Opening terminal URL:', terminalUrl, '(OS:', osType + ')');
            
            // Open in new tab with specific features
            const newTab = window.open(terminalUrl, '_blank', 'width=1200,height=800,scrollbars=yes,resizable=yes');
            
            if (newTab) {
                // Focus the new tab
                newTab.focus();
                console.log('Terminal opened successfully in new tab');
            } else {
                console.error('Failed to open terminal window');
                let errorMessage = `Failed to open terminal window. This could be due to:
        
 Popup blocker preventing new window
 Terminal service not running on port 4200
 Network connection issues`;

                if (osType === 'centos') {
                    errorMessage += `

For CentOS/RHEL systems, try these commands:
 Check service: sudo systemctl status shellinaboxd
 Start service: sudo systemctl start shellinaboxd  
 Enable service: sudo systemctl enable shellinaboxd
 Check port: sudo netstat -tlnp | grep :4200
 Check firewall: sudo firewall-cmd --list-ports | grep 4200`;
                } else {
                    errorMessage += `

For Ubuntu/Debian systems, try these commands:
 Check service: sudo systemctl status shellinabox
 Start service: sudo systemctl start shellinabox
 Enable service: sudo systemctl enable shellinabox
 Check port: sudo netstat -tlnp | grep :4200
 Check firewall: sudo ufw status | grep 4200`;
                }
                
                alert(errorMessage);
            }
        }

        // API Modal Functions
        function openApiModal() {
            alert("API button clicked!"); alert("Button clicked - opening API console"); console.log("Opening API Testing Console");
            
            // Open API Console in a new tab
            const apiUrl = `http://${window.location.hostname}:9090/api_console.html`;
            console.log("Opening API console URL:", apiUrl);
            
            // Open in new tab with specific features
            const newTab = window.open(apiUrl, "_blank", "width=1200,height=900,scrollbars=yes,resizable=yes");
            
            if (newTab) {
                // Focus the new tab
                newTab.focus();
                console.log("API Console opened successfully in new tab");
            } else {
                alert("Please allow popups for this site to open the API console, or manually navigate to: " + apiUrl);
            }
        }

        function closeTerminalModal() {
            console.log('Closing terminal modal');
            const modal = document.getElementById('terminal-modal');
            if (modal) {
                modal.classList.remove('show');
                modal.style.display = 'none';
            }
            
            if (terminalSocket) {
                terminalSocket.close();
                terminalSocket = null;
            }
            
            // Clear terminal reference
            if (terminal) {
                terminal.dispose();
                terminal = null;
            }
        }

        function initializeTerminal() {
            try {
                console.log('Initializing terminal...');
                
                // Check if xterm.js is loaded
                if (typeof Terminal === 'undefined') {
                    alert('xterm.js not loaded! Check CDN connection.');
                    return;
                }
                
                // Create simple terminal
                terminal = new Terminal({
                    cursorBlink: true,
                    fontSize: 14,
                    theme: {
                        background: '#000000',
                        foreground: '#ffffff'
                    }
                });

                const container = document.getElementById('xterm-container');
                if (!container) {
                    alert('Terminal container not found!');
                    return;
                }
                
                terminal.open(container);
                
                // Write test message
                terminal.write('Terminal initialized successfully!\r\n');
                terminal.write('Connecting to server...\r\n');
                
                // Connect to WebSocket
                connectToTerminal();
                
                // Handle terminal input
                terminal.onData((data) => {
                    if (terminalSocket && terminalSocket.readyState === WebSocket.OPEN) {
                        terminalSocket.send(JSON.stringify({
                            type: 'input',
                            data: data
                        }));
                    }
                });
                
                console.log('Terminal initialized successfully');
                
            } catch (error) {
                console.error('Error initializing terminal:', error);
                alert('Error initializing terminal: ' + error.message);
            }
        }

        function connectToTerminal() {
            const protocol = window.location.protocol === 'https:' ? 'wss:' : 'ws:';
            const wsUrl = `${protocol}//${window.location.hostname}:9091/`;
            
            console.log('Connecting to terminal WebSocket:', wsUrl);
            terminal.write('\r\n\x1b[33m[Attempting WebSocket connection to ' + wsUrl + ']\x1b[0m\r\n');
            
            // Add connection timeout
            const connectionTimeout = setTimeout(() => {
                if (terminalSocket && terminalSocket.readyState === WebSocket.CONNECTING) {
                    terminalSocket.close();
                    terminal.write('\r\n\x1b[31m[Connection timeout - server may be down]\x1b[0m\r\n');
                    terminal.write('\r\n\x1b[33m[Please check if terminal server is running on port 9091]\x1b[0m\r\n');
                }
            }, 10000); // 10 second timeout
            
            terminalSocket = new WebSocket(wsUrl);
            
            terminalSocket.onopen = () => {
                clearTimeout(connectionTimeout);
                console.log('Terminal WebSocket connected successfully');
                
                // Check if auth token exists
                const authToken = localStorage.getItem('authToken');
                if (!authToken) {
                    terminal.write('\r\n\x1b[31m[No auth token found - please refresh page and login]\x1b[0m\r\n');
                    return;
                }
                
                console.log('Sending authentication token:', authToken.substring(0, 10) + '...');
                
                // Send authentication token
                terminalSocket.send(JSON.stringify({
                    type: 'auth',
                    token: authToken
                }));
                
                terminal.write('\r\n\x1b[32m[WebSocket connected successfully - authenticating...]\x1b[0m\r\n');
            };
            
            terminalSocket.onmessage = (event) => {
                try {
                    const message = JSON.parse(event.data);
                    
                    if (message.type === 'output') {
                        terminal.write(message.data);
                    } else if (message.type === 'error') {
                        terminal.write(`\r\n\x1b[31mServer Error: ${message.message}\x1b[0m\r\n`);
                    } else {
                    
                        console.log('Unknown message type:', message.type);
                    }
                } catch (e) {
                    console.error('Error parsing WebSocket message:', e);
                    terminal.write('\r\n\x1b[31m[Message parsing error]\x1b[0m\r\n');
                }
            };
            
            terminalSocket.onclose = (event) => {
                clearTimeout(connectionTimeout);
                console.log('Terminal WebSocket disconnected. Code:', event.code, 'Reason:', event.reason);
                terminal.write('\r\n\x1b[31m[Connection closed - Code: ' + event.code + ']\x1b[0m\r\n');
                
                // Offer reconnection option
                if (event.code !== 1000) { // 1000 = normal closure
                    terminal.write('\r\n\x1b[33m[Connection lost unexpectedly. Type "reconnect" to try again]\x1b[0m\r\n');
                }
            };
            
            terminalSocket.onerror = (error) => {
                clearTimeout(connectionTimeout);
                console.error('Terminal WebSocket error:', error);
                terminal.write('\r\n\x1b[31m[WebSocket connection failed]\x1b[0m\r\n');
                terminal.write('\r\n\x1b[33m[Check if terminal server is running on port 9091]\x1b[0m\r\n');
            };
        }

        function sendQuickCommand(command) {
            console.log('Sending command:', command);
            
            // Handle special reconnect command
            if (command === 'reconnect') {
                terminal.write('\r\n\x1b[33m[Attempting to reconnect...]\x1b[0m\r\n');
                connectToTerminal();
                return;
            }
            
            if (terminalSocket && terminalSocket.readyState === WebSocket.OPEN) {
                // Send command followed by Enter
                terminalSocket.send(JSON.stringify({
                    type: 'input',
                    data: command + '\r'
                }));
                console.log('Command sent successfully');
            } else {
                    
                console.error('Terminal WebSocket not connected. State:', terminalSocket ? terminalSocket.readyState : 'null');
                terminal.write('\r\n\x1b[31m[Not connected - cannot send command]\x1b[0m\r\n');
                terminal.write('\r\n\x1b[33m[Click a command button to auto-reconnect]\x1b[0m\r\n');
                
                // Try to reconnect if not connected
                if (!terminalSocket || terminalSocket.readyState === WebSocket.CLOSED) {
                    console.log('Attempting to reconnect...');
                    terminal.write('\r\n\x1b[33m[Attempting to reconnect...]\x1b[0m\r\n');
                    connectToTerminal();
                }
            }
        }

        // Close modal when clicking outside or pressing Escape
        document.addEventListener('click', function(event) {
            const modal = document.getElementById('terminal-modal');
            if (event.target === modal) {
                closeTerminalModal();
            }
        });

        document.addEventListener('keydown', function(event) {
            if (event.key === 'Escape') {
                closeTerminalModal();
                closeSystemSpecs();
            }
        });

        // System IP Functions
        async function fetchSystemIP() {
            try {
                const response = await fetch('/api/system-specs', {
                    method: 'POST',
                    headers: {
                        ...window.authHeaders,
                        'Content-Type': 'application/json'
                    }
                });
                
                if (response.ok) {
                    const data = await response.json();
                    // Extract hostname from curl examples or system info
                    let serverHost = 'gcppftest01'; // Default from curl commands
                    
                    // Try to extract from curl examples if available
                    if (data.curl_examples) {
                        const curlMatch = data.curl_examples.match(/http:\/\/([^:\/]+)/);
                        if (curlMatch) {
                            serverHost = curlMatch[1];
                        }
                    }
                    
                    // Check if it's already an IP address (contains only digits and dots)
                    if (/^\d+\.\d+\.\d+\.\d+$/.test(serverHost)) {
                        updateSystemIPDisplay(serverHost);
                        return;
                    }
                    
                    // Try to resolve FQDN to IP using a simple approach
                    try {
                        // Attempt to resolve via browser (this may not work in all cases)
                        const ipResponse = await fetch('https://dns.google/resolve?name=' + serverHost + '&type=A');
                        if (ipResponse.ok) {
                            const dnsData = await ipResponse.json();
                            if (dnsData.Answer && dnsData.Answer.length > 0) {
                                updateSystemIPDisplay(dnsData.Answer[0].data);
                                return;
                            }
                        }
                    } catch (e) {
                        console.log('DNS resolution failed, using hostname');
                    }
                    
                    // Fallback: just display the hostname/FQDN
                    updateSystemIPDisplay(serverHost);
                } else {
                    updateSystemIPDisplay('gcppftest01');
                }
            } catch (error) {
                console.error('Error fetching system IP:', error);
                updateSystemIPDisplay('gcppftest01');
            }
        }
        
        function updateSystemIPDisplay(ip) {
            const display = document.getElementById('system-ip-display');
            if (display) {
                display.textContent = 'System IP/FQDN: ' + ip;
            }
        }

        // System Specs Functions
        async function showSystemSpecs() {
            const modal = document.getElementById('system-specs-modal');
            const terminal = document.getElementById('system-specs-terminal');
            const loading = document.getElementById('system-specs-loading');

            // Debug: Check if elements exist
            console.log('System Specs Debug:', {
                modal: modal,
                terminal: terminal,
                loading: loading
            });

            if (!modal || !terminal || !loading) {
                console.error('System specs elements not found!', {
                    modal: !!modal,
                    terminal: !!terminal,
                    loading: !!loading
                });
                return;
            }

            // Show modal and loading state
            modal.style.display = 'block';
            loading.style.display = 'block';
            
            try {
                // Fetch system specifications
                const response = await fetch('/api/system-specs', {
                    method: 'POST',
                    headers: {
                        ...window.authHeaders,
                        'Content-Type': 'application/json'
                    }
                });
                
                if (!response.ok) {
                    throw new Error('HTTP ' + response.status + ': ' + response.statusText);
                }
                
                const data = await response.json();
                
                // Hide loading
                loading.style.display = 'none';
                
                // Parse and display the system specs
                displaySystemSpecs(data);
                
            } catch (error) {
                loading.style.display = 'none';
                terminal.innerHTML = '<div style="color: #ff0000; text-align: center; padding: 50px;"> Error loading system specifications<br><br>' + error.message + '<br><br>Please check your connection and try again.</div>';
            }
        }
        
        function closeSystemSpecs() {
            document.getElementById('system-specs-modal').style.display = 'none';
        }
        
        // Add OS detection for system specs
        async function detectOS() {
            try {
                const response = await fetch('/api/detect-os', {
                    method: 'POST',
                    headers: {
                        ...window.authHeaders,
                        'Content-Type': 'application/json'
                    }
                });
                
                if (response.ok) {
                    const osData = await response.json();
                    return osData.os_type || 'unknown';
                }
            } catch (error) {
                console.log('OS detection failed, assuming Ubuntu');
            }
            return 'ubuntu'; // default fallback
        }

        function displaySystemSpecs(data) {
            const terminal = document.getElementById('system-specs-terminal');
            let output = '';
            
            // Add header with green separators
            output += '<span class="section-separator">================================================================================\n';
            output += '                           LINUX SYSTEM SPECIFICATIONS\n';
            output += '================================================================================</span>\n\n';
            
            // Show timestamp
            const timestamp = new Date(data.timestamp * 1000).toLocaleString();
            output += 'Scan Date: ' + timestamp + '\n';
            output += 'Method: ' + (data.method || 'System commands') + '\n';
            output += 'Response Time: ' + data.response_time + 'ms\n\n';
            
            // Parse inxi output properly
            if (data.inxi_available && data.inxi_output) {
                output += createStyledSection('PARSED SYSTEM ANALYSIS', parseInxiOutput(data.inxi_output));
            }
            
            // System Information (Enhanced)
            if (data.system) {
                let systemInfo = '';
                if (data.system.hostname) systemInfo += formatKeyValue('Hostname', cleanOutput(data.system.hostname));
                if (data.system.kernel) {
                    const kernelInfo = cleanOutput(data.system.kernel);
                    const kernelParts = kernelInfo.split(' ');
                    systemInfo += formatKeyValue('Kernel Version', kernelParts[2] || 'Unknown');
                    systemInfo += formatKeyValue('Architecture', kernelParts[4] || 'Unknown');
                }
                if (data.system.uptime) {
                    const uptimeInfo = parseUptime(data.system.uptime);
                    systemInfo += formatKeyValue('System Uptime', uptimeInfo);
                }
                if (data.system.os_release) {
                    const osInfo = parseOsRelease(data.system.os_release);
                    systemInfo += osInfo;
                }
                if (systemInfo) output += createStyledSection('SYSTEM INFORMATION', systemInfo);
            }
            
            // Enhanced Hardware Information
            if (data.hardware && data.hardware.cpuinfo) {
                const cpuInfo = parseCpuInfo(data.hardware.cpuinfo);
                if (cpuInfo) output += createStyledSection('PROCESSOR INFORMATION', cpuInfo);
            }
            
            // Enhanced Memory Information with free -h equivalent
            if (data.memory) {
                let memoryInfo = parseMemoryInfo(data.memory);
                if (memoryInfo) output += createStyledSection('MEMORY & STORAGE ANALYSIS', memoryInfo);
            }
            
            // Enhanced Network Information
            if (data.network) {
                let networkInfo = parseNetworkInfo(data.network);
                if (networkInfo) output += createStyledSection('NETWORK CONFIGURATION', networkInfo);
            }
            
            // Additional System Details
            output += createStyledSection('ADDITIONAL SYSTEM DETAILS', getAdditionalDetails(data));
            
            // Show any errors
            if (data.error) {
                output += createStyledSection('SYSTEM ERRORS', '<span style="color: #ff4444;">Error occurred: ' + cleanOutput(data.error) + '</span>');
            }
            
            terminal.innerHTML = output;
        }
        
        function parseInxiOutput(inxiText) {
            if (!inxiText) return 'No inxi data available';
            
            let parsed = '';
            
            // Clean the inxi text - remove unwanted characters and markers
            let cleanInxi = inxiText
                .replace(/12/g, ' ') // Remove the "12" markers
                .replace(/\s+/g, ' ') // Normalize whitespace
                .replace(/[^\x20-\x7E]/g, '') // Remove non-printable characters
                .trim();
            
            // Parse different sections with better formatting
            const sectionParsers = {
                'System:': function(content) {
                    let systemData = '';
                    if (content.includes('Kernel')) {
                        const kernelMatch = content.match(/Kernel\s+([^\s]+)/);
                        if (kernelMatch) systemData += formatKeyValue('Kernel', kernelMatch[1]);
                    }
                    if (content.includes('Distro')) {
                        const distroMatch = content.match(/Distro\s+(.+?)(?:\s+Machine:|$)/);
                        if (distroMatch) systemData += formatKeyValue('Distribution', distroMatch[1].trim());
                    }
                    if (content.includes('bits')) {
                        const bitsMatch = content.match(/bits\s+(\d+)/);
                        if (bitsMatch) systemData += formatKeyValue('Architecture', bitsMatch[1] + '-bit');
                    }
                    return systemData;
                },
                'Machine:': function(content) {
                    let machineData = '';
                    if (content.includes('Type')) {
                        const typeMatch = content.match(/Type\s+([^\s]+)/);
                        if (typeMatch) machineData += formatKeyValue('Machine Type', typeMatch[1]);
                    }
                    if (content.includes('Mobo')) {
                        const moboMatch = content.match(/Mobo\s+([^\s]+)/);
                        if (moboMatch) machineData += formatKeyValue('Motherboard', moboMatch[1]);
                    }
                    if (content.includes('model')) {
                        const modelMatch = content.match(/model\s+([^s]+?)(?:\s+serial|$)/);
                        if (modelMatch) machineData += formatKeyValue('Model', modelMatch[1].trim());
                    }
                    return machineData;
                },
                'CPU:': function(content) {
                    let cpuData = '';
                    if (content.includes('model')) {
                        const modelMatch = content.match(/model\s+([^b]+?)(?:\s+bits|$)/);
                        if (modelMatch) cpuData += formatKeyValue('CPU Model', modelMatch[1].trim());
                    }
                    if (content.includes('arch')) {
                        const archMatch = content.match(/arch\s+([^\s]+)/);
                        if (archMatch) cpuData += formatKeyValue('Architecture', archMatch[1]);
                    }
                    if (content.includes('Speed')) {
                        const speedMatch = content.match(/Speed\s+(\d+\s+MHz)/);
                        if (speedMatch) cpuData += formatKeyValue('CPU Speed', speedMatch[1]);
                    }
                    if (content.includes('cache')) {
                        const cacheMatch = content.match(/cache\s+([^f]+?)(?:\s+flags|$)/);
                        if (cacheMatch) cpuData += formatKeyValue('L2 Cache', cacheMatch[1].trim());
                    }
                    if (content.includes('flags')) {
                        const flagsMatch = content.match(/flags\s+([^b]+?)(?:\s+bogomips|$)/);
                        if (flagsMatch) {
                            const flags = flagsMatch[1].trim().split(' ').slice(0, 8); // First 8 flags
                            cpuData += formatKeyValue('CPU Features', flags.join(', '));
                        }
                    }
                    return cpuData;
                },
                'Network:': function(content) {
                    let netData = '';
                    if (content.includes('Device-')) {
                        const devices = content.split('Device-').slice(1);
                        devices.forEach(function(device, index) {
                            netData += formatKeyValue('Network Device ' + (index + 1), 'Present');
                            if (device.includes('driver')) {
                                const driverMatch = device.match(/driver\s+([^\s]+)/);
                                if (driverMatch) netData += formatKeyValue('  Driver', driverMatch[1]);
                            }
                            if (device.includes('IF')) {
                                const ifMatch = device.match(/IF\s+([^\s]+)/);
                                if (ifMatch) netData += formatKeyValue('  Interface', ifMatch[1]);
                            }
                            if (device.includes('state')) {
                                const stateMatch = device.match(/state\s+([^\s]+)/);
                                if (stateMatch) netData += formatKeyValue('  State', stateMatch[1].toUpperCase());
                            }
                        });
                    }
                    return netData;
                },
                'Drives:': function(content) {
                    let driveData = '';
                    if (content.includes('total')) {
                        const totalMatch = content.match(/total\s+([^u]+?)(?:\s+used|$)/);
                        if (totalMatch) driveData += formatKeyValue('Total Storage', totalMatch[1].trim());
                    }
                    if (content.includes('used')) {
                        const usedMatch = content.match(/used\s+([^I]+?)(?:\s+ID-|$)/);
                        if (usedMatch) driveData += formatKeyValue('Used Storage', usedMatch[1].trim());
                    }
                    if (content.includes('model')) {
                        const modelMatch = content.match(/model\s+([^s]+?)(?:\s+size|$)/);
                        if (modelMatch) driveData += formatKeyValue('Primary Drive', modelMatch[1].trim());
                    }
                    return driveData;
                },
                'Info:': function(content) {
                    let infoData = '';
                    if (content.includes('Processes')) {
                        const processMatch = content.match(/Processes\s+(\d+)/);
                        if (processMatch) infoData += formatKeyValue('Running Processes', processMatch[1]);
                    }
                    if (content.includes('Uptime')) {
                        const uptimeMatch = content.match(/Uptime\s+([^M]+?)(?:\s+Memory|$)/);
                        if (uptimeMatch) infoData += formatKeyValue('System Uptime', uptimeMatch[1].trim());
                    }
                    if (content.includes('Memory')) {
                        const memMatch = content.match(/Memory\s+([^u]+?)(?:\s+used|$)/);
                        if (memMatch) infoData += formatKeyValue('Total Memory', memMatch[1].trim());
                    }
                    if (content.includes('Init')) {
                        const initMatch = content.match(/Init\s+([^\s]+)/);
                        if (initMatch) infoData += formatKeyValue('Init System', initMatch[1]);
                    }
                    return infoData;
                }
            };
            
            // Process each section
            Object.keys(sectionParsers).forEach(function(sectionName) {
                if (cleanInxi.includes(sectionName)) {
                    const sectionStart = cleanInxi.indexOf(sectionName);
                    let sectionEnd = cleanInxi.length;
                    
                    // Find next section
                    Object.keys(sectionParsers).forEach(function(otherSection) {
                        if (otherSection !== sectionName) {
                            const nextPos = cleanInxi.indexOf(otherSection, sectionStart + 1);
                            if (nextPos > sectionStart && nextPos < sectionEnd) {
                                sectionEnd = nextPos;
                            }
                        }
                    });
                    
                    const sectionContent = cleanInxi.substring(sectionStart + sectionName.length, sectionEnd).trim();
                    const parsedSection = sectionParsers[sectionName](sectionContent);
                    
                    if (parsedSection) {
                        parsed += '\n<span class="section-title">' + sectionName.replace(':', '') + ' Details:</span>\n' + parsedSection + '\n';
                    }
                }
            });
            
            return parsed || 'Unable to parse inxi data properly';
        }
        
        function parseCpuInfo(cpuText) {
            const lines = cpuText.split('\n');
            let cpuInfo = '';
            let cpuModel = '';
            let cpuCores = '';
            let cpuMHz = '';
            let cacheSize = '';
            let flags = [];
            
            lines.forEach(function(line) {
                const trimmed = line.trim();
                if (trimmed.includes('model name') && !cpuModel) {
                    cpuModel = trimmed.split(':')[1]?.trim() || '';
                } else if (trimmed.includes('cpu cores')) {
                    cpuCores = trimmed.split(':')[1]?.trim() || '';
                } else if (trimmed.includes('cpu MHz')) {
                    cpuMHz = trimmed.split(':')[1]?.trim() || '';
                } else if (trimmed.includes('cache size')) {
                    cacheSize = trimmed.split(':')[1]?.trim() || '';
                } else if (trimmed.includes('flags')) {
                    const flagsStr = trimmed.split(':')[1]?.trim() || '';
                    flags = flagsStr.split(' ').slice(0, 10); // First 10 flags
                }
            });
            
            if (cpuModel) cpuInfo += formatKeyValue('Processor Model', cpuModel);
            if (cpuCores) cpuInfo += formatKeyValue('CPU Cores', cpuCores);
            if (cpuMHz) cpuInfo += formatKeyValue('CPU Frequency', cpuMHz + ' MHz');
            if (cacheSize) cpuInfo += formatKeyValue('Cache Size', cacheSize);
            if (flags.length > 0) cpuInfo += formatKeyValue('CPU Features', flags.join(', '));
            
            return cpuInfo;
        }
        
        function parseMemoryInfo(memData) {
            let memInfo = '';
            
            // Parse meminfo for free -h equivalent
            if (memData.meminfo) {
                const lines = memData.meminfo.split('\n');
                let totalMem = 0, freeMem = 0, availableMem = 0, buffers = 0, cached = 0;
                
                lines.forEach(function(line) {
                    const parts = line.split(':');
                    if (parts.length === 2) {
                        const key = parts[0].trim();
                        const value = parseInt(parts[1].trim().split(' ')[0]) || 0;
                        
                        if (key === 'MemTotal') totalMem = value;
                        else if (key === 'MemFree') freeMem = value;
                        else if (key === 'MemAvailable') availableMem = value;
                        else if (key === 'Buffers') buffers = value;
                        else if (key === 'Cached') cached = value;
                    }
                });
                
                if (totalMem > 0) {
                    const usedMem = totalMem - freeMem;
                    const usedPercentage = ((usedMem / totalMem) * 100).toFixed(1);
                    
                    memInfo += formatKeyValue('Total Memory', formatBytes(totalMem * 1024));
                    memInfo += formatKeyValue('Used Memory', formatBytes(usedMem * 1024) + ' (' + usedPercentage + '%)');
                    memInfo += formatKeyValue('Free Memory', formatBytes(freeMem * 1024));
                    memInfo += formatKeyValue('Available Memory', formatBytes(availableMem * 1024));
                    memInfo += formatKeyValue('Buffers', formatBytes(buffers * 1024));
                    memInfo += formatKeyValue('Cached', formatBytes(cached * 1024));
                }
            }
            
            // Enhanced disk usage
            if (memData.disk_usage) {
                memInfo += '\n<span class="section-title">DISK USAGE ANALYSIS</span>\n';
                const diskLines = memData.disk_usage.split('\n');
                diskLines.forEach(function(line) {
                    if (line.trim() && !line.includes('Filesystem') && !line.includes('tmpfs') && !line.includes('loop')) {
                        const parts = line.trim().split(/\s+/);
                        if (parts.length >= 6) {
                            memInfo += formatKeyValue('Device', parts[0]);
                            memInfo += formatKeyValue('  Size', parts[1]);
                            memInfo += formatKeyValue('  Used', parts[2] + ' (' + parts[4] + ')');
                            memInfo += formatKeyValue('  Available', parts[3]);
                            memInfo += formatKeyValue('  Mount Point', parts[5]);
                            memInfo += '\n';
                        }
                    }
                });
            }
            
            return memInfo;
        }
        
        function parseNetworkInfo(netData) {
            let netInfo = '';
            
            if (netData.interfaces) {
                const lines = netData.interfaces.split('\n');
                let currentInterface = '';
                
                lines.forEach(function(line) {
                    const trimmed = line.trim();
                    if (trimmed.match(/^\d+:/)) {
                        // Interface header
                        currentInterface = trimmed.split(':')[1]?.split(' ')[0] || '';
                        if (currentInterface !== 'lo') {
                            netInfo += formatKeyValue('Interface', currentInterface);
                            const status = trimmed.includes('UP') ? 'UP' : 'DOWN';
                            netInfo += formatKeyValue('  Status', status);
                        }
                    } else if (trimmed.includes('inet ') && !trimmed.includes('127.0.0.1')) {
                        const ipMatch = trimmed.match(/inet (\d+\.\d+\.\d+\.\d+)/);
                        if (ipMatch) {
                            netInfo += formatKeyValue('  IP Address', ipMatch[1]);
                        }
                    } else if (trimmed.includes('link/ether')) {
                        const macMatch = trimmed.match(/link\/ether ([a-f0-9:]{17})/);
                        if (macMatch) {
                            netInfo += formatKeyValue('  MAC Address', macMatch[1].toUpperCase());
                        }
                    }
                });
            }
            
            if (netData.routing) {
                netInfo += '\n<span class="section-title">ROUTING INFORMATION</span>\n';
                const routeLines = netData.routing.split('\n');
                routeLines.forEach(function(line) {
                    if (line.includes('default via')) {
                        const parts = line.split(' ');
                        const gateway = parts[2];
                        const interface = parts[4];
                        netInfo += formatKeyValue('Default Gateway', gateway + ' (via ' + interface + ')');
                    }
                });
            }
            
            return netInfo;
        }
        
        function parseOsRelease(osText) {
            let osInfo = '';
            const lines = osText.split('\n');
            
            lines.forEach(function(line) {
                if (line.includes('=')) {
                    const parts = line.split('=');
                    const key = parts[0].trim();
                    const value = parts[1]?.replace(/"/g, '').trim() || '';
                    
                    if (key === 'PRETTY_NAME') osInfo += formatKeyValue('Distribution', value);
                    else if (key === 'VERSION_ID') osInfo += formatKeyValue('Version', value);
                    else if (key === 'VERSION_CODENAME') osInfo += formatKeyValue('Codename', value);
                }
            });
            
            return osInfo;
        }
        
        function parseUptime(uptimeText) {
            const match = uptimeText.match(/up\s+(.+?),\s+\d+\s+user/);
            return match ? match[1] : uptimeText;
        }
        
        function getAdditionalDetails(data) {
            let details = '';
            
            if (data.inxi_available) {
                details += formatKeyValue('System Analysis Tool', 'inxi -Fx (Advanced)');
            } else {
                details += formatKeyValue('System Analysis Tool', 'Basic system commands');
            }
            
            details += formatKeyValue('Scan Timestamp', new Date().toISOString());
            details += formatKeyValue('Data Collection Time', data.response_time + ' milliseconds');
            
            return details;
        }
        
        function formatKeyValue(key, value) {
            return '<span style="color: #cccccc; font-weight: bold;">' + key + ':</span> <span style="color: white;">' + value + '</span>\n';
        }
        
        function formatBytes(bytes) {
            if (bytes === 0) return '0 B';
            const k = 1024;
            const sizes = ['B', 'KB', 'MB', 'GB', 'TB'];
            const i = Math.floor(Math.log(bytes) / Math.log(k));
            return parseFloat((bytes / Math.pow(k, i)).toFixed(2)) + ' ' + sizes[i];
        }
        
        function createStyledSection(title, content) {
            return '\n<span class="section-separator">================================================================================\n' + title + '\n================================================================================</span>\n' + content + '\n\n';
        }
        
        function cleanOutput(text) {
            if (!text) return '';
            // Remove ANSI color codes and other special characters
            return text
                .replace(/\x1b\[[0-9;]*m/g, '') // Remove ANSI codes
                .replace(/[\x00-\x1f\x7f-\x9f]/g, '') // Remove control characters
                .replace(/&/g, '&amp;')
                .replace(/</g, '&lt;')
                .replace(/>/g, '&gt;')
                .replace(/"/g, '&quot;')
                .replace(/'/g, '&#39;');
        }
    </script>

    <!-- Terminal Modal -->
    <div id="terminal-modal" class="terminal-modal">
        <div class="terminal-window">
            <div class="terminal-header">
                <div class="terminal-title">
                     Linux Terminal
                </div>
                <button class="terminal-close-btn" onclick="closeTerminalModal()">
                    
                </button>
            </div>
            <div class="terminal-body">
                <div class="terminal-controls">
                    <div class="quick-commands">
                        <button class="quick-cmd-btn" onclick="sendQuickCommand('ls -la')">ls -la</button>
                        <button class="quick-cmd-btn" onclick="sendQuickCommand('pwd')">pwd</button>
                        <button class="quick-cmd-btn" onclick="sendQuickCommand('df -h')">df -h</button>
                        <button class="quick-cmd-btn" onclick="sendQuickCommand('ps aux')">ps aux</button>
                        <button class="quick-cmd-btn" onclick="sendQuickCommand('free -h')">free -h</button>
                        <button class="quick-cmd-btn" onclick="sendQuickCommand('htop')">htop</button>
                        <button class="quick-cmd-btn clear-btn" onclick="sendQuickCommand('clear')">Clear</button>
                    </div>
                </div>
                <!-- Real Terminal using xterm.js -->
                <div id="xterm-container" class="xterm-container"></div>
            </div>
        </div>
    </div>

    <!-- Load xterm.js from CDN -->
    <script src="https://cdn.jsdelivr.net/npm/xterm@5.3.0/lib/xterm.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/xterm-addon-fit@0.8.0/lib/xterm-addon-fit.js"></script>

<div id="api-modal" style="display:none; position:fixed; z-index:9999; left:0; top:0; width:100%; height:100%; background-color:rgba(0,0,0,0.5);">
  <div style="background-color:#1a1a2e; margin:10% auto; padding:20px; border:2px solid #e94560; width:80%; max-width:600px; border-radius:10px;">
    <div style="color:#e94560; display:flex; justify-content:space-between; align-items:center; margin-bottom:20px;">
      <h3> API Testing Console</h3>
      <span onclick="closeApiModal()" style="cursor:pointer; font-size:24px; color:#e94560;">&times;</span>
    </div>
    <div style="margin-bottom:15px;">
      <label style="color:#e94560; display:inline-block; width:80px;">Username:</label>
      <input type="text" id="api-username" placeholder="Enter username" style="padding:8px; background:#0f0a1a; border:1px solid #16213e; color:#f39c12; margin-left:10px;">
    </div>
    <div style="margin-bottom:15px;">
      <label style="color:#e94560; display:inline-block; width:80px;">Password:</label>
      <input type="password" id="api-password" placeholder="Enter password" style="padding:8px; background:#0f0a1a; border:1px solid #16213e; color:#f39c12; margin-left:10px;">
    </div>
    <div style="margin:15px 0;">
      <button onclick="executeApiCall(auth)" style="margin:5px; padding:10px; background:#16213e; border:1px solid #e94560; color:#e94560; cursor:pointer;"> Auth</button>
      <button onclick="executeApiCall(videos)" style="margin:5px; padding:10px; background:#16213e; border:1px solid #e94560; color:#e94560; cursor:pointer;"> Videos</button>
      <button onclick="executeApiCall(list)" style="margin:5px; padding:10px; background:#16213e; border:1px solid #e94560; color:#e94560; cursor:pointer;"> List Files</button>
    </div>
    <div>
      <div id="api-command" style="background:#0f0a1a; padding:10px; color:#f39c12; font-family:monospace; margin-bottom:10px;">Ready to execute API calls...</div>
      <pre id="api-result" style="background:#000; color:#00ff00; padding:10px; min-height:100px; font-family:monospace; overflow:auto;">Output will appear here...</pre>
    </div>
  </div>
</div>
<script>
function openApiConsole() {
    alert("Button clicked - opening API console"); console.log("Opening API Testing Console");
    const apiUrl = "http://gcppftest01:9090/api_console.html";
    const newWindow = window.open(apiUrl, "_blank", "width=1200,height=900,scrollbars=yes,resizable=yes");
    if (newWindow) {
        newWindow.focus();
        console.log("API Console opened successfully in new window");
    } else {
        alert("Please allow popups for this site to open the API console, or manually navigate to: " + apiUrl);
    }
}

        // Simple debug logging function
        function logAction(action, details, endpoint, method) {
            const token = sessionStorage.getItem("authToken");
            if (!token) return;
            
            fetch("/api/log-action", {
                method: "POST",
                headers: {
                    "Content-Type": "application/json",
                    "Authorization": "Bearer " + token
                },
                body: JSON.stringify({
                    action: action,
                    details: details || "",
                    endpoint: endpoint || "",
                    method: method || "GET"
                })
            }).catch(e => console.log("Log error:", e));

        function logVideoPlay(filename, fullPath, fileSize) {
            const token = sessionStorage.getItem("authToken");
            if (!token) return;
            
            fetch("/api/log-video-play", {
                method: "POST",
                headers: {
                    "Content-Type": "application/json",
                    "Authorization": "Bearer " + token
                },
                body: JSON.stringify({
                    filename: filename,
                    path: fullPath,
                    size: fileSize,
                    duration: "unknown"
                })
            }).catch(e => console.log("Video play log error:", e));
        }
        }

        async function openQuotaConfig(section) {
            console.log("openQuotaConfig called for section: " + section);
            
            try {
                const response = await fetch("/api/storage", {
                    headers: window.authHeaders
                });
                
                if (response.ok) {
                    const data = await response.json();
                    const totalGB = (data.total / (1024 * 1024 * 1024)).toFixed(2);
                    const usedGB = (data.used / (1024 * 1024 * 1024)).toFixed(2);
                    const uploadLimitGB = (data.upload_limit / (1024 * 1024 * 1024)).toFixed(2);
                    
                    console.log("Got storage data: Total=" + totalGB + "GB, Used=" + usedGB + "GB, Upload Limit=" + uploadLimitGB + "GB");
                    
                    // Update the file with real storage data
                    const updateResponse = await fetch("/api/storage_reserve_value_update", {
                        method: "POST",
                        headers: {
                            "Content-Type": "application/json",
                            ...window.authHeaders
                        },
                        body: JSON.stringify({
                            total_disk_space: parseFloat(totalGB),
                            used_disk_space: parseFloat(usedGB),
                            reserved_value: 0,
                            upload_limit_value: parseFloat(uploadLimitGB),
                            reserved_value_flag: "True"
                        })
                    });
                    
                    if (updateResponse.ok) {
                        console.log("File updated successfully with real storage data!");
                    } else {
                        console.error("Failed to update file: " + updateResponse.status);
                    }
                    
                } else {
                    console.error("Failed to get storage data: " + response.status);
                }
            } catch (error) {
                console.error("Error: " + error.message);
            }
            
            document.getElementById("reserveQuotaModal").style.display = "block";
        }

	/*
        function setReserveValue() {
            console.log('setReserveValue called!');
            document.getElementById('quotaNotificationSuccess').style.display = 'block';
        }
	*/

        /*
        function setReserveValue() {
           alert('Test alert');
        }
	*/	
		
        async function setReserveValue() {
            const amount = parseFloat(document.getElementById("reserveAmount").value);

            if (!amount || isNaN(amount) || amount <= 0) {
                document.getElementById("errorMessage").textContent = "Please enter a valid reserve amount greater than 0";
                document.getElementById("errorModal").style.display = "block";
                return;
            }

            try {
                // Get current storage data first
                const response = await fetch("/api/storage", {
                    headers: window.authHeaders
                });
                
                if (response.ok) {
                    const data = await response.json();
                    const totalGB = (data.total / (1024 * 1024 * 1024)).toFixed(2);
                    const usedGB = (data.used / (1024 * 1024 * 1024)).toFixed(2);
                    const availableGB = (data.available / (1024 * 1024 * 1024)).toFixed(2);
                    const uploadLimitGB = (availableGB - amount).toFixed(2);
                    
                    // Update the file with the new reserve value
                    const updateResponse = await fetch("/api/storage_reserve_value_update", {
                        method: "POST",
                        headers: {
                            "Content-Type": "application/json",
                            ...window.authHeaders
                        },
                        body: JSON.stringify({
                            total_disk_space: parseFloat(totalGB),
                            used_disk_space: parseFloat(usedGB),
                            reserved_value: amount,
                            upload_limit_value: parseFloat(uploadLimitGB),
                            reserved_value_flag: "False"
                        })
                    });
                    
                    if (updateResponse.ok) {
                        console.log("Reserve value updated successfully in file!");
                        
                        // Show success modal with green text
                        document.querySelector("#reserveSuccessModal h3").style.textShadow = "3px 3px 8px rgba(0,0,0,0.9)";
                        document.getElementById("reserveSuccessMessage").textContent = "Reserve value set to: " + amount + " GB";
                        document.getElementById("reserveSuccessMessage").style.fontWeight = "bold";
                        document.getElementById("reserveSuccessMessage").style.color = "#00ff00";
                        document.getElementById("reserveSuccessModal").style.display = "block";
                        
                        // Refresh storage display after a short delay
                        setTimeout(() => {
                            updateStorageDisplay();
                        }, 1000);
                        
                    } else {
                        console.error("Failed to update reserve value:", updateResponse.status);
                        document.getElementById("errorMessage").textContent = "Failed to save reserve value to file";
                        document.getElementById("errorModal").style.display = "block";
                    }
                } else {
                    console.error("Failed to get storage data:", response.status);
                    document.getElementById("errorMessage").textContent = "Failed to get current storage data";
                    document.getElementById("errorModal").style.display = "block";
                }
            } catch (error) {
                console.error("Error setting reserve value:", error.message);
                document.getElementById("errorMessage").textContent = "Error: " + error.message;
                document.getElementById("errorModal").style.display = "block";
            }
        }

        function closeModal(modalId) {
            document.getElementById(modalId).style.display = "none";
        }
        
        function closeRefreshModal() {
            document.getElementById("refreshSuccessModal").style.display = "none";
        }


        function closeQuotaNotification(notificationId) {
            document.getElementById(notificationId).style.display = 'none';
        }

        async function toggleReserveInput() {
            const checkbox = document.getElementById("reserveNotSetCheckbox");
            const amountInput = document.getElementById("reserveAmount");
            
            if (checkbox && checkbox.checked) {
                // Show warning modal first
                document.getElementById("reserveWarningModal").style.display = "block";
                
                // Disable input and clear value
                amountInput.disabled = true;
                amountInput.value = "";
                
            } else {
                // Checkbox is unchecked - enable input
                amountInput.disabled = false;
                amountInput.focus();
            }
        }

        async function confirmNotSetReserve() {
            // Close warning modal
            document.getElementById("reserveWarningModal").style.display = "none";
            
            try {
                // Get current storage data
                const response = await fetch("/api/storage", {
                    headers: window.authHeaders
                });
                
                if (response.ok) {
                    const data = await response.json();
                    const totalGB = (data.total / (1024 * 1024 * 1024)).toFixed(2);
                    const usedGB = (data.used / (1024 * 1024 * 1024)).toFixed(2);
                    const uploadLimitGB = (data.upload_limit / (1024 * 1024 * 1024)).toFixed(2);
                    
                    // Update file to set NOT SET state
                    const updateResponse = await fetch("/api/storage_reserve_value_update", {
                        method: "POST",
                        headers: {
                            "Content-Type": "application/json",
                            ...window.authHeaders
                        },
                        body: JSON.stringify({
                            total_disk_space: parseFloat(totalGB),
                            used_disk_space: parseFloat(usedGB),
                            reserved_value: 0,
                            upload_limit_value: parseFloat(uploadLimitGB),
                            reserved_value_flag: "True"
                        })
                    });
                    
                    if (updateResponse.ok) {
                        console.log("Reserve value set to NOT SET");
                        // Refresh storage display after a short delay
                        setTimeout(() => {
                            updateStorageDisplay();
                        }, 1000);
                    } else {
                        console.error("Failed to update NOT SET state:", updateResponse.status);
                    }
                }
            } catch (error) {
                console.error("Error setting NOT SET state:", error.message);
            }
        }

        function cancelNotSetReserve() {
            console.log("Cancel button clicked");
            
            // Close warning modal
            const modal = document.getElementById("reserveWarningModal");
            if (modal) {
                modal.style.display = "none";
                console.log("Modal closed");
            }
            
            // Uncheck the checkbox and re-enable input
            const checkbox = document.getElementById("reserveNotSetCheckbox");
            if (checkbox) {
                checkbox.checked = false;
                console.log("Checkbox unchecked");
            }
            
            const amountInput = document.getElementById("reserveAmount");
            if (amountInput) {
                amountInput.disabled = false;
                amountInput.focus();
                console.log("Input re-enabled and focused");
            }
        }

        async function refreshStorageData() {
            console.log(" Refresh button clicked!");
            
            try {
                // First, get real system storage data
                console.log("Fetching real system storage data...");
                const storageResponse = await fetch('/api/storage', {
                    headers: window.authHeaders
                });
                
                if (!storageResponse.ok) {
                    throw new Error('Failed to fetch storage data');
                }
                
                const systemStorage = await storageResponse.json();
                console.log("System storage data:", systemStorage);
                
                // Update the global storageInfo
                storageInfo = systemStorage;
                
                // Calculate actual values
                const totalGB = (systemStorage.total / (1024 * 1024 * 1024)).toFixed(2);
                const usedGB = (systemStorage.used / (1024 * 1024 * 1024)).toFixed(2);
                const availableGB = (systemStorage.available / (1024 * 1024 * 1024)).toFixed(2);
                
                console.log("Actual storage values - Total:", totalGB, "Used:", usedGB, "Available:", availableGB);
                
                // Update the reserved_value.txt file with real system values
                const updateData = {
                    total_disk_space: totalGB,
                    used_disk_space: usedGB,
                    available_disk_space: availableGB
                };
                
                console.log("Updating config file with real system values...");
                const updateResponse = await fetch('/api/storage_reserve_value_update', {
                    method: 'POST',
                    headers: {
                        ...window.authHeaders,
                        'Content-Type': 'application/json'
                    },
                    body: JSON.stringify(updateData)
                });
                
                if (!updateResponse.ok) {
                    console.warn("Failed to update config file, continuing with display update");
                }
                
                // Now fetch the config file to get reserve settings
                console.log("Fetching config file for reserve settings...");
                const configResponse = await fetch("/api/file?path=/home/gus/video-system/docs/reserved_value.txt&t=" + Date.now(), {
                    headers: window.authHeaders
                });
                
                const configContent = await configResponse.text();
                console.log("Config file content:", configContent);
                
                // Parse reserve settings
                let reservedValue = 0;
                let reservedFlag = "True";
                
                const lines = configContent.split('\n');
                lines.forEach(line => {
                    if (line.includes('reserved_value = ') && !line.startsWith('#') && !line.includes('flag') && !line.includes('upload_limit')) {
                        const value = line.split('= ')[1];
                        if (value) {
                            reservedValue = parseFloat(value.trim());
                        }
                    }
                    if (line.includes('reserved_value_flag = ') && !line.startsWith('#')) {
                        const flag = line.split('= ')[1];
                        if (flag) {
                            reservedFlag = flag.trim();
                        }
                    }
                });
                
                console.log("Parsed reserve values:", {reservedValue, reservedFlag});
                
                // Calculate display values using REAL available space
                let reserveText, uploadLimitText;
                
                if (reservedFlag === "False" && reservedValue > 0) {
                    // Reserve is set
                    reserveText = reservedValue + " GB";
                    // Calculate upload limit: Available - Reserved (using REAL available)
                    const uploadLimitGB = (parseFloat(availableGB) - reservedValue).toFixed(2);
                    uploadLimitText = uploadLimitGB + " GB";
                    console.log("RESERVE SET:", reserveText, "Upload limit:", uploadLimitText);
                } else {
                    // Reserve is NOT SET
                    reserveText = " NOT SET";
                    uploadLimitText = availableGB + " GB"; // Full available (REAL value)
                    console.log("RESERVE NOT SET");
                }
                
                // Update all storage displays with real system data
                console.log("Calling updateStorageDisplay with fresh system data...");
                updateStorageDisplay();
                
                // Show success modal with current values
                document.getElementById("refreshModalReserve").textContent = reserveText;
                document.getElementById("refreshModalUpload").textContent = uploadLimitText;
                document.getElementById("refreshModalAvailable").textContent = availableGB + " GB";
                
                // Also update the modal with all current storage info
                const refreshModal = document.getElementById("refreshSuccessModal");
                if (refreshModal) {
                    // Update the modal title and show it
                    refreshModal.style.display = "block";
                    console.log("Refresh success modal displayed");
                }
                
                console.log("Storage refresh completed successfully!");
                
            } catch (error) {
                console.error("Error refreshing storage data:", error);
                alert("Error refreshing data: " + error.message);
            }
        }

        // Video Search Modal Functions
        let searchResults = [];
        let selectedVideoIndices = new Set();
        
        // Delete functionality variables
        let deleteMode = ''; // 'selected' or 'all'
        let videosToDelete = [];
        let videosBeforeDeletion = 0;
        let videosAfterRefresh = 0;

        async function openVideoSearchModal() {
            const modal = document.getElementById('videoSearchModal');
            if (modal && modal.style) {
                modal.style.display = 'block';
                const searchInput = document.getElementById('videoSearchInput');
                if (searchInput) {
                    searchInput.focus();
                }
            } else {
                console.log('Modal not available right now');
                return;
            }
            
            // Load videos for the modal (bypass mode restriction)
            if (!allVideos || allVideos.length === 0) {
                try {
                    const response = await fetch('/api/videos', {
                        headers: window.authHeaders
                    });
                    if (response.ok) {
                        const data = await response.json();
                        allVideos = data.videos || [];
                    }
                } catch (error) {
                    console.error('Failed to load videos for search modal:', error);
                }
            }
            
            // Display all videos when modal opens
            if (allVideos && allVideos.length > 0) {
                searchResults = [...allVideos]; // Copy all videos to searchResults
                
                const videoSearchResults = document.getElementById('videoSearchResults');
                if (videoSearchResults) {
                    videoSearchResults.style.display = 'block';
                    displaySearchResults();
                    
                    // Update search status
                    const searchStatus = document.getElementById('searchStatus');
                    if (searchStatus) {
                        searchStatus.textContent = `Showing all ${allVideos.length} videos`;
                        searchStatus.style.color = '#28a745';
                    }
                } else {
                    console.error('videoSearchResults element not found - modal may be corrupted');
                }
            }
        }

        function closeVideoSearchModal() {
            const modal = document.getElementById('videoSearchModal');
            if (modal) {
                modal.style.display = 'none';
            }
            clearVideoSearch();
        }

        async function refreshVideoMetadata() {
            // Update status to show refreshing
            const searchStatus = document.getElementById('searchStatus');
            searchStatus.textContent = 'Refreshing metadata...';
            searchStatus.style.color = '#ffd700';
            
            // Run clear action rapidly
            clearVideoSearch();
            
            // Force reload videos from server
            allVideos = []; // Clear cached videos
            try {
                const response = await fetch('/api/videos', {
                    headers: window.authHeaders
                });
                if (response.ok) {
                    const data = await response.json();
                    allVideos = data.videos || [];
                    
                    // Display all videos again
                    if (allVideos.length > 0) {
                        searchResults = [...allVideos];
                        document.getElementById('videoSearchResults').style.display = 'block';
                        displaySearchResults();
                        
                        // Update status
                        searchStatus.textContent = `Metadata refreshed! Showing all ${allVideos.length} videos`;
                        searchStatus.style.color = '#28a745';
                    } else {
                        searchStatus.textContent = 'No videos found after refresh';
                        searchStatus.style.color = '#dc3545';
                    }
                } else {
                    throw new Error('Failed to refresh video metadata');
                }
            } catch (error) {
                console.error('Error refreshing video metadata:', error);
                searchStatus.textContent = 'Error refreshing metadata: ' + error.message;
                searchStatus.style.color = '#dc3545';
            }
        }

        function clearVideoSearch() {
            document.getElementById('videoSearchInput').value = '';
            document.getElementById('searchStatus').textContent = '';
            document.getElementById('videoSearchResults').style.display = 'none';
            document.getElementById('playControls').style.display = 'none';
            document.getElementById('deleteControls').style.display = 'none';
            document.getElementById('downloadControls').style.display = 'none';
            searchResults = [];
            selectedVideoIndices.clear();
        }

        function clearPlaylistVideoSearch() {
            const searchInput = document.getElementById('playlistVideoSearchInput');
            if (searchInput) {
                searchInput.value = '';
                searchVideosForPlaylist(); // Refresh to show all videos
            }
        }

        function togglePlaylistVideoSelection(index) {
            const checkbox = document.getElementById(`addVideo_${index}`);
            const videoItem = document.getElementById(`videoItem_${index}`);
            
            if (checkbox && videoItem) {
                // Always keep black background regardless of checkbox state
                videoItem.style.background = '#000000';
            }
        }

        async function searchVideos() {
            const searchTerm = document.getElementById('videoSearchInput').value.trim().toLowerCase();
            const searchStatus = document.getElementById('searchStatus');
            
            if (!searchTerm) {
                searchStatus.textContent = 'Please enter a search term';
                searchStatus.style.color = '#dc3545';
                return;
            }

            searchStatus.textContent = 'Searching...';
            searchStatus.style.color = '#28a745';

            try {
                // Get all videos from the library
                if (!allVideos || allVideos.length === 0) {
                    await loadVideoLibrary();
                }

                // Filter videos based on search term
                searchResults = allVideos.filter(video => {
                    return video.name.toLowerCase().includes(searchTerm) || 
                           video.path.toLowerCase().includes(searchTerm);
                });

                if (searchResults.length === 0) {
                    searchStatus.textContent = `No videos found matching "${searchTerm}"`;
                    searchStatus.style.color = '#dc3545';
                    document.getElementById('videoSearchResults').style.display = 'none';
                    return;
                }

                searchStatus.textContent = `Found ${searchResults.length} video${searchResults.length === 1 ? '' : 's'} matching "${searchTerm}"`;
                searchStatus.style.color = '#28a745';
                
                displaySearchResults();
                document.getElementById('videoSearchResults').style.display = 'block';

            } catch (error) {
                searchStatus.textContent = 'Error searching videos: ' + error.message;
                searchStatus.style.color = '#dc3545';
                console.error('Video search error:', error);
            }
        }

        function displaySearchResults() {
            const videoList = document.getElementById('videoList');
            let html = '';

            searchResults.forEach((video, index) => {
                // Fix size calculation - handle different size formats
                let sizeBytes = 0;
                if (typeof video.size === 'number') {
                    sizeBytes = video.size;
                } else if (typeof video.size === 'string') {
                    // Parse size string if it contains units
                    if (video.size.includes('MB')) {
                        sizeBytes = parseFloat(video.size) * 1024 * 1024;
                    } else if (video.size.includes('GB')) {
                        sizeBytes = parseFloat(video.size) * 1024 * 1024 * 1024;
                    } else if (video.size.includes('KB')) {
                        sizeBytes = parseFloat(video.size) * 1024;
                    } else {
                        sizeBytes = parseInt(video.size) || 0;
                    }
                }
                
                const sizeMB = (sizeBytes / (1024 * 1024)).toFixed(1);
                const sizeGB = (sizeBytes / (1024 * 1024 * 1024)).toFixed(2);
                let sizeText = 'Unknown size';
                
                if (sizeBytes > 0) {
                    sizeText = sizeBytes >= (1024 * 1024 * 1024) ? `${sizeGB} GB` : `${sizeMB} MB`;
                }

                const isSelected = selectedVideoIndices.has(index);
                const thumbnailId = `thumbnail-dl-${index}`;
                
                html += `
                    <div class="video-search-item" 
                         data-search-index="${index}"
                         draggable="true"
                         style="display: flex; align-items: center; padding: 15px; border-bottom: 1px solid #333; background: ${isSelected ? 'rgba(40,167,69,0.1)' : 'transparent'}; transition: all 0.3s ease;">
                        <div class="search-drag-handle" 
                             onmousedown="event.stopPropagation()" 
                             title="Drag to reorder search results"
                             style="cursor: grab; padding: 5px 8px; margin-right: 10px; color: #ffd700; font-size: 16px; opacity: 0.7; transition: all 0.3s ease; user-select: none;"></div>
                        <input type="checkbox" id="video_${index}" ${isSelected ? 'checked' : ''} 
                               onchange="toggleSearchVideoSelection(${index})"
                               style="margin-right: 15px; transform: scale(1.2);">
                        <div class="video-thumbnail-container" id="${thumbnailId}"
                             onmouseenter="handleThumbnailHover('${video.name}', '${video.path}', '${thumbnailId}')"
                             onmouseleave="handleThumbnailLeave('${thumbnailId}')"
                             onclick="handleThumbnailHover('${video.name}', '${video.path}', '${thumbnailId}')"
                             style="margin-right: 15px;">
                            <div class="video-thumbnail-placeholder"></div>
                            <div class="video-thumbnail-loading" style="display: none;">Loading...</div>
                            <video class="video-thumbnail" muted></video>
                        </div>
                        <div style="flex: 1; min-width: 0;">
                            <div style="color: #ffd700; font-weight: bold; margin-bottom: 5px; word-break: break-all; cursor: pointer;" 
                                 onmouseenter="handleThumbnailHover('${video.name}', '${video.path}', '${thumbnailId}')"
                                 onmouseleave="handleThumbnailLeave('${thumbnailId}')"
                                 onclick="handleThumbnailHover('${video.name}', '${video.path}', '${thumbnailId}')">${video.name}</div>
                            <div style="color: #ccc; font-size: 12px; margin-bottom: 3px; word-break: break-all;">${video.path}</div>
                            <div style="color: #28a745; font-size: 14px; font-weight: bold;">${sizeText}</div>
                        </div>
                        <button onclick="playIndividualVideo('${video.name}', '${video.path}')" 
                                class="play-now-btn"
                                style="padding: 8px 15px; background: #000000; color: #28a745; border: 2px solid #28a745; border-radius: 5px; margin-left: 15px; cursor: pointer; transition: all 0.3s ease;">
                             Play Now
                        </button>
                        <button onclick="showDeleteVideoConfirmation('${video.name}', '${video.path}')" 
                                class="delete-video-btn"
                                style="padding: 8px 15px; background: #000000; color: #dc3545; border: 2px solid #dc3545; border-radius: 5px; margin-left: 10px; cursor: pointer; transition: all 0.3s ease;">
                             Delete
                        </button>
                    </div>
                `;
            });

            videoList.innerHTML = html;
            updateSelectedCount();
            setupSearchResultsDragAndDrop();
        }

        function toggleSearchVideoSelection(index) {
            if (selectedVideoIndices.has(index)) {
                selectedVideoIndices.delete(index);
            } else {
                selectedVideoIndices.add(index);
            }
            
            updateSelectedCount();
            displaySearchResults();
            
            // Show/hide play controls, delete controls, and download controls - they should appear at top of results section
            const playControls = document.getElementById('playControls');
            const deleteControls = document.getElementById('deleteControls');
            const downloadControls = document.getElementById('downloadControls');
            if (selectedVideoIndices.size > 0) {
                playControls.style.display = 'block';
                deleteControls.style.display = 'block';
                downloadControls.style.display = 'block';
            } else {
                playControls.style.display = 'none';
                deleteControls.style.display = 'none';
                downloadControls.style.display = 'none';
            }
        }

        function selectAllSearchVideos() {
            selectedVideoIndices.clear();
            searchResults.forEach((_, index) => selectedVideoIndices.add(index));
            displaySearchResults();
            document.getElementById('playControls').style.display = 'block';
            document.getElementById('deleteControls').style.display = 'block';
            document.getElementById('downloadControls').style.display = 'block';
        }

        function deselectAllSearchVideos() {
            selectedVideoIndices.clear();
            displaySearchResults();
            document.getElementById('playControls').style.display = 'none';
            document.getElementById('deleteControls').style.display = 'none';
            document.getElementById('downloadControls').style.display = 'none';
        }

        function goToTop() {
            const videoList = document.getElementById('videoList');
            if (videoList) {
                videoList.scrollTo({ top: 0, behavior: 'smooth' });
            }
        }

        function goToBottom() {
            const videoList = document.getElementById('videoList');
            if (videoList) {
                videoList.scrollTo({ top: videoList.scrollHeight, behavior: 'smooth' });
            }
        }

        function goToMiddle() {
            const videoList = document.getElementById('videoList');
            if (videoList) {
                const middle = videoList.scrollHeight / 2;
                videoList.scrollTo({ top: middle, behavior: 'smooth' });
            }
        }

        function goToPlaylistTop() {
            const playlistContent = document.getElementById('editablePlaylistContent');
            if (playlistContent) {
                playlistContent.scrollTo({ top: 0, behavior: 'smooth' });
            }
        }

        function goToPlaylistBottom() {
            const playlistContent = document.getElementById('editablePlaylistContent');
            if (playlistContent) {
                playlistContent.scrollTo({ top: playlistContent.scrollHeight, behavior: 'smooth' });
            }
        }

        function goToPlaylistMiddle() {
            const playlistContent = document.getElementById('editablePlaylistContent');
            if (playlistContent) {
                const middle = playlistContent.scrollHeight / 2;
                playlistContent.scrollTo({ top: middle, behavior: 'smooth' });
            }
        }

        function goToPlaylistModalTop() {
            const videosContainer = document.querySelector('.playlist-selection-modal .modal-body div[style*="max-height: 400px"]');
            if (videosContainer) {
                videosContainer.scrollTo({ top: 0, behavior: 'smooth' });
            } else {
                // Fallback: scroll the entire modal body
                const modalBody = document.querySelector('.playlist-selection-modal .modal-body');
                if (modalBody) {
                    modalBody.scrollTo({ top: 0, behavior: 'smooth' });
                }
            }
        }

        function goToPlaylistModalBottom() {
            const videosContainer = document.querySelector('.playlist-selection-modal .modal-body div[style*="max-height: 400px"]');
            if (videosContainer) {
                videosContainer.scrollTo({ top: videosContainer.scrollHeight, behavior: 'smooth' });
            } else {
                // Fallback: scroll the entire modal body
                const modalBody = document.querySelector('.playlist-selection-modal .modal-body');
                if (modalBody) {
                    modalBody.scrollTo({ top: modalBody.scrollHeight, behavior: 'smooth' });
                }
            }
        }

        function goToPlaylistModalMiddle() {
            const videosContainer = document.querySelector('.playlist-selection-modal .modal-body div[style*="max-height: 400px"]');
            if (videosContainer) {
                const middle = videosContainer.scrollHeight / 2;
                videosContainer.scrollTo({ top: middle, behavior: 'smooth' });
            } else {
                // Fallback: scroll the entire modal body
                const modalBody = document.querySelector('.playlist-selection-modal .modal-body');
                if (modalBody) {
                    const middle = modalBody.scrollHeight / 2;
                    modalBody.scrollTo({ top: middle, behavior: 'smooth' });
                }
            }
        }

        function togglePlaylistSelection(playlistDiv) {
            const checkbox = playlistDiv.querySelector('input[type="checkbox"]');
            if (checkbox) {
                checkbox.checked = !checkbox.checked;
                // Visual feedback - highlight selected items
                if (checkbox.checked) {
                    playlistDiv.style.background = 'rgba(0,191,255,0.2)';
                } else {
                    playlistDiv.style.background = 'transparent';
                }
                updatePlaylistSelectionCount();
            }
        }

        function selectAllPlaylists() {
            const checkboxes = document.querySelectorAll('.playlist-selection-modal input[type="checkbox"]');
            checkboxes.forEach(checkbox => {
                checkbox.checked = true;
                // Visual feedback
                const playlistDiv = checkbox.closest('.playlist-item');
                if (playlistDiv) {
                    playlistDiv.style.background = 'rgba(0,191,255,0.2)';
                }
            });
            updatePlaylistSelectionCount();
        }

        function unselectAllPlaylists() {
            const checkboxes = document.querySelectorAll('.playlist-selection-modal input[type="checkbox"]');
            checkboxes.forEach(checkbox => {
                checkbox.checked = false;
                // Visual feedback
                const playlistDiv = checkbox.closest('.playlist-item');
                if (playlistDiv) {
                    playlistDiv.style.background = 'transparent';
                }
            });
            updatePlaylistSelectionCount();
        }

        function updatePlaylistSelectionCount() {
            const selectedCheckboxes = document.querySelectorAll('.playlist-selection-modal input[type="checkbox"]:checked');
            const count = selectedCheckboxes.length;
            const countElement = document.getElementById('selectedPlaylistCount');
            if (countElement) {
                countElement.textContent = `Selected amount: ${count}`;
            }
        }

        function handleCheckboxChange(checkbox) {
            const playlistDiv = checkbox.closest('.playlist-item');
            if (playlistDiv) {
                // Visual feedback
                if (checkbox.checked) {
                    playlistDiv.style.background = 'rgba(0,191,255,0.2)';
                } else {
                    playlistDiv.style.background = 'transparent';
                }
            }
            updatePlaylistSelectionCount();
        }

        function getSelectedPlaylists() {
            const selectedPlaylists = [];
            const checkboxes = document.querySelectorAll('.playlist-selection-modal input[type="checkbox"]:checked');
            checkboxes.forEach(checkbox => {
                const playlistDiv = checkbox.closest('.playlist-item');
                if (playlistDiv) {
                    selectedPlaylists.push({
                        name: playlistDiv.getAttribute('data-playlist-name'),
                        displayName: playlistDiv.querySelector('label').textContent
                    });
                }
            });
            return selectedPlaylists;
        }

        async function addToAllPlaylists(type, videos) {
            // Close selection modal
            document.querySelector('.playlist-selection-modal').remove();
            
            // Show loading modal
            showPlaylistLoadingModal();
            
            try {
                // First get all playlists
                const playlistsResponse = await fetch('/api/playlists', {
                    headers: {
                        'Authorization': window.authHeaders.Authorization
                    }
                });
                
                if (!playlistsResponse.ok) {
                    // Close loading modal
                    const loadingModal = document.querySelector('.playlist-loading-modal');
                    if (loadingModal) loadingModal.remove();
                    
                    showPlaylistErrorModal('Failed to Get Playlists', 'Could not retrieve playlist list. Please try again.');
                    return;
                }
                
                const playlistData = await playlistsResponse.json();
                const allPlaylists = playlistData.playlists || [];
                
                if (allPlaylists.length === 0) {
                    // Close loading modal
                    const loadingModal = document.querySelector('.playlist-loading-modal');
                    if (loadingModal) loadingModal.remove();
                    
                    showPlaylistErrorModal('No Playlists Found', 'No playlists available to add videos to.');
                    return;
                }
                
                // Add videos to each playlist using existing API
                let successCount = 0;
                let errorCount = 0;
                
                for (const playlist of allPlaylists) {
                    try {
                        const response = await fetch('/api/add_videos_to_playlist', {
                            method: 'POST',
                            headers: {
                                'Content-Type': 'application/json',
                                'Authorization': window.authHeaders.Authorization
                            },
                            body: JSON.stringify({
                                playlist_name: playlist.name,
                                videos: videos,
                                type: type
                            })
                        });
                        
                        if (response.ok) {
                            successCount++;
                        } else {
                            errorCount++;
                        }
                    } catch (error) {
                        errorCount++;
                        console.error(`Error adding to playlist ${playlist.name}:`, error);
                    }
                }
                
                // Close loading modal
                const loadingModal = document.querySelector('.playlist-loading-modal');
                if (loadingModal) loadingModal.remove();
                
                // Show results with cool modal
                if (errorCount === 0) {
                    showPlaylistSuccessModal('Videos Added to All Playlists!', `Successfully added ${videos.length} video${videos.length === 1 ? '' : 's'} to all ${successCount} playlists.`);
                } else if (successCount === 0) {
                    showPlaylistErrorModal('Addition Failed', 'Failed to add videos to any playlist. Please try again.');
                } else {
                    showPlaylistSuccessModal('Partial Success', `Added videos to ${successCount} of ${allPlaylists.length} playlists. ${errorCount} playlist${errorCount === 1 ? '' : 's'} failed.`);
                }
                
                // Refresh the playlist view if we're currently viewing playlists
                if (typeof currentView !== 'undefined' && currentView === 'playlists') {
                    loadPlaylists();
                }
                
            } catch (error) {
                // Close loading modal
                const loadingModal = document.querySelector('.playlist-loading-modal');
                if (loadingModal) loadingModal.remove();
                
                console.error('Error adding videos to all playlists:', error);
                showPlaylistErrorModal('Addition Failed', 'Failed to add videos to playlists. Please try again.');
            }
        }

        function updateSelectedCount() {
            document.getElementById('selectedCount').textContent = `${selectedVideoIndices.size} selected`;
        }

        function playIndividualVideo(name, path) {
            closeVideoSearchModal();
            playVideoFromLibrary(name, path);
        }

        // Show delete video confirmation modal
        function showDeleteVideoConfirmation(videoName, videoPath) {
            const modal = document.createElement('div');
            modal.id = 'individual-delete-modal';
            modal.style.cssText = `
                position: fixed;
                top: 0;
                left: 0;
                width: 100%;
                height: 100%;
                background: rgba(0, 0, 0, 0.8);
                display: flex;
                align-items: center;
                justify-content: center;
                z-index: 10001;
                backdrop-filter: blur(5px);
            `;
            
            modal.innerHTML = `
                <div style="
                    position: relative;
                    background: #000000;
                    border: 2px solid #dc3545;
                    border-radius: 12px;
                    padding: 30px;
                    max-width: 500px;
                    width: 90%;
                    text-align: center;
                    box-shadow: 0 0 30px rgba(220, 53, 69, 0.5);
                ">
                    <button onclick="document.getElementById('individual-delete-modal').remove()" style="
                        position: absolute;
                        top: 10px;
                        right: 10px;
                        background: none;
                        border: none;
                        color: #dc3545;
                        font-size: 24px;
                        font-weight: bold;
                        cursor: pointer;
                        width: 30px;
                        height: 30px;
                        display: flex;
                        align-items: center;
                        justify-content: center;
                        border-radius: 50%;
                        transition: background-color 0.2s;
                    " onmouseover="this.style.backgroundColor='#dc3545'; this.style.color='white';" onmouseout="this.style.backgroundColor='transparent'; this.style.color='#dc3545';"></button>
                    <div style="color: #dc3545; font-size: 48px; margin-bottom: 20px;"></div>
                    <h3 style="color: #dc3545; margin: 0 0 20px 0; font-size: 20px;">Delete Video</h3>
                    <p style="color: white; margin: 0 0 15px 0; line-height: 1.4;">
                        Are you sure you want to permanently delete this video?
                    </p>
                    <p style="color: #ffd700; margin: 0 0 25px 0; font-weight: bold; word-break: break-all;">
                        ${videoName}
                    </p>
                    <p style="color: #ff6b6b; margin: 0 0 25px 0; font-size: 14px;">
                         This action cannot be undone!
                    </p>
                    <div style="display: flex; gap: 15px; justify-content: center;">
                        <button onclick="document.getElementById('individual-delete-modal').remove()" 
                                style="padding: 12px 24px; background: #000000; color: #6c757d; border: 2px solid #6c757d; border-radius: 8px; cursor: pointer; font-weight: bold;">
                            Cancel
                        </button>
                        <button onclick="confirmDeleteVideo('${videoName}', '${videoPath}'); document.getElementById('individual-delete-modal').remove()" 
                                style="padding: 12px 24px; background: #000000; color: #dc3545; border: 2px solid #dc3545; border-radius: 8px; cursor: pointer; font-weight: bold;">
                             Delete Video
                        </button>
                    </div>
                </div>
            `;
            
            document.body.appendChild(modal);
            
            // Close on background click
            modal.addEventListener('click', (e) => {
                if (e.target === modal) {
                    modal.remove();
                }
            });
        }

        // Actually delete the video
        async function confirmDeleteVideo(videoName, videoPath) {
            try {
                console.log(`Deleting video: ${videoName} at path: ${videoPath}`);
                
                const response = await fetch('/api/delete-video', {
                    method: 'POST',
                    headers: {
                        'Content-Type': 'application/json',
                        'Authorization': window.authHeaders.Authorization
                    },
                    body: JSON.stringify({
                        path: videoPath
                    })
                });

                if (response.ok) {
                    const result = await response.json();
                    console.log('Delete response:', result);
                    
                    // Verify the file was actually deleted from server
                    await verifyFileDeletion(videoName, videoPath);
                    
                    // Refresh the search results
                    await refreshVideoMetadata();
                    
                } else {
                    const error = await response.json();
                    throw new Error(error.message || `Failed to delete video: ${response.status}`);
                }
            } catch (error) {
                console.error('Error deleting video:', error);
                showErrorMessage(`Failed to delete video: ${error.message}`);
            }
        }

        // Verify file deletion from server
        async function verifyFileDeletion(videoName, videoPath) {
            try {
                // Check if file still exists on server using ls command
                const response = await fetch('/api/verify-file-deletion', {
                    method: 'POST',
                    headers: {
                        'Content-Type': 'application/json',
                        'Authorization': window.authHeaders.Authorization
                    },
                    body: JSON.stringify({
                        path: videoPath
                    })
                });

                if (response.ok) {
                    const result = await response.json();
                    if (result.exists === false) {
                        // File does not exist (successfully deleted) - show green success modal
                        showIndividualDeletionSuccessModal(videoName);
                    } else {
                        // File still exists - show red error modal
                        showDeletionErrorModal(videoName, 'File still exists on server after deletion attempt', response.status);
                    }
                } else if (response.status === 404) {
                    // API endpoint not implemented yet - assume deletion was successful
                    showIndividualDeletionSuccessModal(videoName);
                } else {
                    // API error - show red error modal
                    const error = await response.json().catch(() => ({ message: 'Unknown error' }));
                    showDeletionErrorModal(videoName, error.message || 'Failed to verify deletion', response.status);
                }
            } catch (error) {
                // Network or other error - for now assume deletion was successful
                // In production, you might want to show the error modal instead
                console.warn('Could not verify deletion, assuming success:', error.message);
                showIndividualDeletionSuccessModal(videoName);
            }
        }

        // Show green success modal for successful individual deletion
        function showIndividualDeletionSuccessModal(videoName) {
            const modal = document.createElement('div');
            modal.id = 'deletion-success-modal';
            modal.style.cssText = `
                position: fixed;
                top: 0;
                left: 0;
                width: 100%;
                height: 100%;
                background: rgba(0, 0, 0, 0.8);
                display: flex;
                align-items: center;
                justify-content: center;
                z-index: 10003;
                backdrop-filter: blur(5px);
            `;
            
            modal.innerHTML = `
                <div style="
                    position: relative;
                    background: #000000;
                    border: 2px solid #28a745;
                    border-radius: 12px;
                    padding: 30px;
                    max-width: 500px;
                    width: 90%;
                    text-align: center;
                    box-shadow: 0 0 30px rgba(40, 167, 69, 0.5);
                    animation: successPulse 0.6s ease-out;
                ">
                    <button onclick="document.getElementById('deletion-success-modal').remove()" style="
                        position: absolute;
                        top: 10px;
                        right: 10px;
                        background: none;
                        border: none;
                        color: #28a745;
                        font-size: 24px;
                        font-weight: bold;
                        cursor: pointer;
                        width: 30px;
                        height: 30px;
                        display: flex;
                        align-items: center;
                        justify-content: center;
                        border-radius: 50%;
                        transition: background-color 0.2s;
                    " onmouseover="this.style.backgroundColor='#28a745'; this.style.color='white';" onmouseout="this.style.backgroundColor='transparent'; this.style.color='#28a745';"></button>
                    <div style="color: #28a745; font-size: 48px; margin-bottom: 20px;"></div>
                    <h3 style="color: #28a745; margin: 0 0 20px 0; font-size: 20px;">File Deleted</h3>
                    <p style="color: white; margin: 0 0 15px 0; line-height: 1.4;">
                        The video file has been permanently removed from the server.
                    </p>
                    <p style="color: #ffd700; margin: 0 0 25px 0; font-weight: bold; word-break: break-all;">
                        ${videoName}
                    </p>
                    <p style="color: #28a745; margin: 0 0 25px 0; font-size: 14px;">
                         Confirmed: File no longer exists on server
                    </p>
                    <div style="display: flex; gap: 15px; justify-content: center;">
                        <button onclick="document.getElementById('deletion-success-modal').remove()" 
                                style="padding: 12px 24px; background: #000000; color: #28a745; border: 2px solid #28a745; border-radius: 8px; cursor: pointer; font-weight: bold;">
                             OK
                        </button>
                    </div>
                </div>
            `;
            
            document.body.appendChild(modal);
            
            // Close on background click
            modal.addEventListener('click', (e) => {
                if (e.target === modal) {
                    modal.remove();
                }
            });
        }

        // Show red error modal for failed deletion
        function showDeletionErrorModal(videoName, errorMessage, responseCode) {
            const modal = document.createElement('div');
            modal.id = 'deletion-error-modal';
            modal.style.cssText = `
                position: fixed;
                top: 0;
                left: 0;
                width: 100%;
                height: 100%;
                background: rgba(0, 0, 0, 0.8);
                display: flex;
                align-items: center;
                justify-content: center;
                z-index: 10003;
                backdrop-filter: blur(5px);
            `;
            
            modal.innerHTML = `
                <div style="
                    position: relative;
                    background: #000000;
                    border: 2px solid #dc3545;
                    border-radius: 12px;
                    padding: 30px;
                    max-width: 500px;
                    width: 90%;
                    text-align: center;
                    box-shadow: 0 0 30px rgba(220, 53, 69, 0.5);
                    animation: errorShake 0.6s ease-out;
                ">
                    <button onclick="document.getElementById('deletion-error-modal').remove()" style="
                        position: absolute;
                        top: 10px;
                        right: 10px;
                        background: none;
                        border: none;
                        color: #dc3545;
                        font-size: 24px;
                        font-weight: bold;
                        cursor: pointer;
                        width: 30px;
                        height: 30px;
                        display: flex;
                        align-items: center;
                        justify-content: center;
                        border-radius: 50%;
                        transition: background-color 0.2s;
                    " onmouseover="this.style.backgroundColor='#dc3545'; this.style.color='white';" onmouseout="this.style.backgroundColor='transparent'; this.style.color='#dc3545';"></button>
                    <div style="color: #dc3545; font-size: 48px; margin-bottom: 20px;"></div>
                    <h3 style="color: #dc3545; margin: 0 0 20px 0; font-size: 20px;">Deletion Failed</h3>
                    <p style="color: white; margin: 0 0 15px 0; line-height: 1.4;">
                        The video could not be completely removed from the server.
                    </p>
                    <p style="color: #ffd700; margin: 0 0 15px 0; font-weight: bold; word-break: break-all;">
                        ${videoName}
                    </p>
                    <div style="background: rgba(220, 53, 69, 0.1); border: 1px solid #dc3545; border-radius: 8px; padding: 15px; margin: 15px 0;">
                        <p style="color: #ff6b6b; margin: 0 0 10px 0; font-size: 14px; font-weight: bold;">
                            Error Details:
                        </p>
                        <p style="color: #ffcccc; margin: 0 0 10px 0; font-size: 13px;">
                            ${errorMessage}
                        </p>
                        <p style="color: #ffcccc; margin: 0; font-size: 13px;">
                            Response Code: ${responseCode}
                        </p>
                    </div>
                    <div style="display: flex; gap: 15px; justify-content: center;">
                        <button onclick="document.getElementById('deletion-error-modal').remove()" 
                                style="padding: 12px 24px; background: #000000; color: #dc3545; border: 2px solid #dc3545; border-radius: 8px; cursor: pointer; font-weight: bold;">
                             Close
                        </button>
                    </div>
                </div>
            `;
            
            document.body.appendChild(modal);
            
            // Close on background click
            modal.addEventListener('click', (e) => {
                if (e.target === modal) {
                    modal.remove();
                }
            });
        }

        // Helper function to show success message
        function showSuccessMessage(message) {
            const toast = document.createElement('div');
            toast.style.cssText = `
                position: fixed;
                top: 20px;
                right: 20px;
                background: #000000;
                color: #28a745;
                border: 2px solid #28a745;
                border-radius: 8px;
                padding: 15px 20px;
                z-index: 10002;
                box-shadow: 0 0 20px rgba(40, 167, 69, 0.5);
            `;
            toast.innerHTML = ` ${message}`;
            document.body.appendChild(toast);
            
            setTimeout(() => {
                toast.remove();
            }, 3000);
        }

        // Helper function to show error message
        function showErrorMessage(message) {
            const toast = document.createElement('div');
            toast.style.cssText = `
                position: fixed;
                top: 20px;
                right: 20px;
                background: #000000;
                color: #dc3545;
                border: 2px solid #dc3545;
                border-radius: 8px;
                padding: 15px 20px;
                z-index: 10002;
                box-shadow: 0 0 20px rgba(220, 53, 69, 0.5);
            `;
            toast.innerHTML = ` ${message}`;
            document.body.appendChild(toast);
            
            setTimeout(() => {
                toast.remove();
            }, 5000);
        }

        // Close individual video delete modal
        function closeDeleteModal() {
            const modal = document.getElementById('individual-delete-modal');
            if (modal) {
                modal.remove();
            }
        }

        function playSelectedVideos(order) {
            if (selectedVideoIndices.size === 0) {
                alert('Please select at least one video to play');
                return;
            }

            // Get selected videos in their current arranged order
            const selectedVideos = Array.from(selectedVideoIndices)
                .sort((a, b) => a - b) // Sort indices to maintain display order
                .map(index => searchResults[index]);

            // Apply order - but respect current arrangement
            if (order === 'top-to-bottom') {
                // Use current arranged order of selected videos
                playlistMode = 'search-ascending';
                console.log('Search Playlist Debug: Playing selected videos from top to bottom');
            } else if (order === 'bottom-to-top') {
                // Reverse the current arranged order of selected videos
                selectedVideos.reverse();
                playlistMode = 'search-descending';
                console.log('Search Playlist Debug: Playing selected videos from bottom to top');
            }

            // Store the custom playlist
            window.customPlaylist = selectedVideos;
            window.customPlaylistIndex = 0;

            console.log('Search Playlist Debug: Starting custom playlist with', selectedVideos.length, 'videos');
            console.log('Search Playlist Debug: Video order:', selectedVideos.map(v => v.name));
            
            // Start playing first video
            const firstVideo = selectedVideos[0];
            closeVideoSearchModal();
            playVideoFromLibrary(firstVideo.name, firstVideo.path);
        }

        // Order selection modal functions
        function showPlayAllModal() {
            if (!searchResults || searchResults.length === 0) {
                alert('Please search for videos first');
                return;
            }
            document.getElementById('playAllOrderModal').style.display = 'block';
        }

        function showPlaySelectedModal() {
            if (selectedVideoIndices.size === 0) {
                alert('Please select at least one video to play');
                return;
            }
            document.getElementById('playSelectedOrderModal').style.display = 'block';
        }

        function closePlayAllOrderModal() {
            document.getElementById('playAllOrderModal').style.display = 'none';
        }

        function closePlaySelectedOrderModal() {
            document.getElementById('playSelectedOrderModal').style.display = 'none';
        }

        function playAllVideos(order) {
            closePlayAllOrderModal();
            
            // Use the current search results order (respects user rearrangement)
            const allSearchVideos = [...searchResults];
            
            // Sort based on order - but respect current arrangement
            if (order === 'top-to-bottom') {
                // If top-to-bottom, use current search results order as-is (user arranged)
                playlistMode = 'search-ascending';
                console.log('Search Playlist Debug: Playing all videos from top to bottom');
            } else if (order === 'bottom-to-top') {
                // If bottom-to-top, reverse the current search results order
                allSearchVideos.reverse();
                playlistMode = 'search-descending';
                console.log('Search Playlist Debug: Playing all videos from bottom to top');
            }

            // Store the custom playlist
            window.customPlaylist = allSearchVideos;
            window.customPlaylistIndex = 0;

            console.log('Search Playlist Debug: Starting play all with', allSearchVideos.length, 'videos');
            console.log('Search Playlist Debug: Video order:', allSearchVideos.map(v => v.name));
            
            // Start playing first video
            const firstVideo = allSearchVideos[0];
            closeVideoSearchModal();
            playVideoFromLibrary(firstVideo.name, firstVideo.path);
        }

        function playSelectedVideosOrdered(order) {
            closePlaySelectedOrderModal();
            
            if (selectedVideoIndices.size === 0) {
                alert('Please select at least one video to play');
                return;
            }

            // Get selected videos in their current arranged order
            const selectedVideos = Array.from(selectedVideoIndices)
                .sort((a, b) => a - b) // Sort indices to maintain display order
                .map(index => searchResults[index]);

            // Apply order - but respect current arrangement
            if (order === 'top-to-bottom') {
                // Use current arranged order of selected videos
                playlistMode = 'search-ascending';
                console.log('Search Playlist Debug: Playing selected videos from top to bottom');
            } else if (order === 'bottom-to-top') {
                // Reverse the current arranged order of selected videos
                selectedVideos.reverse();
                playlistMode = 'search-descending';
                console.log('Search Playlist Debug: Playing selected videos from bottom to top');
            }

            // Store the custom playlist
            window.customPlaylist = selectedVideos;
            window.customPlaylistIndex = 0;

            console.log('Search Playlist Debug: Starting play selected with', selectedVideos.length, 'videos');
            console.log('Search Playlist Debug: Video order:', selectedVideos.map(v => v.name));
            
            // Start playing first video
            const firstVideo = selectedVideos[0];
            closeVideoSearchModal();
            playVideoFromLibrary(firstVideo.name, firstVideo.path);
        }

        // Video Catalog Drag and Drop Functions
        let draggedElement = null;
        let draggedIndex = null;

        function setupVideoLibraryDragAndDrop() {
            const videoItems = document.querySelectorAll('.video-library-item');
            
            videoItems.forEach((item, index) => {
                // Drag start
                item.addEventListener('dragstart', (e) => {
                    draggedElement = item;
                    draggedIndex = parseInt(item.dataset.videoIndex);
                    item.classList.add('dragging');
                    
                    // Set drag effect
                    e.dataTransfer.effectAllowed = 'move';
                    e.dataTransfer.setData('text/html', item.outerHTML);
                    
                    console.log('Drag started:', allVideos[draggedIndex].name);
                });
                
                // Drag end
                item.addEventListener('dragend', (e) => {
                    item.classList.remove('dragging');
                    
                    // Remove all drag-over classes
                    document.querySelectorAll('.video-library-item').forEach(el => {
                        el.classList.remove('drag-over');
                    });
                    
                    draggedElement = null;
                    draggedIndex = null;
                });
                
                // Drag over
                item.addEventListener('dragover', (e) => {
                    e.preventDefault();
                    e.dataTransfer.dropEffect = 'move';
                    
                    if (item !== draggedElement) {
                        item.classList.add('drag-over');
                    }
                });
                
                // Drag leave
                item.addEventListener('dragleave', (e) => {
                    item.classList.remove('drag-over');
                });
                
                // Drop
                item.addEventListener('drop', (e) => {
                    e.preventDefault();
                    item.classList.remove('drag-over');
                    
                    if (item !== draggedElement && draggedIndex !== null) {
                        const targetIndex = parseInt(item.dataset.videoIndex);
                        
                        console.log(`Moving video from index ${draggedIndex} to ${targetIndex}`);
                        
                        // Reorder the videos array
                        reorderVideos(draggedIndex, targetIndex);
                    }
                });
            });
        }

        function reorderVideos(fromIndex, toIndex) {
            if (fromIndex === toIndex) return;
            
            // Create a copy of the videos array
            const newVideosOrder = [...allVideos];
            
            // Remove the dragged video from its original position
            const draggedVideo = newVideosOrder.splice(fromIndex, 1)[0];
            
            // Insert it at the new position
            newVideosOrder.splice(toIndex, 0, draggedVideo);
            
            // Update the global array
            allVideos = newVideosOrder;
            
            console.log('Video catalog reordered:', allVideos.map(v => v.name));
            
            // Re-display the library with new order
            displayVideoLibrary(allVideos);
            
            // Removed redundant success message - drag and drop is self-evident
        }

        // Search Results Drag and Drop Functions
        let searchDraggedElement = null;
        let searchDraggedIndex = null;

        function setupSearchResultsDragAndDrop() {
            const searchItems = document.querySelectorAll('.video-search-item');
            
            searchItems.forEach((item, index) => {
                // Drag start
                item.addEventListener('dragstart', (e) => {
                    searchDraggedElement = item;
                    searchDraggedIndex = parseInt(item.dataset.searchIndex);
                    item.classList.add('dragging');
                    
                    // Set drag effect
                    e.dataTransfer.effectAllowed = 'move';
                    e.dataTransfer.setData('text/html', item.outerHTML);
                    
                    console.log('Search drag started:', searchResults[searchDraggedIndex].name);
                });
                
                // Drag end
                item.addEventListener('dragend', (e) => {
                    item.classList.remove('dragging');
                    
                    // Remove all drag-over classes
                    document.querySelectorAll('.video-search-item').forEach(el => {
                        el.classList.remove('drag-over');
                    });
                    
                    searchDraggedElement = null;
                    searchDraggedIndex = null;
                });
                
                // Drag over
                item.addEventListener('dragover', (e) => {
                    e.preventDefault();
                    e.dataTransfer.dropEffect = 'move';
                    
                    if (item !== searchDraggedElement) {
                        item.classList.add('drag-over');
                    }
                });
                
                // Drag leave
                item.addEventListener('dragleave', (e) => {
                    item.classList.remove('drag-over');
                });
                
                // Drop
                item.addEventListener('drop', (e) => {
                    e.preventDefault();
                    item.classList.remove('drag-over');
                    
                    if (item !== searchDraggedElement && searchDraggedIndex !== null) {
                        const targetIndex = parseInt(item.dataset.searchIndex);
                        
                        console.log(`Moving search result from index ${searchDraggedIndex} to ${targetIndex}`);
                        
                        // Reorder the search results
                        reorderSearchResults(searchDraggedIndex, targetIndex);
                    }
                });
            });
        }

        function reorderSearchResults(fromIndex, toIndex) {
            if (fromIndex === toIndex) return;
            
            // Create a copy of the search results array
            const newSearchOrder = [...searchResults];
            
            // Remove the dragged video from its original position
            const draggedVideo = newSearchOrder.splice(fromIndex, 1)[0];
            
            // Insert it at the new position
            newSearchOrder.splice(toIndex, 0, draggedVideo);
            
            // Update the search results array
            searchResults = newSearchOrder;
            
            // Update selected indices to match new order
            const newSelectedIndices = new Set();
            selectedVideoIndices.forEach(oldIndex => {
                let newIndex = oldIndex;
                
                if (oldIndex === fromIndex) {
                    newIndex = toIndex;
                } else if (fromIndex < toIndex && oldIndex > fromIndex && oldIndex <= toIndex) {
                    newIndex = oldIndex - 1;
                } else if (fromIndex > toIndex && oldIndex >= toIndex && oldIndex < fromIndex) {
                    newIndex = oldIndex + 1;
                }
                
                newSelectedIndices.add(newIndex);
            });
            
            selectedVideoIndices = newSelectedIndices;
            
            console.log('Search results reordered:', searchResults.map(v => v.name));
            
            // Re-display the search results with new order
            displaySearchResults();
        }

        // Delete functions
        function showDeleteModal(mode) {
            deleteMode = mode;
            const modal = document.getElementById('deleteConfirmationModal');
            const title = document.getElementById('deleteModalTitle');
            const message = document.getElementById('deleteModalMessage');
            const videosList = document.getElementById('deleteVideosList');
            const videosListContent = document.getElementById('deleteVideosListContent');
            
            if (mode === 'selected') {
                const selectedVideos = Array.from(selectedVideoIndices).map(index => searchResults[index]);
                videosToDelete = selectedVideos;
                
                if (selectedVideos.length === 0) {
                    alert('No videos selected for deletion.');
                    return;
                }
                
                title.textContent = 'DELETE SELECTED VIDEOS';
                message.textContent = `You are about to permanently delete ${selectedVideos.length} selected video${selectedVideos.length === 1 ? '' : 's'}.`;
                
                // Show the videos list
                videosList.style.display = 'block';
                videosListContent.innerHTML = selectedVideos.map(video => 
                    `<div style="padding: 3px 0; color: #ff6b6b;"> ${video.name}</div>`
                ).join('');
                
            } else if (mode === 'all') {
                videosToDelete = [...searchResults];
                
                if (searchResults.length === 0) {
                    alert('No videos found to delete.');
                    return;
                }
                
                title.textContent = 'DELETE ALL VIDEOS';
                message.textContent = `You are about to permanently delete ALL ${searchResults.length} video${searchResults.length === 1 ? '' : 's'} from the current search results.`;
                
                // Show the videos list
                videosList.style.display = 'block';
                videosListContent.innerHTML = searchResults.map(video => 
                    `<div style="padding: 3px 0; color: #ff6b6b;"> ${video.name}</div>`
                ).join('');
            }
            
            modal.style.display = 'block';
        }

        function closeDeleteModal() {
            document.getElementById('deleteConfirmationModal').style.display = 'none';
            deleteMode = '';
            videosToDelete = [];
        }

        async function confirmDelete() {
            if (videosToDelete.length === 0) {
                closeDeleteModal();
                return;
            }

            // Store video count before deletion
            videosBeforeDeletion = searchResults.length;

            const confirmBtn = document.getElementById('confirmDeleteBtn');
            const originalText = confirmBtn.textContent;
            confirmBtn.textContent = ' DELETING...';
            confirmBtn.disabled = true;

            try {
                let deletedCount = 0;
                let failedCount = 0;
                const totalCount = videosToDelete.length;

                for (let i = 0; i < videosToDelete.length; i++) {
                    const video = videosToDelete[i];
                    confirmBtn.textContent = ` DELETING... (${i + 1}/${totalCount})`;
                    
                    try {
                        const response = await fetch('/api/delete-video', {
                            method: 'POST',
                            headers: {
                                'Content-Type': 'application/json',
                                'Authorization': window.authHeaders.Authorization
                            },
                            body: JSON.stringify({
                                path: video.path
                            })
                        });

                        if (response.ok) {
                            deletedCount++;
                        } else {
                            failedCount++;
                            console.error(`Failed to delete ${video.name}:`, await response.text());
                        }
                    } catch (error) {
                        failedCount++;
                        console.error(`Error deleting ${video.name}:`, error);
                    }
                }

                // Close the delete modal first
                closeDeleteModal();

                // Auto-refresh to get updated counts by calling refreshVideoMetadata
                await refreshVideoMetadata();
                videosAfterRefresh = searchResults.length;

                // Show the success modal with stats
                showDeletionSuccessModal(deletedCount, failedCount);

            } catch (error) {
                console.error('Error during deletion:', error);
                alert(' An error occurred during deletion. Please try again.');
            } finally {
                confirmBtn.textContent = originalText;
                confirmBtn.disabled = false;
            }
        }

        function showDeletionSuccessModal(deletedCount, failedCount) {
            const modal = document.getElementById('deletionSuccessModal');
            const title = document.getElementById('deletionSuccessTitle');
            const message = document.getElementById('deletionSuccessMessage');
            const beforeCount = document.getElementById('videosBeforeCount');
            const afterCount = document.getElementById('videosAfterCount');
            const confirmedCount = document.getElementById('confirmedDeletedCount');

            // Update content
            if (failedCount === 0) {
                title.textContent = 'DELETION SUCCESSFUL';
                message.textContent = `Successfully deleted ${deletedCount} video${deletedCount === 1 ? '' : 's'} from the system.`;
            } else {
                title.textContent = 'DELETION PARTIALLY COMPLETE';
                message.textContent = `Deleted ${deletedCount} video${deletedCount === 1 ? '' : 's'}, but ${failedCount} failed to delete.`;
            }

            // Update stats
            beforeCount.textContent = videosBeforeDeletion;
            afterCount.textContent = videosAfterRefresh;
            confirmedCount.textContent = deletedCount;

            modal.style.display = 'block';
        }

        function closeDeletionSuccessModal() {
            document.getElementById('deletionSuccessModal').style.display = 'none';
        }

        // Download functions
        async function downloadSelectedVideos() {
            const selectedVideos = Array.from(selectedVideoIndices).map(index => searchResults[index]);
            
            if (selectedVideos.length === 0) {
                alert('No videos selected for download.');
                return;
            }
            
            await startDownload(selectedVideos);
        }

        async function downloadAllVideos() {
            if (searchResults.length === 0) {
                alert('No videos found to download.');
                return;
            }
            
            await startDownload(searchResults);
        }
        
        // Function to get selected videos from search modal
        function getSelectedVideos() {
            return Array.from(selectedVideoIndices).map(index => searchResults[index]);
        }

        async function downloadSelectedVideosAsZip() {
            console.log('ZIP Download button clicked!');
            
            const selectedVideos = getSelectedVideos();
            console.log('Selected videos:', selectedVideos);
            
            if (selectedVideos.length === 0) {
                showError('Please select at least one video to download as ZIP.', 'No Videos Selected');
                return;
            }
            
            console.log('Starting ZIP download process for selected videos:', selectedVideos);
            
            // Create or get the download modal
            let modal = document.getElementById('download-modal');
            if (!modal) {
                // Create the modal structure like other download functions
                modal = document.createElement('div');
                modal.id = 'download-modal';
                modal.style.cssText = `
                    display: none; position: fixed; z-index: 10000; left: 0; top: 0; 
                    width: 100%; height: 100%; overflow: auto; 
                    background-color: rgba(0,0,0,0.8); backdrop-filter: blur(8px);
                `;
                
                modal.innerHTML = `
                    <div style="background: linear-gradient(135deg, #1a1a1a, #2d2d2d); margin: 2% auto; padding: 30px; border: 2px solid #00ffff; border-radius: 15px; width: 90%; max-width: 800px; max-height: 90vh; overflow-y: auto; position: relative; box-shadow: 0 0 30px rgba(0,255,255,0.3);">
                        <span onclick="document.getElementById('download-modal').style.display='none'" style="color: #ff4444; float: right; font-size: 28px; font-weight: bold; cursor: pointer; margin-top: -10px; margin-right: -10px;">&times;</span>
                        <div id="download-modal-progress-container">
                            <h3> Preparing Download...</h3>
                        </div>
                        <div id="download-modal-footer" style="display: none; text-align: center; margin-top: 30px; padding-top: 20px; border-top: 1px solid #333;">
                            <button onclick="document.getElementById('download-modal').style.display='none'" style="padding: 12px 30px; background: #00ffff; color: #000; border: none; border-radius: 8px; cursor: pointer; font-weight: bold;"> Close</button>
                        </div>
                    </div>
                `;
                
                document.body.appendChild(modal);
            }
            
            // Show the modal
            modal.style.display = 'block';
            
            // Small delay to ensure DOM is ready
            await new Promise(resolve => setTimeout(resolve, 100));
            
            // Start the ZIP download process
            await startDownloadAsZip(selectedVideos);
        }
        
        async function startDownloadAsZip(videosToDownload) {
            console.log('Starting ZIP download for videos:', videosToDownload);
            
            // Modal should already exist and be shown by the calling function
            const progressContainer = document.getElementById('download-modal-progress-container');
            
            if (!progressContainer) {
                console.error('Download progress container not found');
                showError('Download system not ready. Please try again.', 'System Error');
                return;
            }
            
            // Clear and prepare progress container
            progressContainer.innerHTML = '<h3 id="download-progress-header"> Creating ZIP Archive - Downloaded: 0 | Total files to download: 1...</h3>';
            
            const progressId = `search-zip-progress-${Date.now()}`;
            const videoPaths = videosToDownload.map(video => video.path);
            
            // Add ZIP Compression progress item
            progressContainer.innerHTML += `
                <div id="${progressId}-compression" class="progress-item">
                    <div class="progress-header">
                        <span class="file-name"> Compressing ${videoPaths.length} videos to archive</span>
                        <span class="progress-status"> Starting compression...</span>
                    </div>
                    <div class="progress-details">
                        <span class="progress-percentage">0%</span>
                        <span class="progress-speed"></span>
                        <span class="file-size">Processing videos...</span>
                    </div>
                    <div class="progress-bar">
                        <div class="progress-fill" style="width: 0%"></div>
                    </div>
                    <div class="progress-right">
                        <div class="progress-right-status"> Compressing...</div>
                        <div class="progress-right-details">
                            <div>Videos: ${videoPaths.length}</div>
                            <div>Processing...</div>
                        </div>
                    </div>
                </div>
            `;
            
            // Add ZIP Download progress item (initially hidden)
            progressContainer.innerHTML += `
                <div id="${progressId}-download" class="progress-item" style="display: none;">
                    <div class="progress-header">
                        <span class="file-name"> Downloading ZIP archive</span>
                        <span class="progress-status"> Preparing download...</span>
                    </div>
                    <div class="progress-details">
                        <span class="progress-percentage">0%</span>
                        <span class="progress-speed"></span>
                        <span class="file-size"></span>
                    </div>
                    <div class="progress-bar">
                        <div class="progress-fill" style="width: 0%"></div>
                    </div>
                    <div class="progress-right">
                        <div class="progress-right-status"> Downloading...</div>
                        <div class="progress-right-details">
                            <div>Receiving...</div>
                            <div>Estimating...</div>
                        </div>
                    </div>
                </div>
            `;
            
            try {
                const startTime = Date.now();
                
                // Phase 1: Compression progress (0-100%)
                const compressionElement = document.querySelector(`#${progressId}-compression`);
                compressionElement.querySelector('.progress-status').innerHTML = ' Compressing videos...';
                compressionElement.querySelector('.progress-right-status').textContent = ' Creating archive...';
                
                // Simulate realistic compression progress
                let compressionProgress = 0;
                const compressionInterval = setInterval(() => {
                    compressionProgress += Math.random() * 12 + 3; // 3-15% increments
                    if (compressionProgress > 100) compressionProgress = 100;
                    
                    if (compressionElement) {
                        compressionElement.querySelector('.progress-percentage').textContent = `${Math.round(compressionProgress)}%`;
                        compressionElement.querySelector('.progress-fill').style.width = `${compressionProgress}%`;
                        compressionElement.querySelector('.file-size').textContent = `Processing ${videoPaths.length} videos...`;
                        compressionElement.querySelector('.progress-right-details').innerHTML = `
                            <div>Videos: ${videoPaths.length}</div>
                            <div>${Math.round(compressionProgress)}% compressed</div>
                        `;
                        
                        if (compressionProgress >= 100) {
                            clearInterval(compressionInterval);
                            compressionElement.querySelector('.progress-status').innerHTML = ' Compression complete';
                            compressionElement.querySelector('.progress-right-status').textContent = ' Archive created';
                            compressionElement.querySelector('.progress-right-details').innerHTML = `
                                <div>Videos: ${videoPaths.length}</div>
                                <div>100% compressed</div>
                            `;
                            
                            // Add waiting message IMMEDIATELY when compression hits 100%
                            setTimeout(() => {
                                const waitingMessage = document.createElement('div');
                                waitingMessage.className = 'waiting-message';
                                waitingMessage.style.cssText = 'margin: 15px 0; padding: 12px; background: rgba(255, 193, 7, 0.1); border: 1px solid #ffc107; border-radius: 8px; text-align: center; color: #ffc107; font-weight: 500;';
                                waitingMessage.innerHTML = ' Waiting for Zip file to be downloaded...';
                                compressionElement.appendChild(waitingMessage);
                            }, 300); // Small delay to let the completion message render
                        }
                    }
                }, 300);
                
                // Start ZIP creation
                const response = await fetch('/api/download-zip', {
                    method: 'POST',
                    headers: window.authHeaders,
                    body: JSON.stringify({ videos: videoPaths })
                });
                
                // Wait for compression to complete
                while (compressionProgress < 100) {
                    await new Promise(resolve => setTimeout(resolve, 100));
                }
                
                // Add compression completion report
                const compressionEndTime = Date.now();
                const compressionDuration = (compressionEndTime - startTime) / 1000;
                const completionReportCompression = document.createElement('div');
                completionReportCompression.className = 'completion-report-horizontal';
                completionReportCompression.innerHTML = `
                    <div class="report-line">
                        <span class="report-item"> STARTED ${new Date(startTime).toLocaleTimeString()}</span>
                        <span class="report-item"> COMPLETED ${new Date(compressionEndTime).toLocaleTimeString()}</span>
                        <span class="report-item"> DURATION ${formatDuration(compressionDuration)}</span>
                        <span class="report-item"> VIDEOS COMPRESSED ${videoPaths.length}</span>
                    </div>
                `;
                compressionElement.appendChild(completionReportCompression);
                
                // Show download progress item (waiting message already added when compression hit 100%)
                const downloadElement = document.querySelector(`#${progressId}-download`);
                downloadElement.style.display = 'block';
                
                if (!response.ok) {
                    throw new Error(`Failed to create ZIP archive: ${response.status} ${response.statusText}`);
                }
                
                // Phase 2: Download with streaming progress (separate 0-100%)
                const contentLength = response.headers.get('Content-Length');
                const totalBytes = contentLength ? parseInt(contentLength) : 0;
                
                downloadElement.querySelector('.progress-status').innerHTML = ' Downloading ZIP...';
                downloadElement.querySelector('.progress-right-status').textContent = ' Receiving data...';
                
                const reader = response.body.getReader();
                const chunks = [];
                let receivedBytes = 0;
                const downloadStartTime = Date.now();
                
                // Real-time download progress (0-100% for download only)
                const downloadInterval = setInterval(() => {
                    const elapsed = (Date.now() - downloadStartTime) / 1000;
                    const speed = receivedBytes / elapsed;
                    const percentage = totalBytes > 0 ? Math.round((receivedBytes / totalBytes) * 100) : 0;
                    
                    if (downloadElement) {
                        downloadElement.querySelector('.progress-percentage').textContent = `${percentage}%`;
                        downloadElement.querySelector('.progress-fill').style.width = `${percentage}%`;
                        downloadElement.querySelector('.progress-speed').textContent = formatSpeed(speed);
                        
                        if (totalBytes > 0) {
                            downloadElement.querySelector('.file-size').textContent = 
                                `${formatBytes(receivedBytes)} / ${formatBytes(totalBytes)}`;
                        } else {
                            downloadElement.querySelector('.file-size').textContent = formatBytes(receivedBytes);
                        }
                        
                        downloadElement.querySelector('.progress-right-details').innerHTML = `
                            <div>Receiving...</div>
                            <div>${percentage}% downloaded</div>
                        `;
                    }
                }, 500);
                
                // Read chunks
                while (true) {
                    const { done, value } = await reader.read();
                    
                    if (done) break;
                    
                    chunks.push(value);
                    receivedBytes += value.length;
                }
                
                // Create final blob
                const blob = new Blob(chunks);
                
                // Final download update
                clearInterval(downloadInterval);
                const downloadEndTime = Date.now();
                const downloadDuration = (downloadEndTime - downloadStartTime) / 1000;
                const averageSpeed = blob.size / downloadDuration;
                
                downloadElement.querySelector('.progress-percentage').textContent = '100%';
                downloadElement.querySelector('.progress-fill').style.width = '100%';
                downloadElement.querySelector('.progress-status').innerHTML = ' Download complete';
                downloadElement.querySelector('.file-size').textContent = `${formatBytes(blob.size)}`;
                downloadElement.querySelector('.progress-speed').textContent = formatSpeed(averageSpeed);
                downloadElement.querySelector('.progress-right-status').textContent = ' Complete';
                downloadElement.querySelector('.progress-right-details').innerHTML = `
                    <div>100% downloaded</div>
                    <div>${formatBytes(blob.size)}</div>
                `;
                
                // Add download completion report
                const completionReportDownload = document.createElement('div');
                completionReportDownload.className = 'completion-report-horizontal';
                completionReportDownload.innerHTML = `
                    <div class="report-line">
                        <span class="report-item"> STARTED ${new Date(downloadStartTime).toLocaleTimeString()}</span>
                        <span class="report-item"> COMPLETED ${new Date(downloadEndTime).toLocaleTimeString()}</span>
                        <span class="report-item"> DURATION ${formatDuration(downloadDuration)}</span>
                        <span class="report-item"> AVERAGE SPEED ${formatSpeed(averageSpeed)}</span>
                    </div>
                    <div class="report-center">
                        <span class="report-size"> Size: ${formatBytes(blob.size)}</span>
                    </div>
                `;
                downloadElement.appendChild(completionReportDownload);
                
                // Trigger download
                const url = URL.createObjectURL(blob);
                const a = document.createElement('a');
                a.href = url;
                a.download = `selected-videos-${new Date().toISOString().slice(0, 19).replace(/[:-]/g, '')}.zip`;
                document.body.appendChild(a);
                a.click();
                document.body.removeChild(a);
                
                // Clean up
                setTimeout(() => URL.revokeObjectURL(url), 10000);
                
                // Update download progress header counter for ZIP completion
                const headerElement = document.getElementById('download-progress-header');
                if (headerElement) {
                    headerElement.textContent = ` Creating ZIP Archive - Downloaded: 1 | Total files to download: 1...`;
                }
                
                // NOW show footer after download is 100% complete and triggered
                await new Promise(resolve => setTimeout(resolve, 500)); // Brief delay for user to see completion
                const footer = document.getElementById('download-modal-footer');
                const okBtn = document.getElementById('download-ok-btn');
                if (footer && okBtn) {
                    footer.style.display = 'block';
                    okBtn.style.display = 'inline-block';
                    okBtn.textContent = 'Press Ok to close this window';
                }
                
            } catch (error) {
                console.error('Error creating ZIP:', error);
                const compressionElement = document.querySelector(`#${progressId}-compression`);
                const downloadElement = document.querySelector(`#${progressId}-download`);
                
                if (compressionElement) {
                    compressionElement.querySelector('.progress-status').innerHTML = ' Failed';
                    compressionElement.querySelector('.progress-right-status').textContent = ' Failed';
                }
                if (downloadElement && downloadElement.style.display !== 'none') {
                    downloadElement.querySelector('.progress-status').innerHTML = ' Failed';
                    downloadElement.querySelector('.progress-right-status').textContent = ' Failed';
                }
                showError(`Failed to create ZIP archive: ${error.message}`);
            } finally {
                // Note: Footer will be shown after ZIP download completes successfully
            }
        }
        

        async function startDownload(videosToDownload) {
            console.log('Starting download for videos:', videosToDownload);
            
            const modal = document.getElementById('download-modal');
            const progressContainer = document.getElementById('download-modal-progress-container');
            
            // Ensure modal elements exist
            if (!modal || !progressContainer) {
                console.error('Download modal elements not found');
                alert('Download modal not properly initialized');
                return;
            }
            
            modal.style.display = 'block';
            
            // Build the progress HTML with dark theme and detailed reports
            let html = '<h3 id="download-progress-header"> Downloading Files - Downloaded: 0 | Total files to download: ' + videosToDownload.length + '...</h3>';
            videosToDownload.forEach((video, index) => {
                html += `
                    <div style="margin: 15px 0; padding: 15px; background: rgba(0,0,0,0.3); border-radius: 10px;">
                        <div style="display: flex; justify-content: space-between; margin-bottom: 10px;">
                            <span>${video.name}</span>
                            <span id="download-status-${index}"> Preparing...</span>
                        </div>
                        <div style="display: flex; justify-content: space-between; margin-bottom: 10px; font-size: 0.9em; color: white;">
                            <span id="download-percentage-${index}">0%</span>
                            <span id="download-speed-${index}">--</span>
                        </div>
                        <div style="display: flex; justify-content: space-between; margin-bottom: 20px; font-size: 0.85em; color: white;">
                            <span id="download-data-size-${index}">0 B / Calculating...</span>
                            <span id="download-time-remaining-${index}">--</span>
                        </div>
                        <div style="width: 100%; background: rgba(0,0,0,0.3); border-radius: 5px; overflow: hidden;">
                            <div id="download-progress-${index}" style="height: 10px; background: linear-gradient(90deg, #17a2b8, #28a745); width: 0%; transition: none;"></div>
                        </div>
                        <div id="download-report-${index}" style="margin-top: 15px; padding: 12px; background: rgba(0,0,0,0.6); border-radius: 8px; display: none;">
                            <div style="display: flex; justify-content: space-between; margin-bottom: 8px;">
                                <span style="color: #4CAF50;"> <strong>STARTED</strong></span>
                                <span id="download-start-time-${index}" style="color: #4CAF50;">--</span>
                                <span style="color: #2196F3;"> <strong>COMPLETED</strong></span>
                                <span id="download-end-time-${index}" style="color: #2196F3;">--</span>
                            </div>
                            <div style="display: flex; justify-content: space-between; margin-bottom: 8px;">
                                <span style="color: #FF9800;"> <strong>DURATION</strong></span>
                                <span id="download-duration-${index}" style="color: #FF9800;">--</span>
                                <span style="color: #E91E63;"> <strong>AVERAGE SPEED</strong></span>
                                <span id="download-avg-speed-${index}" style="color: #E91E63;">--</span>
                            </div>
                            <div style="text-align: center; margin-top: 8px;">
                                <span style="color: #FFC107;"> <strong>Size:</strong> <span id="download-file-size-${index}">--</span></span>
                            </div>
                        </div>
                    </div>
                `;
            });
            
            progressContainer.innerHTML = html;
            
            let completedDownloads = 0;
            let failedDownloads = 0;
            
            for (let index = 0; index < videosToDownload.length; index++) {
                const video = videosToDownload[index];
                console.log(`Starting download ${index + 1}/${videosToDownload.length}: ${video.name}`);
                
                const statusSpan = document.getElementById(`download-status-${index}`);
                const percentageSpan = document.getElementById(`download-percentage-${index}`);
                const speedSpan = document.getElementById(`download-speed-${index}`);
                const progressBar = document.getElementById(`download-progress-${index}`);
                const dataSizeSpan = document.getElementById(`download-data-size-${index}`);
                const timeRemainingSpan = document.getElementById(`download-time-remaining-${index}`);
                const reportElement = document.getElementById(`download-report-${index}`);
                const startTimeElement = document.getElementById(`download-start-time-${index}`);
                const endTimeElement = document.getElementById(`download-end-time-${index}`);
                const durationElement = document.getElementById(`download-duration-${index}`);
                const avgSpeedElement = document.getElementById(`download-avg-speed-${index}`);
                const fileSizeElement = document.getElementById(`download-file-size-${index}`);
                
                if (!statusSpan || !percentageSpan || !speedSpan || !progressBar) {
                    console.error(`Progress elements not found for index ${index}`);
                    failedDownloads++;
                    continue;
                }
                
                try {
                    const startTime = Date.now();
                    const startTimeStr = new Date(startTime).toLocaleTimeString('en-US', { hour12: false });
                    
                    statusSpan.textContent = ' Downloading...';
                    percentageSpan.textContent = '0%';
                    speedSpan.textContent = '--';
                    progressBar.style.width = '0%';
                    dataSizeSpan.textContent = '0 B / Calculating...';
                    timeRemainingSpan.textContent = '--';
                    
                    const response = await fetch(`/api/download?path=${encodeURIComponent(video.path)}`, {
                        headers: window.authHeaders
                    });
                    
                    console.log('Response status:', response.status, response.statusText);
                    
                    if (!response.ok) {
                        if (response.status === 413) {
                            throw new Error(`File too large: ${video.name}. Server limit exceeded.`);
                        }
                        throw new Error(`HTTP ${response.status}: ${response.statusText}`);
                    }
                    
                    const fileSize = parseInt(response.headers.get('content-length')) || 0;
                    const fileSizeText = fileSize > 1024*1024 ? `${(fileSize/1024/1024).toFixed(1)} MB` : `${(fileSize/1024).toFixed(1)} KB`;
                    
                    // Update with file size info
                    dataSizeSpan.textContent = `0 B / ${fileSizeText}`;
                    
                    // Update progress to show download starting
                    progressBar.style.width = '50%';
                    percentageSpan.textContent = '50%';
                    speedSpan.textContent = 'Receiving...';
                    const halfSizeText = fileSize > 1024*1024 ? `${(fileSize/2/1024/1024).toFixed(1)} MB` : `${(fileSize/2/1024).toFixed(1)} KB`;
                    dataSizeSpan.textContent = `${halfSizeText} / ${fileSizeText}`;
                    timeRemainingSpan.textContent = 'Estimating...';
                    
                    // Add real-time progress tracking for Play videos modal
                    let playModalDownloadedBytes = 0;
                    const playModalReader = response.body.getReader();
                    const playModalChunks = [];
                    
                    // Update play modal progress every 500ms
                    const playModalProgressInterval = setInterval(() => {
                        if (fileSize > 0) {
                            const percentage = Math.min(100, (playModalDownloadedBytes / fileSize) * 100);
                            const downloadedText = playModalDownloadedBytes > 1024*1024 ? 
                                `${(playModalDownloadedBytes/1024/1024).toFixed(1)} MB` : 
                                `${(playModalDownloadedBytes/1024).toFixed(1)} KB`;
                            
                            progressBar.style.width = `${percentage}%`;
                            percentageSpan.textContent = `${Math.floor(percentage)}%`;
                            dataSizeSpan.textContent = `${downloadedText} / ${fileSizeText}`;
                        }
                    }, 500);
                    
                    // Stream play modal download
                    try {
                        while (true) {
                            const { done, value } = await playModalReader.read();
                            if (done) break;
                            playModalChunks.push(value);
                            playModalDownloadedBytes += value.length;
                        }
                    } finally {
                        clearInterval(playModalProgressInterval);
                    }
                    
                    const blob = new Blob(playModalChunks);
                    const actualFileSize = blob.size;
                    const endTime = Date.now();
                    const duration = (endTime - startTime) / 1000;
                    const speed = actualFileSize / duration;
                    const speedText = speed > 1024*1024 ? `${(speed/1024/1024).toFixed(1)} MB/s` : `${(speed/1024).toFixed(1)} KB/s`;
                    const actualFileSizeText = actualFileSize > 1024*1024 ? `${(actualFileSize/1024/1024).toFixed(1)} MB` : `${(actualFileSize/1024).toFixed(1)} KB`;
                    const durationText = duration < 1 ? '0:01' : `0:${Math.floor(duration).toString().padStart(2, '0')}`;
                    const endTimeStr = new Date(endTime).toLocaleTimeString('en-US', { hour12: false });
                    
                    console.log('Downloaded blob size:', blob.size, 'bytes');
                    
                    if (blob.size === 0) {
                        throw new Error('Downloaded file is empty');
                    }
                    
                    // Create download link
                    const url = window.URL.createObjectURL(blob);
                    const a = document.createElement('a');
                    a.style.display = 'none';
                    a.href = url;
                    a.download = video.name;
                    document.body.appendChild(a);
                    a.click();
                    window.URL.revokeObjectURL(url);
                    document.body.removeChild(a);
                    
                    // Update progress to completion
                    progressBar.style.width = '100%';
                    percentageSpan.textContent = '100%';
                    statusSpan.textContent = ' Complete';
                    speedSpan.textContent = speedText;
                    dataSizeSpan.textContent = `${actualFileSizeText} / ${actualFileSizeText}`;
                    timeRemainingSpan.textContent = 'Complete';
                    
                    // Small delay to ensure user sees the completion before footer shows
                    await new Promise(resolve => setTimeout(resolve, 1000));
                    
                    completedDownloads++;
                    
                    // Update download progress header counter
                    const headerElement = document.getElementById('download-progress-header');
                    if (headerElement) {
                        headerElement.textContent = ` Downloading Files - Downloaded: ${completedDownloads + failedDownloads} | Total files to download: ${videosToDownload.length}...`;
                    }
                    
                    // Show and populate the detailed report
                    if (reportElement && startTimeElement && endTimeElement && durationElement && avgSpeedElement && fileSizeElement) {
                        reportElement.style.display = 'block';
                        startTimeElement.textContent = startTimeStr;
                        endTimeElement.textContent = endTimeStr;
                        durationElement.textContent = durationText;
                        avgSpeedElement.textContent = speedText;
                        fileSizeElement.textContent = actualFileSizeText;
                    }
                    
                } catch (error) {
                    console.error(`Error downloading ${video.name}:`, error);
                    statusSpan.textContent = ' Failed';
                    percentageSpan.textContent = 'Error';
                    speedSpan.textContent = error.message.substring(0, 20);
                    progressBar.style.background = 'linear-gradient(90deg, #dc3545, #c82333)';
                    failedDownloads++;
                    
                    // Update download progress header counter
                    const headerElement = document.getElementById('download-progress-header');
                    if (headerElement) {
                        headerElement.textContent = ` Downloading Files - Downloaded: ${completedDownloads + failedDownloads} | Total files to download: ${videosToDownload.length}...`;
                    }
                    
                    // Show error in a friendly way
                    if (error.message.includes('File too large')) {
                        showError(error.message, 'Download Error');
                    }
                }
                
                // Small delay between downloads
                await new Promise(resolve => setTimeout(resolve, 100));
            }
            
            console.log(`Download completed: ${completedDownloads} successful, ${failedDownloads} failed`);
            
            // Show the footer with completion info
            const footer = document.getElementById('download-modal-footer');
            const okBtn = document.getElementById('download-ok-btn');
            if (footer && okBtn) {
                footer.style.display = 'block';
                okBtn.style.display = 'inline-block';
                okBtn.textContent = 'Press Ok to close this window';
            }
        }

        function closeDownloadModal() {
            document.getElementById('download-modal').style.display = 'none';
        }
        
        function closeIndividualDownloadModal() {
            document.getElementById('individual-download-modal').style.display = 'none';
        }

        // ====================================
        // PLAYLIST MANAGEMENT FUNCTIONS
        // ====================================

        // Note: Folder creation is now handled automatically by the file creation process

        // Show playlist name input modal
        function showPlaylistNameModal() {
            const modal = document.createElement('div');
            modal.className = 'modal';
            modal.style.display = 'block';
            modal.innerHTML = `
                <div class="modal-content playlist-modal-content" style="width: fit-content !important; max-width: 300px !important; min-width: 250px !important; padding: 15px !important; margin: 20% auto !important; height: auto !important;">
                    <div style="display: flex; align-items: center; justify-content: space-between; margin-bottom: 12px;">
                        <h3 style="margin: 0; font-size: 14px; color: #28a745;"> New Playlist</h3>
                        <button class="close" onclick="this.closest('.modal').remove()" style="background: none; border: none; color: #ccc; font-size: 18px; cursor: pointer;">&times;</button>
                    </div>
                    <input type="text" id="playlistNameInput" placeholder="Playlist name..." 
                           style="width: 100%; padding: 6px 8px; background: rgba(0,0,0,0.8); border: 1px solid #28a745; border-radius: 4px; color: white; font-size: 13px; margin-bottom: 12px; box-sizing: border-box;">
                    <div style="display: flex; gap: 8px; justify-content: flex-end;">
                        <button onclick="this.closest('.modal').remove()" 
                                style="padding: 6px 12px; background: #6c757d; color: white; border: none; border-radius: 3px; cursor: pointer; font-size: 12px;">
                            Cancel
                        </button>
                        <button onclick="handlePlaylistNameSubmit()" 
                                style="padding: 6px 12px; background: #28a745; color: white; border: none; border-radius: 3px; cursor: pointer; font-size: 12px;">
                            Create
                        </button>
                    </div>
                </div>
            `;
            document.body.appendChild(modal);
            
            // Focus on input and handle Enter key
            const input = document.getElementById('playlistNameInput');
            input.focus();
            input.addEventListener('keypress', (e) => {
                if (e.key === 'Enter') {
                    handlePlaylistNameSubmit();
                }
            });
        }

        // Handle playlist name submission
        async function handlePlaylistNameSubmit() {
            const input = document.getElementById('playlistNameInput');
            const playlistName = input.value.trim();
            
            if (!playlistName) {
                input.style.borderColor = '#dc3545';
                return;
            }

            // Validate playlist name
            const sanitizedName = playlistName.replace(/[^a-zA-Z0-9\s\-_]/g, '').replace(/\s+/g, '_');
            if (!sanitizedName) {
                showPlaylistErrorModal('Invalid Name', 'Playlist name must contain at least some valid characters (letters, numbers, spaces, hyphens, underscores).');
                return;
            }

            // Close the name input modal
            document.querySelector('.modal').remove();

            // Show loading
            showPlaylistLoadingModal();

            console.log('=== VALIDATION START ===');
            console.log('User entered:', playlistName);
            console.log('Sanitized to:', sanitizedName);
            console.log('Looking for file:', `video_system_playlist_${sanitizedName}.txt`);

            // Check if playlist file already exists
            // For user input "ambassador" -> look for "video_system_playlist_ambassador.txt"
            const targetFileName = `video_system_playlist_${sanitizedName}.txt`;
            const targetDirectory = '/home/gus/video-system/docs/video_system_saved_playlists';
            
            console.log('Checking for existing playlist file:');
            console.log('- Directory:', targetDirectory);
            console.log('- Filename:', targetFileName);
            
            let playlistExists = false;
            let existingLocation = '';

            try {
                // Use the new dedicated API endpoint for playlist validation
                console.log('Calling playlist validation API...');
                
                const validationResponse = await fetch('/api/validate_existing_playlist', {
                    method: 'POST',
                    headers: {
                        ...window.authHeaders,
                        'Content-Type': 'application/json'
                    },
                    body: JSON.stringify({
                        playlist_name: playlistName
                    })
                });
                
                if (validationResponse.ok) {
                    const result = await validationResponse.json();
                    console.log('Validation API result:', result);
                    
                    if (result.exists === true) {
                        playlistExists = true;
                        existingLocation = targetDirectory;
                        console.log('*** FILE EXISTS - Confirmed via validation API ***');
                        console.log('File path:', result.path);
                    } else {
                        console.log('File does not exist - Confirmed via validation API');
                    }
                } else {
                    console.log('Validation API failed, status:', validationResponse.status);
                    const errorText = await validationResponse.text();
                    console.log('Error details:', errorText);
                }
            } catch (error) {
                console.log('Error during playlist validation:', error);
            }

            // Close loading modal
            const loadingModal = document.querySelector('.playlist-loading-modal');
            if (loadingModal) loadingModal.remove();

            console.log('=== VALIDATION RESULT ===');
            if (playlistExists) {
                console.log('RESULT: Playlist EXISTS at:', existingLocation);
                console.log('ACTION: Showing rename modal');
                showPlaylistExistsModal(playlistName, sanitizedName, existingLocation);
                return;
            }

            console.log('RESULT: Playlist does NOT exist');
            console.log('ACTION: Creating new playlist');
            await createPlaylistFile(playlistName, sanitizedName);
        }

        // Create playlist file
        async function createPlaylistFile(playlistName, sanitizedName) {
            try {
                // Try to create the playlist file
                const createResponse = await fetch('/api/create-file', {
                    method: 'POST',
                    headers: {
                        ...window.authHeaders,
                        'Content-Type': 'application/json'
                    },
                    body: JSON.stringify({
                        path: `/home/gus/video-system/docs/video_system_saved_playlists/video_system_playlist_${sanitizedName}.txt`,
                        content: `# Playlist: ${playlistName}\n# Created: ${new Date().toISOString()}\n# Videos will be listed below in order:\n\n`
                    })
                });

                if (createResponse.ok) {
                    showPlaylistSuccessModal('Playlist Created Successfully!', `Successfully created playlist: <span style="color: #ffd700; font-weight: bold; text-shadow: 0 0 8px rgba(255, 215, 0, 0.8);">${playlistName}</span>. Go back to the Add Videos section, to add videos to the playlist.`, 'primary');
                    console.log(`User created new playlist: ${playlistName}`);
                } else {
                    // Try fallback location
                    const fallbackResponse = await fetch('/api/create-file', {
                        method: 'POST',
                        headers: {
                            ...window.authHeaders,
                            'Content-Type': 'application/json'
                        },
                        body: JSON.stringify({
                            path: `/home/gus/video-system/docs/video_system_playlist_${sanitizedName}.txt`,
                            content: `# Playlist: ${playlistName}\n# Created: ${new Date().toISOString()}\n# Videos will be listed below in order:\n\n`
                        })
                    });

                    if (fallbackResponse.ok) {
                        showPlaylistSuccessModal('Playlist Created Successfully!', `Successfully created playlist: <span style="color: #ffd700; font-weight: bold; text-shadow: 0 0 8px rgba(255, 215, 0, 0.8);">${playlistName}</span>. Go back to the Add Videos section, to add videos to the playlist.`, 'fallback');
                        console.log(`User created new playlist: ${playlistName} (fallback location)`);
                    } else {
                        showPlaylistErrorModal('Creation Failed', `Could not create playlist "${playlistName}". Please try again or contact support.`);
                    }
                }

            } catch (error) {
                console.log('Error creating playlist:', error);
                showPlaylistErrorModal('Creation Failed', `Could not create playlist "${playlistName}". Please try again.`);
            }
        }

        // Show loading modal
        function showPlaylistLoadingModal() {
            const modal = document.createElement('div');
            modal.className = 'modal playlist-loading-modal';
            modal.style.display = 'block';
            modal.innerHTML = `
                <div class="modal-content playlist-modal-content" style="width: fit-content !important; max-width: 200px !important; padding: 15px !important; margin: 25% auto !important; height: auto !important; text-align: center;">
                    <div style="font-size: 20px; margin-bottom: 8px;"></div>
                    <div style="color: #28a745; font-size: 13px; margin-bottom: 10px;">Validating...</div>
                    <div style="width: 120px; background: rgba(0,0,0,0.3); border-radius: 4px; overflow: hidden;">
                        <div style="height: 3px; background: linear-gradient(90deg, #28a745, #20c997); width: 100%; animation: loading-bar 2s ease-in-out infinite;"></div>
                    </div>
                </div>
            `;
            document.body.appendChild(modal);
        }

        // Show success modal
        function showPlaylistSuccessModal(title, message, type) {
            const modal = document.createElement('div');
            modal.className = 'modal';
            modal.style.cssText = `
                display: block;
                position: fixed;
                z-index: 10001;
                left: 0;
                top: 0;
                width: 100%;
                height: 100%;
                background: rgba(0, 0, 0, 0.9);
                backdrop-filter: blur(10px);
                animation: modalFadeIn 0.3s ease-out;
            `;
            
            const locationText = type === 'fallback' ? 
                '<p style="color: #ffc107; font-size: 14px; margin-top: 15px; font-style: italic;"><i> Created in docs folder</i></p>' : '';
            
            // Handle legacy calls (playlistName, type) and new calls (title, message)
            const displayTitle = message ? title : 'Success!';
            const displayMessage = message ? message : `"${title}" playlist created!`;
            
            modal.innerHTML = `
                <div class="modal-content playlist-modal-content" style="
                    width: 90% !important; 
                    max-width: 800px !important; 
                    min-width: 600px !important; 
                    margin: 15% auto !important; 
                    padding: 0 !important; 
                    height: auto !important; 
                    text-align: center;
                    background: #000000;
                    border: 3px solid #28a745;
                    border-radius: 20px;
                    box-shadow: 
                        0 0 30px rgba(40, 167, 69, 0.4),
                        0 0 60px rgba(40, 167, 69, 0.2),
                        inset 0 0 20px rgba(40, 167, 69, 0.1);
                    animation: successPulse 0.6s ease-out;
                ">
                    <div class="modal-header" style="
                        background: #000000;
                        padding: 15px; 
                        border-radius: 17px 17px 0 0;
                        border-bottom: 3px solid #28a745;
                        position: relative;
                        overflow: hidden;
                    ">
                        <div style="position: absolute; top: 0; left: 0; right: 0; height: 3px; background: linear-gradient(90deg, transparent, #28a745, transparent); animation: shimmer 2s infinite;"></div>
                        <h2 style="
                            color: #28a745; 
                            font-size: 20px; 
                            margin: 0;
                            text-shadow: 0 0 10px rgba(40, 167, 69, 0.8);
                            font-weight: 700;
                            display: flex;
                            align-items: center;
                            justify-content: center;
                            gap: 15px;
                        ">
                            <span style="font-size: 28px; color: #28a745;"></span>
                            <span style="color: #28a745;">
                                ${displayTitle}
                            </span>
                        </h2>
                        <button class="close" onclick="this.closest('.modal').remove()" style="
                            position: absolute;
                            top: 20px;
                            right: 20px;
                            background: #000000 !important; 
                            color: #28a745 !important; 
                            border: 2px solid #28a745; 
                            border-radius: 50%; 
                            width: 45px; 
                            height: 45px; 
                            font-size: 20px; 
                            font-weight: bold; 
                            cursor: pointer;
                            box-shadow: 0 0 15px rgba(40, 167, 69, 0.6); 
                            transition: all 0.3s ease;
                        " 
                        onmouseover="this.style.transform='scale(1.1) rotate(90deg)'; this.style.boxShadow='0 0 25px rgba(40, 167, 69, 0.8)';" 
                        onmouseout="this.style.transform='scale(1) rotate(0deg)'; this.style.boxShadow='0 0 15px rgba(40, 167, 69, 0.6)';"></button>
                    </div>
                    <div class="modal-body" style="
                        padding: 20px; 
                        background: #000000;
                        border-radius: 0 0 17px 17px;
                    ">
                        <div style="
                            font-size: 48px; 
                            margin-bottom: 20px; 
                            animation: bounce 1.5s ease-in-out infinite;
                            filter: drop-shadow(0 0 10px rgba(40, 167, 69, 0.5));
                        "></div>
                        <p style="
                            color: #28a745; 
                            margin-bottom: 20px; 
                            font-size: 14px; 
                            line-height: 1.6;
                            max-width: 600px;
                            margin-left: auto;
                            margin-right: auto;
                            text-shadow: 0 0 5px rgba(40, 167, 69, 0.8);
                        ">${displayMessage}</p>
                        ${locationText}
                        <div style="margin-top: 20px;">
                            <button onclick="closeAllModals()" style="
                                padding: 10px 30px; 
                                background: #000000; 
                                color: #28a745; 
                                border: 2px solid #28a745; 
                                border-radius: 12px; 
                                cursor: pointer; 
                                font-weight: bold; 
                                font-size: 14px;
                                box-shadow: 
                                    0 8px 16px rgba(40, 167, 69, 0.3),
                                    0 0 20px rgba(40, 167, 69, 0.2);
                                transition: all 0.3s ease;
                                text-transform: uppercase;
                                letter-spacing: 1px;
                                text-shadow: 0 0 5px rgba(40, 167, 69, 0.8);
                            " 
                            onmouseover="this.style.transform='translateY(-2px)'; this.style.boxShadow='0 12px 24px rgba(40, 167, 69, 0.4), 0 0 30px rgba(40, 167, 69, 0.3)';" 
                            onmouseout="this.style.transform='translateY(0)'; this.style.boxShadow='0 8px 16px rgba(40, 167, 69, 0.3), 0 0 20px rgba(40, 167, 69, 0.2)';">
                                 Got It!
                            </button>
                        </div>
                    </div>
                </div>
            `;
            document.body.appendChild(modal);
            
            // Close on background click
            modal.addEventListener('click', (e) => {
                if (e.target === modal) {
                    modal.remove();
                }
            });
        }

        // Show error modal
        function showPlaylistErrorModal(title, message) {
            const modal = document.createElement('div');
            modal.className = 'modal';
            modal.style.display = 'block';
            modal.innerHTML = `
                <div class="modal-content playlist-modal-content" style="width: fit-content !important; max-width: 350px !important; min-width: 280px !important; margin: 20% auto !important; padding: 0 !important; height: auto !important;">
                    <div class="modal-header" style="background: linear-gradient(135deg, #dc3545, #c82333); padding: 12px; border-radius: 8px 8px 0 0;">
                        <h2 style="color: white; font-size: 14px; margin: 0;"> Playlist stopped: <span style="background: rgba(255, 215, 0, 0.3); color: #ffd700; padding: 2px 6px; border-radius: 3px; border: 1px solid #ffd700;">${title}</span></h2>
                        <button class="close" onclick="this.closest('.modal').remove()" style="color: white; background: none; border: none; font-size: 18px; cursor: pointer; float: right;">&times;</button>
                    </div>
                    <div class="modal-body" style="padding: 18px; text-align: center;">
                        <div style="font-size: 24px; margin-bottom: 10px;"></div>
                        <p style="color: #e0e0e0; margin-bottom: 15px; font-size: 13px; line-height: 1.4;">${message}</p>
                        <button onclick="this.closest('.modal').remove()" 
                                style="padding: 8px 16px; background: #dc3545; color: white; border: none; border-radius: 4px; cursor: pointer; font-size: 12px;">
                            OK
                        </button>
                    </div>
                </div>
            `;
            document.body.appendChild(modal);
        }

        // Show playlist exists modal with rename option
        function showPlaylistExistsModal(originalName, sanitizedName, existingLocation) {
            const modal = document.createElement('div');
            modal.className = 'modal';
            modal.style.display = 'block';
            modal.innerHTML = `
                <div class="modal-content playlist-modal-content" style="width: fit-content !important; max-width: 900px !important; min-width: 760px !important; margin: 15% auto !important; padding: 0 !important; height: auto !important;">
                    <div class="modal-header" style="background: #000000; padding: 12px; border-radius: 8px 8px 0 0;">
                        <h2 style="color: #ffc107; font-size: 14px; margin: 0;"> Playlist Already Exists</h2>
                        <button class="close" onclick="this.closest('.modal').remove()" style="color: #ffc107; background: none; border: none; font-size: 18px; cursor: pointer; float: right;">&times;</button>
                    </div>
                    <div class="modal-body" style="padding: 20px;">
                        <div style="text-align: center; margin-bottom: 18px;">
                            <div style="font-size: 32px; margin-bottom: 8px;"></div>
                            <h3 style="color: #ffc107; margin-bottom: 6px; font-size: 16px;">"${originalName}"</h3>
                            <p style="color: #e0e0e0; font-size: 13px; margin-bottom: 12px;">A playlist with this name already exists.</p>
                            <div style="background: rgba(255, 193, 7, 0.1); border: 1px solid #ffc107; border-radius: 6px; padding: 10px; margin: 10px 0; text-align: left;">
                                <p style="color: #ffc107; font-weight: bold; margin-bottom: 6px; font-size: 12px;"> Location:</p>
                                <p style="color: #ccc; font-size: 11px; word-break: break-all;">${existingLocation}/video_system_playlist_${sanitizedName}.txt</p>
                            </div>
                        </div>
                        
                        <div style="margin-bottom: 18px;">
                            <label style="color: #e0e0e0; font-size: 13px; margin-bottom: 6px; display: block;">Rename to:</label>
                            <input type="text" id="renamePlaylistInput" placeholder="Enter new playlist name..." 
                                   value="${originalName}" 
                                   style="width: 100%; padding: 8px; background: rgba(0,0,0,0.8); border: 2px solid #ffc107; border-radius: 6px; color: white; font-size: 14px; margin-bottom: 8px; box-sizing: border-box;">
                            <p style="color: #888; font-size: 11px; margin-bottom: 12px;">
                                <i>Choose a different name for your new playlist</i>
                            </p>
                        </div>
                        
                        <div style="display: flex; gap: 10px; justify-content: space-between;">
                            <button onclick="this.closest('.modal').remove()" 
                                    style="padding: 8px 14px; background: #6c757d; color: white; border: none; border-radius: 4px; cursor: pointer; font-size: 13px; flex: 1;">
                                Cancel
                            </button>
                            <button onclick="handlePlaylistRename()" 
                                    style="padding: 8px 14px; background: #28a745; color: white; border: none; border-radius: 4px; cursor: pointer; font-weight: bold; font-size: 13px; flex: 2;">
                                Create with New Name
                            </button>
                        </div>
                    </div>
                </div>
            `;
            document.body.appendChild(modal);
            
            // Focus on rename input and handle Enter key
            const renameInput = document.getElementById('renamePlaylistInput');
            renameInput.focus();
            renameInput.select(); // Select all text for easy editing
            renameInput.addEventListener('keypress', (e) => {
                if (e.key === 'Enter') {
                    handlePlaylistRename();
                }
            });
        }

        // Handle playlist rename and create with new name
        async function handlePlaylistRename() {
            const input = document.getElementById('renamePlaylistInput');
            const newPlaylistName = input.value.trim();
            
            if (!newPlaylistName) {
                input.style.borderColor = '#dc3545';
                return;
            }

            // Validate new playlist name
            const newSanitizedName = newPlaylistName.replace(/[^a-zA-Z0-9\s\-_]/g, '').replace(/\s+/g, '_');
            if (!newSanitizedName) {
                input.style.borderColor = '#dc3545';
                return;
            }

            // Close the exists modal
            document.querySelector('.modal').remove();

            // Show loading
            showPlaylistLoadingModal();

            try {
                // Use the new playlist validation API to check if the new name exists
                console.log('Checking if new playlist name exists:', newPlaylistName);
                
                const validationResponse = await fetch('/api/validate_existing_playlist', {
                    method: 'POST',
                    headers: {
                        ...window.authHeaders,
                        'Content-Type': 'application/json'
                    },
                    body: JSON.stringify({
                        playlist_name: newPlaylistName
                    })
                });
                
                let newNameExists = false;
                
                if (validationResponse.ok) {
                    const result = await validationResponse.json();
                    console.log('New name validation result:', result);
                    newNameExists = result.exists;
                } else {
                    console.log('Validation API failed for new name, status:', validationResponse.status);
                    throw new Error('Validation API failed');
                }

                // Close loading modal
                const loadingModal = document.querySelector('.playlist-loading-modal');
                if (loadingModal) loadingModal.remove();

                if (newNameExists) {
                    // New name also exists, show error and ask to try again
                    showPlaylistErrorModal('Name Still Exists', `The name "${newPlaylistName}" is also already taken. Please choose a different name.`);
                    return;
                }

                // Proceed with creation using the new name
                await createPlaylistFile(newPlaylistName, newSanitizedName);

            } catch (error) {
                // Close loading modal
                const loadingModal = document.querySelector('.playlist-loading-modal');
                if (loadingModal) loadingModal.remove();
                
                console.log('Error checking renamed playlist:', error);
                showPlaylistErrorModal('Check Failed', `Could not verify if new playlist name exists. Please try again.`);
            }
        }

        // Close only playlist-related modals and return to main video search modal
        function closeAllModals() {
            // Remove only playlist-related modals (those with playlist-modal-content class)
            const playlistModals = document.querySelectorAll('.modal .playlist-modal-content');
            playlistModals.forEach(content => {
                const modal = content.closest('.modal');
                if (modal) modal.remove();
            });
            
            // Also remove any remaining modals that don't have specific IDs (playlist modals)
            const modals = document.querySelectorAll('.modal:not([id])');
            modals.forEach(modal => {
                // Only remove if it's not a main system modal
                if (!modal.id || (!modal.id.includes('manageModal') && !modal.id.includes('videoSearchModal'))) {
                    modal.remove();
                }
            });
            
            // Ensure the main search modal is visible if it exists
            const searchModal = document.getElementById('manageModal');
            if (searchModal) {
                searchModal.style.display = 'block';
            }
        }

        // Create new playlist - entry point
        function createNewPlaylist() {
            showPlaylistNameModal();
        }

        // Edit playlist (Phase 3 - placeholder)
        async function editPlaylist() {
            console.log('Edit Playlist button clicked');
            
            // Show loading
            showPlaylistLoadingModal();
            
            try {
                // Get existing playlists
                const playlists = await getExistingPlaylists();
                
                // Close loading modal
                const loadingModal = document.querySelector('.playlist-loading-modal');
                if (loadingModal) loadingModal.remove();
                
                if (playlists.length === 0) {
                    showPlaylistErrorModal('No Playlists Found', 'You need to create at least one playlist before editing. Please create a new playlist first.');
                    return;
                }
                
                // Show playlist selection modal for editing
                showPlaylistEditSelectionModal(playlists);
                
            } catch (error) {
                console.error('Error loading playlists for editing:', error);
                const loadingModal = document.querySelector('.playlist-loading-modal');
                if (loadingModal) loadingModal.remove();
                showPlaylistErrorModal('Error Loading Playlists', 'Failed to load playlists. Please try again.');
            }
        }

        // Delete playlist (Phase 4 - placeholder)  
        function deletePlaylist() {
            showInfoModal('Delete Playlist', 'Delete playlist functionality will be available in Phase 4 of the implementation. This will allow you to delete existing playlists with confirmation.');
        }

        // Show all playlists (Phase 4 - placeholder)
        function showAllPlaylists() {
            console.log('Opening Show All Playlists modal');
            
            // Create modal HTML
            const modal = document.createElement('div');
            modal.className = 'modal';
            modal.style.cssText = `
                position: fixed;
                top: 0;
                left: 0;
                width: 100%;
                height: 100%;
                background: rgba(0,0,0,0.8);
                display: flex;
                justify-content: center;
                align-items: center;
                z-index: 1000;
                backdrop-filter: blur(5px);
            `;
            
            modal.innerHTML = `
                <div style="
                    background: linear-gradient(145deg, #1a1a1a, #2d2d2d);
                    border-radius: 15px;
                    padding: 20px;
                    min-width: 800px;
                    max-width: 1000px;
                    max-height: 80vh;
                    border: 2px solid #17a2b8;
                    box-shadow: 0 10px 30px rgba(0,0,0,0.5);
                    display: flex;
                    flex-direction: column;
                ">
                    <!-- Modal Header -->
                    <div style="display: flex; justify-content: space-between; align-items: center; margin-bottom: 20px; border-bottom: 2px solid #17a2b8; padding-bottom: 15px;">
                        <h2 style="color: #17a2b8; font-size: 20px; margin: 0; font-weight: bold;"> Show All Playlists</h2>
                        <button onclick="this.closest('.modal').remove()" style="background: #dc3545; color: white; border: none; border-radius: 50%; width: 30px; height: 30px; cursor: pointer; font-size: 16px; font-weight: bold;"></button>
                    </div>
                    
                    <!-- Search Section -->
                    <div style="display: flex; gap: 10px; margin-bottom: 20px; align-items: center;">
                        <input type="text" id="playlistSearchInput" placeholder="Search playlists..." style="flex: 1; padding: 10px; background: rgba(0,0,0,0.8); border: 2px solid #17a2b8; border-radius: 8px; color: white; font-size: 14px;" oninput="searchPlaylists()">
                        <button onclick="searchPlaylists()" style="padding: 10px 20px; background: #000000; color: #17a2b8; border: 2px solid #17a2b8; border-radius: 8px; cursor: pointer; font-weight: bold; box-shadow: 0 0 10px rgba(23, 162, 184, 0.5); transition: all 0.3s ease;" onmouseover="this.style.transform='scale(1.05)'; this.style.boxShadow='0 0 20px rgba(23, 162, 184, 0.8)'; this.style.textShadow='0 0 10px #17a2b8';" onmouseout="this.style.transform='scale(1)'; this.style.boxShadow='0 0 10px rgba(23, 162, 184, 0.5)'; this.style.textShadow='none';"> Find</button>
                        <button onclick="loadAllPlaylists()" style="padding: 10px 20px; background: #000000; color: #28a745; border: 2px solid #28a745; border-radius: 8px; cursor: pointer; font-weight: bold; box-shadow: 0 0 10px rgba(40, 167, 69, 0.5); transition: all 0.3s ease;" onmouseover="this.style.transform='scale(1.05)'; this.style.boxShadow='0 0 20px rgba(40, 167, 69, 0.8)'; this.style.textShadow='0 0 10px #28a745';" onmouseout="this.style.transform='scale(1)'; this.style.boxShadow='0 0 10px rgba(40, 167, 69, 0.5)'; this.style.textShadow='none';"> Show All</button>
                    </div>
                    
                    <!-- Playlists Results -->
                    <div id="allPlaylistsResults" style="flex: 1; overflow-y: auto; border: 2px solid #17a2b8; border-radius: 8px; background: rgba(0,0,0,0.4); padding: 15px; min-height: 400px; max-height: 500px;">
                        <div style="text-align: center; color: #888; padding: 40px;">
                            <div style="font-size: 48px; margin-bottom: 15px;"></div>
                            <div>Loading playlists...</div>
                        </div>
                    </div>
                </div>
            `;
            
            document.body.appendChild(modal);
            
            // Load all playlists
            loadAllPlaylists();
        }

        // Load all playlists from server
        async function loadAllPlaylists() {
            console.log('Loading all playlists...');
            const resultsContainer = document.getElementById('allPlaylistsResults');
            
            if (!resultsContainer) return;
            
            try {
                // Show loading state
                resultsContainer.innerHTML = `
                    <div style="text-align: center; color: #888; padding: 40px;">
                        <div style="font-size: 48px; margin-bottom: 15px;"></div>
                        <div>Loading playlists...</div>
                    </div>
                `;
                
                const response = await fetch('/api/playlists', {
                    method: 'GET',
                    headers: {
                        ...window.authHeaders
                    }
                });
                
                if (response.ok) {
                    const data = await response.json();
                    displayAllPlaylists(data.playlists || []);
                } else {
                    throw new Error('Failed to load playlists');
                }
            } catch (error) {
                console.error('Error loading playlists:', error);
                resultsContainer.innerHTML = `
                    <div style="text-align: center; color: #dc3545; padding: 40px;">
                        <div style="font-size: 48px; margin-bottom: 15px;"></div>
                        <div>Error loading playlists</div>
                        <div style="font-size: 12px; margin-top: 10px; color: #888;">${error.message}</div>
                    </div>
                `;
            }
        }

        // Display all playlists in the modal
        function displayAllPlaylists(playlists) {
            const resultsContainer = document.getElementById('allPlaylistsResults');
            
            if (!playlists || playlists.length === 0) {
                resultsContainer.innerHTML = `
                    <div style="text-align: center; color: #888; padding: 40px;">
                        <div style="font-size: 48px; margin-bottom: 15px;"></div>
                        <div>No playlists found</div>
                        <div style="font-size: 12px; margin-top: 10px;">Create your first playlist to get started!</div>
                    </div>
                `;
                return;
            }
            
            const playlistsHTML = playlists.map(playlist => `
                <div style="display: flex; align-items: center; padding: 15px; border-bottom: 1px solid #333; margin-bottom: 8px; background: rgba(0,0,0,0.3); border-radius: 8px; transition: all 0.3s ease;">
                    <div style="flex: 1; color: #e0e0e0;">
                        <div style="font-size: 16px; font-weight: bold; margin-bottom: 5px; color: #17a2b8;"> ${playlist.name}</div>
                    </div>
                    <button onclick="openPlaylistModal('${playlist.name}', '${playlist.filename}')" 
                            style="padding: 10px 20px; background: #000000; color: #17a2b8; border: 2px solid #17a2b8; border-radius: 8px; cursor: pointer; font-weight: bold; transition: all 0.3s ease; margin-left: 15px;">
                         Open Playlist
                    </button>
                </div>
            `).join('');
            
            resultsContainer.innerHTML = `
                <div style="margin-bottom: 15px; color: #17a2b8; font-weight: bold;">
                    Found ${playlists.length} playlist${playlists.length !== 1 ? 's' : ''}
                </div>
                ${playlistsHTML}
            `;
        }

        // Search playlists
        function searchPlaylists() {
            const searchTerm = document.getElementById('playlistSearchInput')?.value.toLowerCase().trim();
            const allPlaylistItems = document.querySelectorAll('#allPlaylistsResults > div > div');
            
            if (!searchTerm) {
                // Show all playlists if no search term
                allPlaylistItems.forEach(item => item.style.display = 'flex');
                return;
            }
            
            // Filter playlists by search term
            allPlaylistItems.forEach(item => {
                const playlistName = item.querySelector('[style*="font-weight: bold"]')?.textContent.toLowerCase() || '';
                const filename = item.querySelector('[style*="font-size: 12px"]')?.textContent.toLowerCase() || '';
                
                if (playlistName.includes(searchTerm) || filename.includes(searchTerm)) {
                    item.style.display = 'flex';
                } else {
                    item.style.display = 'none';
                }
            });
        }

        // Open individual playlist content modal
        async function openPlaylistModal(playlistName, filename) {
            console.log('Opening playlist content modal for:', playlistName);
            
            // Create loading modal first
            const modal = document.createElement('div');
            modal.className = 'modal';
            modal.style.cssText = `
                position: fixed;
                top: 0;
                left: 0;
                width: 100%;
                height: 100%;
                background: rgba(0,0,0,0.8);
                display: flex;
                justify-content: center;
                align-items: center;
                z-index: 1001;
                backdrop-filter: blur(5px);
            `;
            
            // Initial loading content
            modal.innerHTML = `
                <div style="
                    background: linear-gradient(145deg, #1a1a1a, #2d2d2d);
                    border-radius: 15px;
                    padding: 20px;
                    min-width: 1100px;
                    max-width: 1400px;
                    max-height: 95vh;
                    border: 2px solid #17a2b8;
                    box-shadow: 0 10px 30px rgba(0,0,0,0.5);
                    display: flex;
                    flex-direction: column;
                ">
                    <!-- Modal Header -->
                    <div style="display: flex; justify-content: space-between; align-items: center; margin-bottom: 20px; border-bottom: 2px solid #17a2b8; padding-bottom: 15px;">
                        <h2 style="color: #17a2b8; font-size: 20px; margin: 0; font-weight: bold;"> Videos from playlist: <span style="background: rgba(255, 215, 0, 0.2); color: #ffd700; padding: 4px 8px; border-radius: 4px; border: 1px solid #ffd700;">${playlistName}</span></h2>
                        <button onclick="this.closest('.modal').remove()" style="background: #dc3545; color: white; border: none; border-radius: 50%; width: 30px; height: 30px; cursor: pointer; font-size: 16px; font-weight: bold;"></button>
                    </div>
                    
                    <!-- Loading Content -->
                    <div id="playlistContentArea" style="flex: 1; overflow-y: auto; border: 2px solid #17a2b8; border-radius: 8px; background: rgba(0,0,0,0.4); padding: 20px; min-height: 600px;">
                        <div style="text-align: center; color: #888; padding: 40px;">
                            <div style="font-size: 48px; margin-bottom: 15px;"></div>
                            <div>Loading playlist content...</div>
                        </div>
                    </div>
                </div>
            `;
            
            document.body.appendChild(modal);
            
            // Load playlist content
            try {
                const response = await fetch('/api/open_playlist_content', {
                    method: 'POST',
                    headers: {
                        'Content-Type': 'application/json',
                        ...window.authHeaders
                    },
                    body: JSON.stringify({
                        playlist_name: playlistName,
                        playlist_filename: filename
                    })
                });
                
                if (response.ok) {
                    const data = await response.json();
                    displayPlaylistContent(data, modal);
                } else {
                    throw new Error('Failed to load playlist content');
                }
            } catch (error) {
                console.error('Error loading playlist content:', error);
                const contentArea = modal.querySelector('#playlistContentArea');
                contentArea.innerHTML = `
                    <div style="text-align: center; color: #dc3545; padding: 40px;">
                        <div style="font-size: 48px; margin-bottom: 15px;"></div>
                        <div>Error loading playlist content</div>
                        <div style="font-size: 12px; margin-top: 10px; color: #888;">${error.message}</div>
                    </div>
                `;
            }
        }

        // Display playlist content with videos
        function displayPlaylistContent(data, modal) {
            const contentArea = modal.querySelector('#playlistContentArea');
            
            console.log('Playlist data received:', data);
            
            if (!data.videos || data.videos.length === 0) {
                contentArea.innerHTML = `
                    <div style="text-align: center; color: #888; padding: 40px;">
                        <div style="font-size: 48px; margin-bottom: 15px;"></div>
                        <div>No videos found in this playlist</div>
                        <div style="font-size: 12px; margin-top: 10px;">The playlist might be empty or contain invalid paths.</div>
                    </div>
                `;
                return;
            }
            
            // Filter out non-existent videos and create content with action buttons and video list
            const validVideos = data.videos.filter(video => video.exists === true);
            console.log(`Filtered ${data.videos.length} total videos down to ${validVideos.length} valid videos`);
            
            // Store original videos globally for search filtering
            originalPlaylistVideos = validVideos.map(video => ({
                name: video.name,
                path: video.path,
                size: video.size,
                playlistName: data.playlist_name
            }));
            
            const videosHTML = validVideos.map((video, index) => {
                // Use the full path that's already provided by the API
                const fullPath = video.path;
                const thumbnailPath = fullPath;
                
                console.log('Valid Video', index, ':', {
                    name: video.name,
                    path: video.path, 
                    size: video.size,
                    exists: video.exists
                }); // Debug individual video data
                
                return `
                    <div style="display: flex; align-items: center; padding: 12px; margin-bottom: 8px; background: black; border: 2px solid #28a745; border-radius: 8px; transition: all 0.3s ease;">
                        <!-- Checkbox -->
                        <input type="checkbox" id="playlistVideo_${index}" style="margin-right: 15px; transform: scale(1.2);">
                        
                        <!-- Thumbnail -->
                        <div class="video-thumbnail-container" id="playlist-thumb-${index}"
                             onmouseenter="handleThumbnailHover('${video.name}', '${video.path}', 'playlist-thumb-${index}')"
                             onmouseleave="handleThumbnailLeave('playlist-thumb-${index}')"
                             onclick="handleThumbnailHover('${video.name}', '${video.path}', 'playlist-thumb-${index}')"
                             style="width: 120px; height: 80px; border: 2px solid #17a2b8; margin-right: 15px;">
                            <div class="video-thumbnail-placeholder"></div>
                            <div class="video-thumbnail-loading" style="display: none;">Loading...</div>
                            <video class="video-thumbnail" muted></video>
                        </div>
                        
                        <!-- Video Info -->
                        <div style="flex: 1; color: #e0e0e0;">
                            <div style="font-size: 14px; font-weight: bold; margin-bottom: 3px; color: #17a2b8; cursor: pointer;"
                                 onmouseenter="handleThumbnailHover('${video.name}', '${video.path}', 'playlist-thumb-${index}')"
                                 onmouseleave="handleThumbnailLeave('playlist-thumb-${index}')"
                                 onclick="handleThumbnailHover('${video.name}', '${video.path}', 'playlist-thumb-${index}')">${video.name}</div>
                            <div style="font-size: 13px; color: white; margin-bottom: 3px; font-weight: bold;">${video.size || 'Loading...'}</div>
                            <div style="font-size: 12px; color: white; word-break: break-all;">${video.path}</div>
                        </div>
                        
                        <!-- Individual Play Button -->
                        <button onclick="playIndividualPlaylistVideo('${fullPath}', '${data.playlist_name}')" 
                                style="padding: 8px 16px; background: #000000; color: #28a745; border: 2px solid #28a745; border-radius: 6px; cursor: pointer; font-weight: bold; font-size: 12px; margin-left: 10px;">
                             Play
                        </button>
                    </div>
                `;
            }).join('');
            
            contentArea.innerHTML = `
                <!-- Action Buttons -->
                <div style="display: flex; gap: 10px; margin-bottom: 20px; flex-wrap: wrap; justify-content: center;">
                    <button onclick="playEntirePlaylist('${data.playlist_name}', ${JSON.stringify(validVideos).replace(/"/g, '&quot;')})" 
                            style="padding: 12px 24px; background: #000000; color: #28a745; border: 2px solid #28a745; border-radius: 8px; cursor: pointer; font-weight: bold; font-size: 14px; transition: all 0.3s ease;">
                         Play Entire Playlist
                    </button>
                    <button onclick="playSelectedPlaylistVideos('${data.playlist_name}')" 
                            style="padding: 12px 24px; background: #000000; color: #fd7e14; border: 2px solid #fd7e14; border-radius: 8px; cursor: pointer; font-weight: bold; font-size: 14px; transition: all 0.3s ease;">
                         Play Selected
                    </button>
                    <button onclick="selectAllPlaylistVideos()" 
                            style="padding: 12px 24px; background: #000000; color: #17a2b8; border: 2px solid #17a2b8; border-radius: 8px; cursor: pointer; font-weight: bold; font-size: 14px;">
                         Select All
                    </button>
                    <button onclick="deselectAllPlaylistVideos()" 
                            style="padding: 12px 24px; background: #000000; color: #dc3545; border: 2px solid #dc3545; border-radius: 8px; cursor: pointer; font-weight: bold; font-size: 14px;">
                         Deselect All
                    </button>
                </div>
                
                <!-- Videos Count -->
                <div style="margin-bottom: 15px; color: #17a2b8; font-weight: bold; text-align: center;">
                    Found ${validVideos.length} video${validVideos.length !== 1 ? 's' : ''} in playlist
                </div>
                
                <!-- Search and Refresh Controls -->
                <div style="display: flex; gap: 10px; margin-bottom: 20px; justify-content: center; align-items: center;">
                    <input type="text" id="playlistVideoSearchInput" placeholder="Search videos in playlist..." 
                           style="flex: 1; max-width: 400px; padding: 10px; background: #000000; border: 2px solid #ffd700; border-radius: 8px; color: white; font-size: 14px;" 
                           oninput="filterPlaylistVideos()">
                    <button onclick="filterPlaylistVideos()" 
                            style="padding: 10px 20px; background: #000000; color: #ffd700; border: 2px solid #ffd700; border-radius: 8px; cursor: pointer; font-weight: bold; box-shadow: 0 0 10px rgba(255, 215, 0, 0.5); transition: all 0.3s ease;"
                            onmouseover="this.style.transform='scale(1.05)'; this.style.boxShadow='0 0 20px rgba(255, 215, 0, 0.8)'; this.style.textShadow='0 0 10px #ffd700';"
                            onmouseout="this.style.transform='scale(1)'; this.style.boxShadow='0 0 10px rgba(255, 215, 0, 0.5)'; this.style.textShadow='none';">
                         Find
                    </button>
                    <button onclick="clearPlaylistSearch()" 
                            style="padding: 10px 20px; background: #000000; color: #dc3545; border: 2px solid #dc3545; border-radius: 8px; cursor: pointer; font-weight: bold; box-shadow: 0 0 10px rgba(220, 53, 69, 0.5); transition: all 0.3s ease;"
                            onmouseover="this.style.transform='scale(1.05)'; this.style.boxShadow='0 0 20px rgba(220, 53, 69, 0.8)'; this.style.textShadow='0 0 10px #dc3545';"
                            onmouseout="this.style.transform='scale(1)'; this.style.boxShadow='0 0 10px rgba(220, 53, 69, 0.5)'; this.style.textShadow='none';">
                         Clear
                    </button>
                    <button onclick="refreshPlaylistMetadata()" 
                            style="padding: 10px 20px; background: #000000; color: #ffffff; border: 2px solid #fd7e14; border-radius: 8px; cursor: pointer; font-weight: bold; box-shadow: 0 0 10px rgba(253, 126, 20, 0.5); transition: all 0.3s ease;"
                            onmouseover="this.style.transform='scale(1.05)'; this.style.boxShadow='0 0 20px rgba(253, 126, 20, 0.8)'; this.style.textShadow='0 0 10px #fd7e14';"
                            onmouseout="this.style.transform='scale(1)'; this.style.boxShadow='0 0 10px rgba(253, 126, 20, 0.5)'; this.style.textShadow='none';">
                         Refresh Playlist
                    </button>
                </div>
                
                <!-- Videos List -->
                <div id="playlistVideosList" style="overflow-y: auto; max-height: 500px; padding-right: 5px;">
                    ${videosHTML}
                </div>
            `;
        }

        // Helper functions for playlist modal
        function selectAllPlaylistVideos() {
            const checkboxes = document.querySelectorAll('[id^="playlistVideo_"]');
            checkboxes.forEach(checkbox => checkbox.checked = true);
        }

        function deselectAllPlaylistVideos() {
            const checkboxes = document.querySelectorAll('[id^="playlistVideo_"]');
            checkboxes.forEach(checkbox => checkbox.checked = false);
        }

        // Global storage for original playlist videos for filtering
        let originalPlaylistVideos = [];

        // Filter playlist videos by search term
        function filterPlaylistVideos() {
            const searchInput = document.getElementById('playlistVideoSearchInput');
            const searchTerm = searchInput ? searchInput.value.toLowerCase().trim() : '';
            const videosList = document.getElementById('playlistVideosList');
            
            if (!videosList || originalPlaylistVideos.length === 0) {
                console.log('No videos list found or no original videos stored');
                return;
            }
            
            let filteredHTML = '';
            let matchCount = 0;
            
            // Filter videos based on search term
            originalPlaylistVideos.forEach((video, index) => {
                const videoName = video.name.toLowerCase();
                const videoPath = video.path.toLowerCase();
                
                if (!searchTerm || videoName.includes(searchTerm) || videoPath.includes(searchTerm)) {
                    matchCount++;
                    // Use exact same format as displayPlaylistContent
                    const fullPath = video.path;
                    filteredHTML += `
                        <div style="display: flex; align-items: center; padding: 12px; margin-bottom: 8px; background: black; border: 2px solid #28a745; border-radius: 8px; transition: all 0.3s ease;">
                            <!-- Checkbox -->
                            <input type="checkbox" id="playlistVideo_${index}" style="margin-right: 15px; transform: scale(1.2);">
                            
                            <!-- Thumbnail -->
                            <div class="video-thumbnail-container" id="playlist-thumb-${index}"
                                 onmouseenter="handleThumbnailHover('${video.name}', '${video.path}', 'playlist-thumb-${index}')"
                                 onmouseleave="handleThumbnailLeave('playlist-thumb-${index}')"
                                 onclick="handleThumbnailHover('${video.name}', '${video.path}', 'playlist-thumb-${index}')"
                                 style="width: 120px; height: 80px; border: 2px solid #17a2b8; margin-right: 15px;">
                                <div class="video-thumbnail-placeholder"></div>
                                <div class="video-thumbnail-loading" style="display: none;">Loading...</div>
                                <video class="video-thumbnail" muted></video>
                            </div>
                            
                            <!-- Video Info -->
                            <div style="flex: 1; color: #e0e0e0;">
                                <div style="font-size: 14px; font-weight: bold; margin-bottom: 3px; color: #17a2b8; cursor: pointer;"
                                     onmouseenter="handleThumbnailHover('${video.name}', '${video.path}', 'playlist-thumb-${index}')"
                                     onmouseleave="handleThumbnailLeave('playlist-thumb-${index}')"
                                     onclick="handleThumbnailHover('${video.name}', '${video.path}', 'playlist-thumb-${index}')">${video.name}</div>
                                <div style="font-size: 13px; color: white; margin-bottom: 3px; font-weight: bold;">${video.size || 'Loading...'}</div>
                                <div style="font-size: 12px; color: white; word-break: break-all;">${video.path}</div>
                            </div>
                            
                            <!-- Individual Play Button -->
                            <button onclick="playIndividualPlaylistVideo('${fullPath}', '${video.playlistName}')" 
                                    style="padding: 8px 16px; background: #000000; color: #28a745; border: 2px solid #28a745; border-radius: 6px; cursor: pointer; font-weight: bold; font-size: 12px; margin-left: 10px;">
                                 Play
                            </button>
                        </div>
                    `;
                }
            });
            
            // Update the videos list with filtered results
            videosList.innerHTML = filteredHTML;
            
            // Update the count display if it exists
            const countDisplay = document.querySelector('[style*="Found"][style*="video"]');
            if (countDisplay) {
                const totalVideos = originalPlaylistVideos.length;
                if (searchTerm) {
                    countDisplay.innerHTML = `Found ${matchCount} video${matchCount !== 1 ? 's' : ''} matching "${searchTerm}" (${totalVideos} total)`;
                } else {
                    countDisplay.innerHTML = `Found ${totalVideos} video${totalVideos !== 1 ? 's' : ''} in playlist`;
                }
            }
            
            console.log(`Filtered playlist videos: ${matchCount} matches out of ${originalPlaylistVideos.length} total`);
        }

        // Clear playlist search and show all videos
        function clearPlaylistSearch() {
            const searchInput = document.getElementById('playlistVideoSearchInput');
            if (searchInput) {
                searchInput.value = '';
            }
            
            // Reset the display to show all videos
            filterPlaylistVideos();
            
            console.log('Playlist search cleared, showing all videos');
        }

        // Refresh playlist metadata
        async function refreshPlaylistMetadata(playlistName) {
            console.log('Refreshing metadata for playlist:', playlistName);
            
            try {
                const videosList = document.getElementById('playlistVideosList');
                const countDisplay = document.querySelector('[style*="Found"][style*="video"]');
                
                // Step 1: Show loading for 1 second and clear videos
                if (videosList) {
                    videosList.innerHTML = `
                        <div style="text-align: center; color: #fd7e14; padding: 40px;">
                            <div style="font-size: 48px; margin-bottom: 15px;"></div>
                            <div>Refreshing playlist metadata...</div>
                        </div>
                    `;
                }
                
                if (countDisplay) {
                    countDisplay.innerHTML = 'Refreshing playlist data...';
                }
                
                // Wait 1 second as requested
                await new Promise(resolve => setTimeout(resolve, 1000));
                
                // Step 2: Clear all videos from view
                if (videosList) {
                    videosList.innerHTML = '';
                }
                
                // Step 3: Call API to refresh metadata
                const response = await fetch('/api/refresh_playlist_metadata', {
                    method: 'POST',
                    headers: {
                        'Content-Type': 'application/json',
                        ...window.authHeaders
                    },
                    body: JSON.stringify({
                        playlist_name: playlistName
                    })
                });
                
                if (!response.ok) {
                    throw new Error(`HTTP ${response.status}: ${response.statusText}`);
                }
                
                const result = await response.json();
                
                if (!result.success) {
                    throw new Error(result.message || 'Failed to refresh playlist metadata');
                }
                
                // Step 4: Reload fresh playlist content by calling the content API
                const contentResponse = await fetch('/api/open_playlist_content', {
                    method: 'POST',
                    headers: {
                        'Content-Type': 'application/json',
                        ...window.authHeaders
                    },
                    body: JSON.stringify({
                        playlist_name: playlistName
                    })
                });
                
                if (!contentResponse.ok) {
                    throw new Error(`Failed to reload playlist content: ${contentResponse.status}`);
                }
                
                const contentData = await contentResponse.json();
                
                if (!contentData.success) {
                    throw new Error(contentData.message || 'Failed to load refreshed playlist content');
                }
                
                // Step 5: Update the current modal with fresh data instead of reopening
                const modal = document.querySelector('.modal');
                if (modal) {
                    // Find the content area and update it
                    const contentArea = modal.querySelector('#playlistContentArea');
                    if (contentArea) {
                        // Clear search field
                        const searchInput = document.getElementById('playlistVideoSearchInput');
                        if (searchInput) {
                            searchInput.value = '';
                        }
                        
                        // Use the existing displayPlaylistContent function logic
                        const validVideos = contentData.videos.filter(video => video.exists === true);
                        
                        // Update global storage for filtering
                        originalPlaylistVideos = validVideos.map(video => ({
                            name: video.name,
                            path: video.path,
                            size: video.size,
                            playlistName: contentData.playlist_name
                        }));
                        
                        // Regenerate videos HTML with original styling
                        const videosHTML = validVideos.map((video, index) => {
                            const fullPath = video.path;
                            
                            return `
                                <div style="display: flex; align-items: center; padding: 12px; margin-bottom: 8px; background: black; border: 2px solid #28a745; border-radius: 8px; transition: all 0.3s ease;">
                                    <!-- Checkbox -->
                                    <input type="checkbox" id="playlistVideo_${index}" style="margin-right: 15px; transform: scale(1.2);">
                                    
                                    <!-- Thumbnail -->
                                    <div class="video-thumbnail-container" id="playlist-thumb-${index}"
                                         onmouseenter="handleThumbnailHover('${video.name}', '${video.path}', 'playlist-thumb-${index}')"
                                         onmouseleave="handleThumbnailLeave('playlist-thumb-${index}')"
                                         style="margin-right: 15px; position: relative;">
                                        <div class="video-thumbnail-placeholder" style="
                                            width: 120px; 
                                            height: 68px; 
                                            background: linear-gradient(135deg, #333, #555); 
                                            border: 2px solid #17a2b8; 
                                            border-radius: 8px; 
                                            display: flex; 
                                            align-items: center; 
                                            justify-content: center; 
                                            color: #17a2b8; 
                                            font-size: 24px;
                                            cursor: pointer;
                                        "></div>
                                        <div class="video-thumbnail-loading" style="display: none;">Loading...</div>
                                        <video class="video-thumbnail" muted style="
                                            width: 120px; 
                                            height: 68px; 
                                            border-radius: 8px; 
                                            display: none; 
                                            object-fit: cover;
                                        "></video>
                                    </div>
                                    
                                    <!-- Video Info -->
                                    <div style="flex: 1; min-width: 0;">
                                        <div class="video-name" style="color: #17a2b8; font-weight: bold; font-size: 16px; margin-bottom: 5px; word-break: break-word;">
                                            ${index + 1}. ${video.name}
                                        </div>
                                        <div style="color: #888; font-size: 12px; margin-bottom: 3px;">${video.size}</div>
                                        <div class="video-path" style="color: #666; font-size: 11px; word-break: break-all;">${video.path}</div>
                                    </div>
                                    
                                    <!-- Play Button -->
                                    <button onclick="playIndividualPlaylistVideo('${video.path}', '${playlistName}')" 
                                            style="padding: 8px 16px; background: #000000; color: #28a745; border: 2px solid #28a745; border-radius: 6px; cursor: pointer; font-weight: bold; transition: all 0.2s; margin-left: 15px;">
                                         Play
                                    </button>
                                </div>
                            `;
                        }).join('');
                        
                        // Update the videos list
                        if (videosList) {
                            videosList.innerHTML = videosHTML;
                        }
                        
                        // Update the count display
                        if (countDisplay) {
                            countDisplay.innerHTML = `Found ${validVideos.length} video${validVideos.length !== 1 ? 's' : ''} in playlist`;
                        }
                        
                        console.log('Playlist metadata refreshed successfully with updated content');
                    }
                }
                
            } catch (error) {
                console.error('Error refreshing playlist metadata:', error);
                
                // Show error message
                const videosList = document.getElementById('playlistVideosList');
                if (videosList) {
                    videosList.innerHTML = `
                        <div style="text-align: center; color: #dc3545; padding: 40px;">
                            <div style="font-size: 48px; margin-bottom: 15px;"></div>
                            <div>Error refreshing metadata: ${error.message}</div>
                            <button onclick="location.reload()" style="margin-top: 20px; padding: 10px 20px; background: #dc3545; color: white; border: none; border-radius: 6px; cursor: pointer;">
                                Refresh Page
                            </button>
                        </div>
                    `;
                }
            }
        }

        // Play individual video from playlist
        async function playIndividualPlaylistVideo(videoPath, playlistName) {
            console.log('Playing individual video from playlist:', videoPath);
            
            // Close playlist modals but keep system modals
            const modals = document.querySelectorAll('.modal');
            modals.forEach(modal => {
                if (modal.id !== 'videoSearchModal') {
                    modal.remove();
                }
            });
            
            // Show playlist banner
            showPlaylistBanner(playlistName);
            
            // Create a temporary video list with just this one video  
            const videoName = videoPath.split('/').pop();
            const fullPath = videoPath.startsWith('/') ? videoPath : `/home/gus/video-system/videos/${videoName}`;
            const singleVideoList = [{
                name: videoName,
                path: fullPath
            }];
            
            // Load this video directly into the player
            await loadPlaylistVideos(singleVideoList, playlistName);
        }

        // Play entire playlist
        async function playEntirePlaylist(playlistName, videos) {
            console.log('Playing entire playlist:', playlistName, videos.length, 'videos');
            
            // Close playlist modals but keep system modals
            const modals = document.querySelectorAll('.modal');
            modals.forEach(modal => {
                if (modal.id !== 'videoSearchModal') {
                    modal.remove();
                }
            });
            
            // Show playlist banner
            showPlaylistBanner(playlistName);
            
            // Load all videos into the player
            await loadPlaylistVideos(videos, playlistName);
        }

        // Play selected videos from playlist
        async function playSelectedPlaylistVideos(playlistName) {
            console.log(' UPDATED CODE LOADED - Playing selected videos from playlist:', playlistName);
            
            // Get selected videos
            const checkboxes = document.querySelectorAll('[id^="playlistVideo_"]');
            const selectedVideos = [];
            
            checkboxes.forEach((checkbox, index) => {
                if (checkbox.checked) {
                    const videoRow = checkbox.closest('div[style*="display: flex"]');
                    const videoNameElem = videoRow.querySelector('div[style*="font-weight: bold"]');
                    const videoPathElem = videoRow.querySelector('div[style*="word-break: break-all"]');
                    
                    // Extract size from the row text - look for MB or GB patterns
                    const rowText = videoRow.textContent;
                    const sizeMatch = rowText.match(/(\d+\.?\d*\s*(MB|GB))/i);
                    const extractedSize = sizeMatch ? sizeMatch[0] : 'Unknown';
                    
                    console.log('Extracting from row:', {
                        rowText: rowText,
                        sizeMatch: sizeMatch,
                        extractedSize: extractedSize
                    });
                    
                    if (videoNameElem && videoPathElem) {
                        selectedVideos.push({
                            name: videoNameElem.textContent,
                            path: videoPathElem.textContent,
                            size: extractedSize
                        });
                    }
                }
            });
            
            if (selectedVideos.length === 0) {
                alert('Please select at least one video to play.');
                return;
            }
            
            // Close playlist modals but keep system modals
            const modals = document.querySelectorAll('.modal');
            modals.forEach(modal => {
                if (modal.id !== 'videoSearchModal') {
                    modal.remove();
                }
            });
            
            // Show playlist banner
            showPlaylistBanner(playlistName);
            
            // Load selected videos into the player
            await loadPlaylistVideos(selectedVideos, playlistName);
        }

        // Load playlist videos into the video catalog and start playing
        async function loadPlaylistVideos(videos, playlistName) {
            try {
                // Backup original video library if not already backed up
                if (!window.originalVideoLibrary) {
                    window.originalVideoLibrary = [...allVideos];
                }
                
                // Store playlist for sequential playback
                window.currentPlaylist = {
                    videos: videos,
                    name: playlistName,
                    currentIndex: 0
                };
                
                // Clear current video catalog and load playlist videos
                allVideos = [];
                
                // Add playlist videos to the catalog
                videos.forEach((video, index) => {
                    // Ensure full path for video loading
                    const fullVideoPath = video.path && video.path.startsWith('/') ? video.path : `/home/gus/video-system/videos/${video.name}`;
                    console.log('Playlist video', index, ':', video); // Debug video data
                    allVideos.push({
                        name: video.name,
                        path: fullVideoPath,
                        size: video.size || 'Unknown',
                        modified: 'Playlist item',
                        directory: fullVideoPath  // Use full path instead of 'Playlist'
                    });
                });
                
                // Update the video display using correct function
                displayVideoLibrary(allVideos);
                
                // Skip metadata refresh for playlist videos to avoid null reference errors
                // await refreshVideoMetadata();
                
                // Auto-play the first video using direct video player loading to avoid logging issues
                if (videos.length > 0) {
                    const firstVideo = videos[0];
                    const videoPlayer = document.getElementById('videoPlayer');
                    
                    console.log('Loading first playlist video:', firstVideo.name, firstVideo.path);
                    
                    // Fetch and play the video
                    fetchVideoAsBlob(firstVideo.path)
                        .then(blobUrl => {
                            console.log('Got blob URL for video:', blobUrl);
                            videoPlayer.innerHTML = `<source src="${blobUrl}" type="video/mp4">`;
                            videoPlayer.load();
                            
                            // Add event listener to auto-play when ready
                            videoPlayer.addEventListener('loadeddata', function() {
                                videoPlayer.play().catch(error => {
                                    console.error('Error auto-playing video:', error);
                                });
                            }, { once: true });
                            
                            document.getElementById("current-video-name").textContent = firstVideo.name;
                            updatePlayStatus("playing");
                        })
                        .catch(error => {
                            console.error('Error loading playlist video:', error);
                            // Try playing directly without blob
                            videoPlayer.src = firstVideo.path;
                            videoPlayer.load();
                            videoPlayer.play().catch(e => console.error('Direct play also failed:', e));
                        });
                    
                    currentPlayingVideo = firstVideo.name;
                    
                    // Try to log video play if possible
                    try {
                        if (typeof logVideoPlay === 'function') {
                            logVideoPlay(firstVideo.name, firstVideo.path, firstVideo.size || 'unknown');
                        }
                    } catch (e) {
                        console.warn('Could not log video play:', e);
                    }
                }
                
                console.log('Loaded', videos.length, 'videos from playlist:', playlistName);
                
            } catch (error) {
                console.error('Error loading playlist videos:', error);
                alert('Error loading playlist videos: ' + error.message);
            }
        }

        // Show blinking playlist banner above metadata
        function showPlaylistBanner(playlistName) {
            // Remove existing banner if any
            const existingBanner = document.getElementById('playlistBanner');
            if (existingBanner) {
                existingBanner.remove();
            }
            
            // Create new banner - always use fixed positioning to avoid interfering with layout
            const banner = document.createElement('div');
            banner.id = 'playlistBanner';
            banner.style.cssText = `
                position: fixed;
                top: 20px;
                left: 50%;
                transform: translateX(-50%);
                background: #000000;
                color: #00ff00;
                border: 2px solid #00ff00;
                border-radius: 10px;
                padding: 12px 20px;
                font-weight: bold;
                font-size: 14px;
                z-index: 1000;
                display: flex;
                align-items: center;
                justify-content: center;
                animation: playlistBannerBlink 3s ease-in-out infinite;
                box-shadow: 0 5px 20px rgba(0, 255, 0, 0.8), 0 0 30px rgba(0, 255, 0, 0.6), 0 0 40px rgba(0, 255, 0, 0.4);
                text-align: center;
                white-space: nowrap;
            `;
            
            banner.innerHTML = `
                Playing from playlist: <span style="color: #ffd700; background: rgba(255, 215, 0, 0.2); padding: 2px 6px; border-radius: 3px; border: 1px solid #ffd700; font-weight: bold;">${playlistName}</span>. To stop playlist press Video Catalog.
            `;
            
            // Add blinking animation CSS if not already present
            if (!document.getElementById('playlistBannerStyle')) {
                const style = document.createElement('style');
                style.id = 'playlistBannerStyle';
                style.textContent = `
                    @keyframes playlistBannerBlink {
                        0%, 66.66% { opacity: 1; }
                        66.67%, 100% { opacity: 0; }
                    }
                `;
                document.head.appendChild(style);
            }
            
            // Always append to body to avoid layout issues
            document.body.appendChild(banner);
            
            // Set up video player event listeners for blinking control
            setupPlaylistBannerControl();
        }
        
        // Control playlist banner blinking based on video player state
        function setupPlaylistBannerControl() {
            const videoPlayer = document.getElementById('videoPlayer');
            const banner = document.getElementById('playlistBanner');
            
            if (!videoPlayer || !banner) return;
            
            // Remove existing listeners to avoid duplicates
            videoPlayer.removeEventListener('play', handlePlaylistBannerPlay);
            videoPlayer.removeEventListener('pause', handlePlaylistBannerPause);
            videoPlayer.removeEventListener('ended', handlePlaylistBannerEnd);
            
            // Add event listeners
            videoPlayer.addEventListener('play', handlePlaylistBannerPlay);
            videoPlayer.addEventListener('pause', handlePlaylistBannerPause);
            videoPlayer.addEventListener('ended', handlePlaylistBannerEnd);
        }
        
        // Banner control functions
        function handlePlaylistBannerPlay() {
            const banner = document.getElementById('playlistBanner');
            if (banner && window.currentPlaylist) {
                // Restore original green banner when resuming playback
                banner.innerHTML = `Playing from playlist: <span style="color: #ffd700; background: rgba(255, 215, 0, 0.2); padding: 2px 6px; border-radius: 3px; border: 1px solid #ffd700; font-weight: bold;">${window.currentPlaylist.name}</span>. To stop playlist press Video Catalog.`;
                banner.style.color = '#00ff00';
                banner.style.border = '2px solid #00ff00';
                banner.style.boxShadow = '0 5px 20px rgba(0, 255, 0, 0.8), 0 0 30px rgba(0, 255, 0, 0.6), 0 0 40px rgba(0, 255, 0, 0.4)';
                banner.style.animation = 'playlistBannerBlink 3s ease-in-out infinite';
                banner.classList.remove('playlist-banner-paused');
            }
        }
        
        function handlePlaylistBannerPause() {
            const banner = document.getElementById('playlistBanner');
            if (banner && window.currentPlaylist) {
                // Change to red stop message
                banner.innerHTML = ` Stopped reproduction of playlist: <span style="color: #ffd700; background: rgba(255, 215, 0, 0.3); padding: 2px 6px; border-radius: 3px; border: 1px solid #ffd700; font-weight: bold;">${window.currentPlaylist.name}</span>. To stop playlist press Video Catalog.`;
                banner.style.color = '#ff0000';
                banner.style.border = '2px solid #ff0000';
                banner.style.boxShadow = '0 5px 20px rgba(255, 0, 0, 0.8), 0 0 30px rgba(255, 0, 0, 0.6), 0 0 40px rgba(255, 0, 0, 0.4)';
                banner.style.animation = 'playlistBannerBlink 3s ease-in-out infinite';
                // Don't add paused class so it keeps blinking
            }
        }
        
        function handlePlaylistBannerEnd() {
            const banner = document.getElementById('playlistBanner');
            if (banner && window.currentPlaylist) {
                // Play next video in playlist
                window.currentPlaylist.currentIndex++;
                
                if (window.currentPlaylist.currentIndex < window.currentPlaylist.videos.length) {
                    // Play next video
                    const nextVideo = window.currentPlaylist.videos[window.currentPlaylist.currentIndex];
                    console.log('Playing next video in playlist:', nextVideo.name);
                    
                    const videoPlayer = document.getElementById('videoPlayer');
                    fetchVideoAsBlob(nextVideo.path)
                        .then(blobUrl => {
                            videoPlayer.innerHTML = `<source src="${blobUrl}" type="video/mp4">`;
                            videoPlayer.load();
                            
                            // Add event listener to auto-play when ready
                            videoPlayer.addEventListener('loadeddata', function() {
                                videoPlayer.play().catch(error => {
                                    console.error('Error auto-playing next video:', error);
                                });
                            }, { once: true });
                            
                            document.getElementById("current-video-name").textContent = nextVideo.name;
                            updatePlayStatus("playing");
                        })
                        .catch(error => {
                            console.error('Error loading next playlist video:', error);
                            // Try playing directly without blob
                            videoPlayer.src = nextVideo.path;
                            videoPlayer.load();
                            videoPlayer.play().catch(e => {
                                console.error('Direct play failed for next video:', e);
                                // Try to play the next one
                                handlePlaylistBannerEnd();
                            });
                        });
                } else {
                    // Playlist finished - remove banner
                    console.log('Playlist finished');
                    setTimeout(() => {
                        if (banner.parentNode) {
                            banner.remove();
                        }
                        window.currentPlaylist = null;
                    }, 2000);
                }
            }
        }


        // Add All Videos to Playlist (Phase 2)
        async function addAllVideosToPlaylist() {
            // Get all currently visible videos
            const allVisibleVideos = getCurrentlyVisibleVideos();
            
            if (allVisibleVideos.length === 0) {
                showPlaylistErrorModal('No Videos Available', 'There are no videos available to add to a playlist.');
                return;
            }
            
            console.log('Adding all videos to playlist:', allVisibleVideos.length, 'videos');
            showPlaylistSelectionModal('all', allVisibleVideos);
        }

        // Add Selected Videos to Playlist (Phase 2)
        async function addSelectedVideosToPlaylist() {
            console.log('Add Selected Videos button clicked');
            
            // Check if any videos are selected - try multiple selectors
            let checkboxes = document.querySelectorAll('input[type="checkbox"][id^="video_"]:checked');
            console.log('Found checked checkboxes with video_ prefix:', checkboxes.length);
            
            if (checkboxes.length === 0) {
                // Try broader search in videoSearchResults
                checkboxes = document.querySelectorAll('#videoSearchResults input[type="checkbox"]:checked');
                console.log('Found checked checkboxes in videoSearchResults:', checkboxes.length);
            }
            
            if (checkboxes.length === 0) {
                // Try even broader search
                checkboxes = document.querySelectorAll('input[type="checkbox"]:checked');
                console.log('Found any checked checkboxes:', checkboxes.length);
                
                // Filter to only those in video search results area
                const videoAreaCheckboxes = Array.from(checkboxes).filter(cb => {
                    const videoItem = cb.closest('.video-search-item');
                    return videoItem !== null;
                });
                checkboxes = videoAreaCheckboxes;
                console.log('Filtered to video area checkboxes:', checkboxes.length);
            }
            
            if (checkboxes.length === 0) {
                console.log('No checked boxes found - showing error modal');
                showPlaylistErrorModal('No Videos Selected', 'Please select one or more videos by checking their checkboxes before using this feature.');
                return;
            }
            
            console.log('Getting selected video details for', checkboxes.length, 'checkboxes');
            const selectedVideos = getSelectedVideoDetails(checkboxes);
            console.log('Selected videos:', selectedVideos);
            showPlaylistSelectionModal('selected', selectedVideos);
        }

        // Get currently visible videos from the search results
        function getCurrentlyVisibleVideos() {
            console.log('Getting currently visible videos...');
            
            // Use allVideos array if available (has complete metadata including sizes)
            if (typeof allVideos !== 'undefined' && allVideos && allVideos.length > 0) {
                console.log('Using allVideos array with complete metadata:', allVideos.length, 'videos');
                return allVideos.map(video => {
                    const videoName = video.name || video.filename || 'Unknown';
                    const videoPath = video.path || video.name || video.filename;
                    // Ensure name is just the filename, not a path
                    const actualName = videoName.includes('/') ? videoName.split('/').pop() : videoName;
                    return {
                        name: actualName,
                        path: videoPath,
                        size: video.size || 'Unknown size'
                    };
                });
            }
            
            // Fallback to DOM parsing if allVideos not available
            console.log('allVideos not available, falling back to DOM parsing...');
            
            // First check if videoSearchResults container exists and is visible
            const container = document.getElementById('videoSearchResults');
            console.log('videoSearchResults container:', container);
            
            // Try multiple possible selectors for video elements
            let videoElements = document.querySelectorAll('#videoSearchResults .video-search-item');
            console.log('Found .video-search-item elements:', videoElements.length);
            
            if (videoElements.length === 0) {
                videoElements = document.querySelectorAll('#videoSearchResults .video-item');
                console.log('Found .video-item elements:', videoElements.length);
            }
            if (videoElements.length === 0) {
                videoElements = document.querySelectorAll('#videoSearchResults [data-video-name]');
                console.log('Found [data-video-name] elements:', videoElements.length);
            }
            if (videoElements.length === 0) {
                videoElements = document.querySelectorAll('#videoSearchResults > div');
                console.log('Found direct div children:', videoElements.length);
            }
            
            console.log('Final found video elements:', videoElements.length);
            
            const videos = [];
            
            videoElements.forEach((element, index) => {
                // Extract video information from DOM
                let videoName = '';
                let videoPath = '';
                let videoSize = 'Unknown size';
                
                // Look for specific classes and data attributes
                const nameElement = element.querySelector('.video-name, .video-title, .name, .title');
                const pathElement = element.querySelector('.video-path, .path, .file-path');
                const sizeElement = element.querySelector('.video-size, .size, .file-size');
                
                if (nameElement) {
                    videoName = nameElement.textContent.trim();
                }
                if (pathElement) {
                    videoPath = pathElement.textContent.trim();
                }
                if (sizeElement) {
                    videoSize = sizeElement.textContent.trim();
                }
                
                // Try data attributes
                if (!videoName) {
                    videoName = element.getAttribute('data-video-name') || element.getAttribute('data-name') || '';
                }
                if (!videoPath) {
                    videoPath = element.getAttribute('data-video-path') || element.getAttribute('data-path') || '';
                }
                if (videoSize === 'Unknown size') {
                    videoSize = element.getAttribute('data-video-size') || element.getAttribute('data-size') || 'Unknown size';
                }
                
                // Try extracting from text content
                if (!videoName) {
                    const textElements = element.querySelectorAll('strong, span, div');
                    textElements.forEach(el => {
                        const text = el.textContent.trim();
                        if (text && (text.includes('.mp4') || text.includes('.webm') || text.includes('.avi'))) {
                            videoName = text;
                        }
                    });
                }
                
                console.log(`Extracted video ${index}: name="${videoName}", path="${videoPath}", size="${videoSize}"`);
                
                if (videoName) {
                    // If videoName is actually a full path, extract just the filename
                    const actualName = videoName.includes('/') ? videoName.split('/').pop() : videoName;
                    videos.push({
                        name: actualName,
                        path: videoPath || videoName,
                        size: videoSize
                    });
                }
            });
            
            console.log('Total videos found:', videos.length);
            return videos;
        }

        // Get details of selected videos
        function getSelectedVideoDetails(checkboxes) {
            console.log('Getting selected video details...', checkboxes.length, 'checkboxes');
            
            const videos = [];
            
            checkboxes.forEach((checkbox, index) => {
                console.log(`Processing checkbox ${index}:`, checkbox);
                
                // Find the parent video container
                let videoItem = checkbox.closest('.video-search-item');
                if (!videoItem) {
                    videoItem = checkbox.closest('.video-item');
                }
                if (!videoItem) {
                    videoItem = checkbox.closest('.video-card');
                }
                if (!videoItem) {
                    videoItem = checkbox.closest('[data-video-name]');
                }
                if (!videoItem) {
                    // Look for parent with video information
                    videoItem = checkbox.parentNode;
                    while (videoItem && !videoItem.querySelector('.video-name, .video-title, .name, .title') && videoItem !== document.body) {
                        videoItem = videoItem.parentNode;
                    }
                }
                
                console.log(`Found video item for checkbox ${index}:`, videoItem);
                
                if (videoItem) {
                    // Try different ways to extract video name and path
                    let videoName = '';
                    let videoPath = '';
                    
                    // Method 1: Look for specific classes
                    const nameElement = videoItem.querySelector('.video-name, .video-title, .name, .title');
                    const pathElement = videoItem.querySelector('.video-path, .path, .file-path');
                    
                    if (nameElement) {
                        videoName = nameElement.textContent.trim();
                    }
                    if (pathElement) {
                        videoPath = pathElement.textContent.trim();
                    }
                    
                    // Method 2: Look for data attributes
                    if (!videoName) {
                        videoName = videoItem.getAttribute('data-video-name') || videoItem.getAttribute('data-name') || '';
                    }
                    if (!videoPath) {
                        videoPath = videoItem.getAttribute('data-video-path') || videoItem.getAttribute('data-path') || '';
                    }
                    
                    // Method 3: Look for text content that looks like a filename
                    if (!videoName) {
                        const textElements = videoItem.querySelectorAll('strong, span, div');
                        textElements.forEach(el => {
                            const text = el.textContent.trim();
                            if (text && (text.includes('.mp4') || text.includes('.webm') || text.includes('.avi'))) {
                                videoName = text;
                            }
                        });
                    }
                    
                    console.log(`Extracted selected video ${index}: name="${videoName}", path="${videoPath}"`);
                    
                    if (videoName) {
                        // If videoName is actually a full path, extract just the filename
                        const actualName = videoName.includes('/') ? videoName.split('/').pop() : videoName;
                        videos.push({
                            name: actualName,
                            path: videoPath || videoName
                        });
                    }
                }
            });
            
            console.log('Total selected videos found:', videos.length);
            return videos;
        }

        // Show playlist selection modal
        async function showPlaylistSelectionModal(type, videos) {
            console.log('Opening playlist selection modal for:', type, 'with', videos.length, 'videos');
            
            // Show loading
            showPlaylistLoadingModal();
            
            try {
                // Get existing playlists
                const playlists = await getExistingPlaylists();
                
                // Close loading modal
                const loadingModal = document.querySelector('.playlist-loading-modal');
                if (loadingModal) loadingModal.remove();
                
                if (playlists.length === 0) {
                    showPlaylistErrorModal('No Playlists Found', 'You need to create at least one playlist before adding videos. Please create a new playlist first.');
                    return;
                }
                
                // Show playlist selection modal
                const modal = document.createElement('div');
                modal.className = 'modal playlist-selection-modal';
                modal.style.display = 'block';
                
                const actionText = type === 'all' ? `Add ${videos.length} Videos` : `Add ${videos.length} Selected Video${videos.length === 1 ? '' : 's'}`;
                
                modal.innerHTML = `
                    <div class="modal-content playlist-modal-content" style="width: fit-content !important; max-width: 1200px !important; min-width: 1000px !important; margin: 3% auto !important; padding: 0 !important; height: auto !important; min-height: 800px !important;">
                        <div class="modal-header" style="background: #000000; padding: 15px; border-radius: 8px 8px 0 0;">
                            <h2 style="color: #00bfff; font-size: 16px; margin: 0;"> ${actionText} to Playlist</h2>
                            <button class="close" onclick="this.closest('.modal').remove()" style="color: #00bfff; background: none; border: none; font-size: 18px; cursor: pointer; float: right;">&times;</button>
                        </div>
                        <div class="modal-body" style="padding: 20px; max-height: 700px; overflow-y: auto;">
                            <div style="margin-bottom: 15px;">
                                <h3 style="color: #00bfff; font-size: 14px; margin-bottom: 10px;">Select Playlist:</h3>
                                <input type="text" id="playlistSearchInput" placeholder="Search playlists..." 
                                       style="width: 100%; padding: 8px; background: rgba(0,0,0,0.8); border: 1px solid #00bfff; border-radius: 4px; color: white; font-size: 13px; margin-bottom: 15px; box-sizing: border-box;"
                                       oninput="filterPlaylistList()">
                            </div>
                            <div id="playlistList" style="max-height: 300px; overflow-y: auto; border: 1px solid #333; border-radius: 4px; background: rgba(0,0,0,0.3); padding: 15px;">
                                ${generatePlaylistList(playlists)}
                            </div>
                            
                            <!-- Navigation Buttons -->
                            <div style="margin: 15px 0; display: flex; gap: 10px; justify-content: center; align-items: center;">
                                <button onclick="unselectAllPlaylists()" style="padding: 8px 16px; background: #000000; color: #dc3545; border: 2px solid #dc3545; border-radius: 4px; cursor: pointer; font-weight: bold; transition: all 0.3s ease;" onmouseover="this.style.transform='scale(1.05)'; this.style.boxShadow='0 0 15px #dc3545'; this.style.textShadow='0 0 8px #dc3545';" onmouseout="this.style.transform='scale(1)'; this.style.boxShadow='none'; this.style.textShadow='none';">Unselect all Playlists</button>
                                <button onclick="selectAllPlaylists()" style="padding: 8px 16px; background: #000000; color: #17a2b8; border: 2px solid #17a2b8; border-radius: 4px; cursor: pointer; font-weight: bold; transition: all 0.3s ease;" onmouseover="this.style.transform='scale(1.05)'; this.style.boxShadow='0 0 15px #17a2b8'; this.style.textShadow='0 0 8px #17a2b8';" onmouseout="this.style.transform='scale(1)'; this.style.boxShadow='none'; this.style.textShadow='none';">Select all Playlists</button>
                                <div id="selectedPlaylistCount" style="padding: 8px 16px; background: rgba(255, 255, 0, 0.1); color: #ffff00; border: 2px solid #ffff00; border-radius: 4px; font-weight: bold; font-size: 13px; min-width: 150px; text-align: center;">Selected amount: 0</div>
                                <button onclick="goToPlaylistModalTop()" style="padding: 8px 16px; background: #000000; color: #ff7f00; border: 2px solid #ff7f00; border-radius: 4px; cursor: pointer; font-weight: bold; transition: all 0.3s ease;" onmouseover="this.style.transform='scale(1.05)'; this.style.boxShadow='0 0 15px #ff7f00'; this.style.textShadow='0 0 8px #ff7f00';" onmouseout="this.style.transform='scale(1)'; this.style.boxShadow='none'; this.style.textShadow='none';">Go to Top</button>
                                <button onclick="goToPlaylistModalBottom()" style="padding: 8px 16px; background: #000000; color: #ff7f00; border: 2px solid #ff7f00; border-radius: 4px; cursor: pointer; font-weight: bold; transition: all 0.3s ease;" onmouseover="this.style.transform='scale(1.05)'; this.style.boxShadow='0 0 15px #ff7f00'; this.style.textShadow='0 0 8px #ff7f00';" onmouseout="this.style.transform='scale(1)'; this.style.boxShadow='none'; this.style.textShadow='none';">Go to Bottom</button>
                                <button onclick="goToPlaylistModalMiddle()" style="padding: 8px 16px; background: #000000; color: #ff7f00; border: 2px solid #ff7f00; border-radius: 4px; cursor: pointer; font-weight: bold; transition: all 0.3s ease;" onmouseover="this.style.transform='scale(1.05)'; this.style.boxShadow='0 0 15px #ff7f00'; this.style.textShadow='0 0 8px #ff7f00';" onmouseout="this.style.transform='scale(1)'; this.style.boxShadow='none'; this.style.textShadow='none';">Go to Middle</button>
                            </div>
                            
                            <div style="margin-top: 15px; padding: 15px; background: rgba(0,0,0,0.8); border-radius: 8px; border: 1px solid #00bfff; max-height: 400px; overflow-y: auto;">
                                <h4 style="color: #00bfff; font-size: 14px; margin: 0 0 10px 0; font-weight: bold;"> Videos to add (${videos.length}):</h4>
                                <div style="font-family: 'Courier New', monospace;">
                                    ${videos.map((v, index) => `
                                        <div style="color: white; font-size: 12px; padding: 8px; border-bottom: 1px solid rgba(255,255,255,0.1); line-height: 1.4; display: flex; align-items: center;">
                                            <span style="color: #ffd700; font-weight: bold; display: inline-block; width: 25px;">${index + 1}.</span>
                                            
                                            <!-- Video Thumbnail -->
                                            <div class="video-thumbnail-container" id="thumbnail-playlist-${index}" style="margin-right: 10px;" 
                                                 onmouseenter="handleThumbnailHover('${v.name}', '${v.path || v.name}', 'thumbnail-playlist-${index}')"
                                                 onmouseleave="handleThumbnailLeave('thumbnail-playlist-${index}')"
                                                 onclick="handleThumbnailHover('${v.name}', '${v.path || v.name}', 'thumbnail-playlist-${index}')">
                                                <div class="video-thumbnail-placeholder"></div>
                                                <div class="video-thumbnail-loading" style="display: none;">Loading...</div>
                                                <video class="video-thumbnail" muted></video>
                                            </div>
                                            
                                            <div style="flex: 1; cursor: pointer;"
                                                 onmouseenter="handleThumbnailHover('${v.name}', '${v.path || v.name}', 'thumbnail-playlist-${index}')"
                                                 onmouseleave="handleThumbnailLeave('thumbnail-playlist-${index}')"
                                                 onclick="handleThumbnailHover('${v.name}', '${v.path || v.name}', 'thumbnail-playlist-${index}')">
                                                <div style="color: #e0e0e0;">${v.name}</div>
                                                <div style="color: #888; font-size: 11px; margin-top: 1px;">${v.size || getVideoSizeFromLibrary(v.name, v.path) || 'Unknown size'}</div>
                                            </div>
                                        </div>
                                    `).join('')}
                                </div>
                            </div>
                            <div style="display: flex; gap: 10px; justify-content: flex-end; margin-top: 20px;">
                                <button onclick="this.closest('.modal').remove()" 
                                        style="padding: 8px 16px; background: #000000; color: #dc3545; border: 2px solid #dc3545; border-radius: 4px; cursor: pointer; font-size: 13px; font-weight: bold; transition: all 0.3s ease;" onmouseover="this.style.transform='scale(1.05)'; this.style.boxShadow='0 0 15px #dc3545'; this.style.textShadow='0 0 8px #dc3545';" onmouseout="this.style.transform='scale(1)'; this.style.boxShadow='none'; this.style.textShadow='none';">
                                    Cancel
                                </button>
                                <button onclick="confirmAddVideosToPlaylist('${type}', ${JSON.stringify(videos).replace(/"/g, '&quot;')})" 
                                        style="padding: 8px 16px; background: #000000; color: #28a745; border: 2px solid #28a745; border-radius: 4px; cursor: pointer; font-weight: bold; font-size: 13px; transition: all 0.3s ease;" onmouseover="this.style.transform='scale(1.05)'; this.style.boxShadow='0 0 15px #28a745'; this.style.textShadow='0 0 8px #28a745';" onmouseout="this.style.transform='scale(1)'; this.style.boxShadow='none'; this.style.textShadow='none';">
                                    Add to Selected Playlist
                                </button>
                                <button onclick="addToAllPlaylists('${type}', ${JSON.stringify(videos).replace(/"/g, '&quot;')})" 
                                        style="padding: 8px 16px; background: #000000; color: #17a2b8; border: 2px solid #17a2b8; border-radius: 4px; cursor: pointer; font-weight: bold; font-size: 13px; transition: all 0.3s ease;" onmouseover="this.style.transform='scale(1.05)'; this.style.boxShadow='0 0 15px #17a2b8'; this.style.textShadow='0 0 8px #17a2b8';" onmouseout="this.style.transform='scale(1)'; this.style.boxShadow='none'; this.style.textShadow='none';">
                                    ADD TO ALL PLAYLISTS
                                </button>
                            </div>
                        </div>
                    </div>
                `;
                
                document.body.appendChild(modal);
                
                // Focus on search input
                document.getElementById('playlistSearchInput').focus();
                
            } catch (error) {
                // Close loading modal
                const loadingModal = document.querySelector('.playlist-loading-modal');
                if (loadingModal) loadingModal.remove();
                
                console.error('Error loading playlists:', error);
                showPlaylistErrorModal('Error Loading Playlists', 'Could not load existing playlists. Please try again.');
            }
        }

        // Get existing playlists
        async function getExistingPlaylists() {
            try {
                const response = await fetch('/api/validate_existing_playlist', {
                    method: 'POST',
                    headers: {
                        'Content-Type': 'application/json',
                        ...window.authHeaders
                    },
                    body: JSON.stringify({
                        action: 'list_all'
                    })
                });
                
                if (response.ok) {
                    const data = await response.json();
                    console.log('Playlist list response:', data);
                    
                    if (data.success && data.playlists && Array.isArray(data.playlists)) {
                        return data.playlists.map(playlist => ({
                            name: playlist.replace(/^video_system_playlist_/, '').replace(/\.txt$/, '').replace(/_/g, ' '),
                            filename: playlist,
                            displayName: playlist.replace(/^video_system_playlist_/, '').replace(/\.txt$/, '').replace(/_/g, ' ').charAt(0).toUpperCase() + playlist.replace(/^video_system_playlist_/, '').replace(/\.txt$/, '').replace(/_/g, ' ').slice(1)
                        })).sort((a, b) => a.displayName.localeCompare(b.displayName));
                    } else {
                        console.log('No playlists found in response');
                        return [];
                    }
                } else {
                    throw new Error('Failed to load playlists');
                }
            } catch (error) {
                console.error('Error fetching playlists:', error);
                return [];
            }
        }

        // Generate playlist list HTML
        function generatePlaylistList(playlists) {
            let html = '<div style="display: grid; grid-template-columns: repeat(5, 1fr); gap: 8px;">';
            
            playlists.forEach((playlist, index) => {
                html += `
                    <div class="playlist-item" data-playlist-name="${playlist.name}" style="display: flex; align-items: center; padding: 8px; border-radius: 4px; cursor: pointer; transition: background 0.2s; border: 1px solid #333;" onclick="togglePlaylistSelection(this)">
                        <input type="checkbox" id="playlist_${index}" style="margin-right: 8px; flex-shrink: 0;" onchange="event.stopPropagation(); handleCheckboxChange(this);">
                        <label for="playlist_${index}" style="color: #e0e0e0; font-size: 12px; cursor: pointer; flex: 1; overflow: hidden; text-overflow: ellipsis; white-space: nowrap;" title="${playlist.displayName}">${playlist.displayName}</label>
                    </div>
                `;
            });
            
            html += '</div>';
            return html;
        }

        // Filter playlist list based on search
        function filterPlaylistList() {
            const searchTerm = document.getElementById('playlistSearchInput').value.toLowerCase();
            const playlistItems = document.querySelectorAll('.playlist-item');
            
            playlistItems.forEach(item => {
                const playlistName = item.getAttribute('data-playlist-name').toLowerCase();
                const displayName = item.querySelector('label').textContent.toLowerCase();
                
                if (playlistName.includes(searchTerm) || displayName.includes(searchTerm)) {
                    item.style.display = 'flex';
                } else {
                    item.style.display = 'none';
                }
            });
        }

        // Select playlist item
        function selectPlaylist(item) {
            // Multi-select functionality - toggle the checkbox for this item
            const checkbox = item.querySelector('input[type="checkbox"]');
            if (checkbox) {
                checkbox.checked = !checkbox.checked;
                // Visual feedback - highlight selected items
                if (checkbox.checked) {
                    item.style.background = 'rgba(0,191,255,0.2)';
                } else {
                    item.style.background = 'transparent';
                }
                updatePlaylistSelectionCount();
            }
        }

        // Confirm adding videos to selected playlist
        async function confirmAddVideosToPlaylist(type, videos) {
            // Find all selected playlists
            const selectedCheckboxes = document.querySelectorAll('.playlist-item input[type="checkbox"]:checked');
            if (selectedCheckboxes.length === 0) {
                showPlaylistErrorModal('No Playlist Selected', 'Please select at least one playlist to add the videos to.');
                return;
            }
            
            // Get playlist names from selected checkboxes
            const selectedPlaylists = [];
            selectedCheckboxes.forEach(checkbox => {
                const playlistItem = checkbox.closest('.playlist-item');
                const playlistName = playlistItem.getAttribute('data-playlist-name');
                selectedPlaylists.push(playlistName);
            });
            
            console.log('Adding videos to playlists:', selectedPlaylists, 'Type:', type, 'Videos:', videos);
            
            // Close selection modal
            document.querySelector('.playlist-selection-modal').remove();
            
            // Show loading
            showPlaylistLoadingModal();
            
            try {
                // Call existing API to add videos to each selected playlist
                let successCount = 0;
                let errorCount = 0;
                const results = [];
                
                for (const playlistName of selectedPlaylists) {
                    try {
                        const response = await fetch('/api/add_videos_to_playlist', {
                            method: 'POST',
                            headers: {
                                ...window.authHeaders,
                                'Content-Type': 'application/json'
                            },
                            body: JSON.stringify({
                                playlist_name: playlistName,
                                videos: videos,
                                type: type
                            })
                        });
                        
                        if (response.ok) {
                            successCount++;
                            results.push({ playlist: playlistName, status: 'success' });
                        } else {
                            errorCount++;
                            results.push({ playlist: playlistName, status: 'error' });
                        }
                    } catch (error) {
                        errorCount++;
                        results.push({ playlist: playlistName, status: 'error' });
                        console.error(`Error adding to playlist ${playlistName}:`, error);
                    }
                }
                
                // Close loading modal
                const loadingModal = document.querySelector('.playlist-loading-modal');
                if (loadingModal) loadingModal.remove();
                
                // Show results
                if (errorCount === 0) {
                    const playlistText = selectedPlaylists.length === 1 ? 'playlist' : 'playlists';
                    showPlaylistSuccessModal(`Videos Added!`, `Successfully added ${videos.length} video${videos.length === 1 ? '' : 's'} to all ${successCount} selected ${playlistText}.`);
                } else if (successCount === 0) {
                    showPlaylistErrorModal('Addition Failed', 'Failed to add videos to any of the selected playlists. Please try again.');
                } else {
                    const playlistText = selectedPlaylists.length === 1 ? 'playlist' : 'playlists';
                    showPlaylistSuccessModal(`Partial Success`, `Added videos to ${successCount} of ${selectedPlaylists.length} selected ${playlistText}. ${errorCount} failed.`);
                }
                
            } catch (error) {
                // Close loading modal
                const loadingModal = document.querySelector('.playlist-loading-modal');
                if (loadingModal) loadingModal.remove();
                
                console.error('Error adding videos to playlists:', error);
                showPlaylistErrorModal('Addition Failed', 'Could not add videos to playlists. Please try again.');
            }
        }

        // Show playlist selection modal for editing
        function showPlaylistEditSelectionModal(playlists) {
            console.log('Opening playlist edit selection modal with', playlists.length, 'playlists');
            
            const modal = document.createElement('div');
            modal.className = 'modal playlist-edit-selection-modal';
            modal.style.display = 'block';
            
            modal.innerHTML = `
                <div class="modal-content playlist-modal-content" style="width: fit-content !important; max-width: 1600px !important; min-width: 1200px !important; margin: 5% auto !important; padding: 0 !important; height: auto !important; max-height: 600px !important;">
                    <div class="modal-header" style="background: #000000; padding: 15px; border-radius: 8px 8px 0 0;">
                        <h2 style="color: #ffd700; font-size: 16px; margin: 0;"> Edit Playlist - Select Playlist</h2>
                        <button class="close" onclick="this.closest('.modal').remove()" style="color: #ffd700; background: none; border: none; font-size: 18px; cursor: pointer; float: right;">&times;</button>
                    </div>
                    <div class="modal-body" style="padding: 20px; max-height: 500px; overflow-y: auto;">
                        <div style="margin-bottom: 15px;">
                            <h3 style="color: #ffd700; font-size: 14px; margin-bottom: 10px;">Select a playlist to edit:</h3>
                            <input type="text" id="editPlaylistSearchInput" placeholder="Search playlists..." 
                                   style="width: 100%; padding: 8px; background: rgba(0,0,0,0.8); border: 1px solid #ffd700; border-radius: 4px; color: white; font-size: 13px; margin-bottom: 15px; box-sizing: border-box;"
                                   oninput="filterEditPlaylistList()">
                        </div>
                        <div id="editPlaylistList" style="max-height: 300px; overflow-y: auto; border: 1px solid #333; border-radius: 4px; background: rgba(0,0,0,0.3); padding: 15px;">
                            ${generateEditPlaylistList(playlists)}
                        </div>
                        <div style="display: flex; gap: 10px; justify-content: flex-end; margin-top: 20px;">
                            <button onclick="this.closest('.modal').remove()" 
                                    style="padding: 8px 16px; background: #6c757d; color: white; border: none; border-radius: 4px; cursor: pointer; font-size: 13px;">
                                Cancel
                            </button>
                            <button onclick="confirmEditPlaylist()" 
                                    style="padding: 8px 16px; background: #ffd700; color: #000; border: none; border-radius: 4px; cursor: pointer; font-size: 13px; font-weight: bold;">
                                Edit Selected Playlist
                            </button>
                        </div>
                    </div>
                </div>
            `;
            
            document.body.appendChild(modal);
        }

        // Generate playlist list HTML for editing
        function generateEditPlaylistList(playlists) {
            let html = '<div style="display: grid; grid-template-columns: repeat(5, 1fr); gap: 8px;">';
            
            playlists.forEach((playlist, index) => {
                html += `
                    <div class="edit-playlist-item" data-playlist-name="${playlist.name}" data-playlist-filename="${playlist.filename}" style="display: flex; flex-direction: column; padding: 10px; border-radius: 6px; cursor: pointer; transition: background 0.2s; border: 1px solid #333;" onclick="selectEditPlaylist(this)">
                        <div style="display: flex; align-items: flex-start; margin-bottom: 6px;">
                            <input type="radio" name="editPlaylistSelection" id="editPlaylist_${index}" style="margin-right: 8px; flex-shrink: 0; margin-top: 2px;">
                            <div style="flex: 1; min-width: 0;">
                                <label for="editPlaylist_${index}" style="color: #e0e0e0; font-size: 12px; cursor: pointer; font-weight: bold; display: block; overflow: hidden; text-overflow: ellipsis; white-space: nowrap;" title="${playlist.displayName}">${playlist.displayName}</label>
                                <div style="color: #888; font-size: 10px; margin-top: 2px; overflow: hidden; text-overflow: ellipsis; white-space: nowrap;" title="${playlist.filename}">${playlist.filename}</div>
                            </div>
                        </div>
                    </div>
                `;
            });
            
            html += '</div>';
            return html;
        }

        // Filter edit playlist list based on search
        function filterEditPlaylistList() {
            const searchTerm = document.getElementById('editPlaylistSearchInput').value.toLowerCase();
            const playlistItems = document.querySelectorAll('.edit-playlist-item');
            
            playlistItems.forEach(item => {
                const playlistName = item.dataset.playlistName.toLowerCase();
                const playlistFilename = item.dataset.playlistFilename.toLowerCase();
                if (playlistName.includes(searchTerm) || playlistFilename.includes(searchTerm)) {
                    item.style.display = 'flex';
                } else {
                    item.style.display = 'none';
                }
            });
        }

        // Select edit playlist item
        function selectEditPlaylist(item) {
            // Clear other selections
            document.querySelectorAll('.edit-playlist-item').forEach(i => {
                i.style.background = '';
                i.style.borderColor = 'transparent';
                i.querySelector('input[type="radio"]').checked = false;
            });
            
            // Select this item
            item.style.background = 'rgba(255,215,0,0.2)';
            item.style.borderColor = '#ffd700';
            item.querySelector('input[type="radio"]').checked = true;
        }

        // Confirm edit playlist selection
        async function confirmEditPlaylist() {
            // Find selected playlist
            const selectedRadio = document.querySelector('.edit-playlist-item input[type="radio"]:checked');
            if (!selectedRadio) {
                showPlaylistErrorModal('No Playlist Selected', 'Please select a playlist to edit.');
                return;
            }
            
            const playlistItem = selectedRadio.closest('.edit-playlist-item');
            const playlistName = playlistItem.dataset.playlistName;
            const playlistFilename = playlistItem.dataset.playlistFilename;
            
            console.log('Opening edit modal for playlist:', playlistName, playlistFilename);
            
            // Close selection modal first
            const selectionModal = document.querySelector('.playlist-edit-selection-modal');
            if (selectionModal) {
                selectionModal.remove();
            }
            
            // Open the actual edit modal directly - no error handling
            openPlaylistEditModal(playlistName, playlistFilename);
        }

        // Open the main playlist edit modal
        async function openPlaylistEditModal(playlistName, playlistFilename) {
            console.log('Opening edit modal for:', playlistName, playlistFilename);
            
            // Show loading modal
            showPlaylistLoadingModal();
            
            // Load playlist content
            const playlistData = await loadPlaylistContent(playlistFilename);
            
            // Close loading modal
            const loadingModal = document.querySelector('.playlist-loading-modal');
            if (loadingModal) loadingModal.remove();
            
            console.log('Successfully loaded playlist data:', playlistData);
            
            // Create the edit modal
            const modal = document.createElement('div');
            modal.className = 'modal playlist-edit-modal';
            modal.style.display = 'block';
            
            modal.innerHTML = `
                <div class="modal-content playlist-modal-content" style="width: 90% !important; max-width: 1400px !important; min-width: 1200px !important; margin: 2% auto !important; padding: 0 !important; height: 90vh !important; display: flex; flex-direction: column;">
                    <div class="modal-header" style="background: #000000; padding: 15px; border-radius: 8px 8px 0 0; flex-shrink: 0;">
                        <h2 style="color: #ffd700; font-size: 18px; margin: 0;"> Edit Playlist: ${playlistName}</h2>
                        <button class="close" onclick="closeEditModal()" style="color: #ffd700; background: none; border: none; font-size: 20px; cursor: pointer; float: right; transition: all 0.3s ease;" onmouseover="this.style.transform='scale(1.05)'; this.style.textShadow='0 0 8px #ffd700';" onmouseout="this.style.transform='scale(1)'; this.style.textShadow='none';">&times;</button>
                    </div>
                    <div class="modal-body" style="padding: 20px; flex: 1; overflow: hidden; display: flex; flex-direction: column;">
                        <!-- Action Buttons Row -->
                        <div style="display: flex; gap: 10px; margin-bottom: 20px; flex-shrink: 0;">
                            <button onclick="addVideosToCurrentPlaylist()" style="padding: 10px 16px; background: #000000; color: #28a745; border: 2px solid #28a745; border-radius: 6px; cursor: pointer; font-size: 13px; font-weight: bold; transition: all 0.3s ease;" onmouseover="this.style.transform='scale(1.05)'; this.style.boxShadow='0 0 15px #28a745'; this.style.textShadow='0 0 8px #28a745';" onmouseout="this.style.transform='scale(1)'; this.style.boxShadow='none'; this.style.textShadow='none';">
                                 Add Videos
                            </button>
                            <button onclick="removeAllVideosFromPlaylist()" style="padding: 10px 16px; background: #000000; color: #dc3545; border: 2px solid #dc3545; border-radius: 6px; cursor: pointer; font-size: 13px; font-weight: bold; transition: all 0.3s ease;" onmouseover="this.style.transform='scale(1.05)'; this.style.boxShadow='0 0 15px #dc3545'; this.style.textShadow='0 0 8px #dc3545';" onmouseout="this.style.transform='scale(1)'; this.style.boxShadow='none'; this.style.textShadow='none';">
                                 Remove All
                            </button>
                            <button onclick="refreshPlaylistMetadata()" style="padding: 10px 16px; background: #000000; color: #17a2b8; border: 2px solid #17a2b8; border-radius: 6px; cursor: pointer; font-size: 13px; font-weight: bold; transition: all 0.3s ease;" onmouseover="this.style.transform='scale(1.05)'; this.style.boxShadow='0 0 15px #17a2b8'; this.style.textShadow='0 0 8px #17a2b8';" onmouseout="this.style.transform='scale(1)'; this.style.boxShadow='none'; this.style.textShadow='none';">
                                 Refresh Metadata
                            </button>
                            <button onclick="savePlaylistChanges()" style="padding: 10px 16px; background: #000000; color: #ffd700; border: 2px solid #ffd700; border-radius: 6px; cursor: pointer; font-size: 13px; font-weight: bold; transition: all 0.3s ease;" onmouseover="this.style.transform='scale(1.05)'; this.style.boxShadow='0 0 15px #ffd700'; this.style.textShadow='0 0 8px #ffd700';" onmouseout="this.style.transform='scale(1)'; this.style.boxShadow='none'; this.style.textShadow='none';">
                                 Save Changes
                            </button>
                            <button id="undoLastChangeBtn" onclick="undoLastAction()" style="display: none; padding: 10px 16px; background: #000000; color: #00ffff; border: 2px solid #00ffff; border-radius: 6px; cursor: pointer; font-size: 13px; font-weight: bold; margin-left: 10px; transition: all 0.3s ease;" onmouseover="this.style.transform='scale(1.05)'; this.style.boxShadow='0 0 15px #00ffff'; this.style.textShadow='0 0 8px #00ffff';" onmouseout="this.style.transform='scale(1)'; this.style.boxShadow='none'; this.style.textShadow='none';">
                                 Undo Last Change
                            </button>
                            <button onclick="goToPlaylistTop()" style="padding: 10px 16px; background: #000000; color: #ff7f00; border: 2px solid #ff7f00; border-radius: 6px; cursor: pointer; font-size: 13px; font-weight: bold; margin-left: 10px; transition: all 0.3s ease;" onmouseover="this.style.transform='scale(1.05)'; this.style.boxShadow='0 0 15px #ff7f00'; this.style.textShadow='0 0 8px #ff7f00';" onmouseout="this.style.transform='scale(1)'; this.style.boxShadow='none'; this.style.textShadow='none';">
                                Go to Top
                            </button>
                            <button onclick="goToPlaylistBottom()" style="padding: 10px 16px; background: #000000; color: #ff7f00; border: 2px solid #ff7f00; border-radius: 6px; cursor: pointer; font-size: 13px; font-weight: bold; transition: all 0.3s ease;" onmouseover="this.style.transform='scale(1.05)'; this.style.boxShadow='0 0 15px #ff7f00'; this.style.textShadow='0 0 8px #ff7f00';" onmouseout="this.style.transform='scale(1)'; this.style.boxShadow='none'; this.style.textShadow='none';">
                                Go to Bottom
                            </button>
                            <button onclick="goToPlaylistMiddle()" style="padding: 10px 16px; background: #000000; color: #ff7f00; border: 2px solid #ff7f00; border-radius: 6px; cursor: pointer; font-size: 13px; font-weight: bold; transition: all 0.3s ease;" onmouseover="this.style.transform='scale(1.05)'; this.style.boxShadow='0 0 15px #ff7f00'; this.style.textShadow='0 0 8px #ff7f00';" onmouseout="this.style.transform='scale(1)'; this.style.boxShadow='none'; this.style.textShadow='none';">
                                Go to Middle
                            </button>
                        </div>
                        
                        <!-- Playlist Content -->
                        <div style="flex: 1; overflow: hidden; display: flex; flex-direction: column;">
                            <div style="display: flex; justify-content: between; align-items: center; margin-bottom: 10px;">
                                <h3 style="color: #ffd700; font-size: 16px; margin: 0;"> Videos in Playlist (${playlistData.videos.length})</h3>
                                <div style="color: #888; font-size: 12px;">Drag videos to reorder  Click remove button to delete</div>
                            </div>
                            
                            <div id="editablePlaylistContent" style="flex: 1; overflow-y: auto; border: 1px solid #444; border-radius: 6px; background: rgba(0,0,0,0.4); padding: 15px;" data-playlist-name="${playlistName}" data-playlist-filename="${playlistFilename}">
                                ${generateEditablePlaylistHTML(playlistData.videos)}
                            </div>
                        </div>
                    </div>
                </div>
            `;
            
            document.body.appendChild(modal);
            
            // Initialize action queue system
            initializeActionQueue();
            
            // Initialize drag and drop functionality
            initializePlaylistDragAndDrop();
        }

        // Initialize drag and drop functionality for playlist editing
        function initializePlaylistDragAndDrop() {
            const container = document.getElementById('editablePlaylistContent');
            if (!container) return;
            
            let draggedElement = null;
            let draggedIndex = null;
            
            // Add event listeners to all draggable items
            const items = container.querySelectorAll('.editable-video-item');
            items.forEach((item, index) => {
                item.addEventListener('dragstart', function(e) {
                    draggedElement = this;
                    draggedIndex = parseInt(this.dataset.videoIndex);
                    this.style.opacity = '0.5';
                    e.dataTransfer.effectAllowed = 'move';
                });
                
                item.addEventListener('dragend', function(e) {
                    this.style.opacity = '1';
                    draggedElement = null;
                    draggedIndex = null;
                });
                
                item.addEventListener('dragover', function(e) {
                    e.preventDefault();
                    e.dataTransfer.dropEffect = 'move';
                });
                
                item.addEventListener('drop', function(e) {
                    e.preventDefault();
                    if (draggedElement && draggedElement !== this) {
                        const targetIndex = parseInt(this.dataset.videoIndex);
                        reorderPlaylistVideos(draggedIndex, targetIndex);
                    }
                });
                
                item.addEventListener('dragenter', function(e) {
                    e.preventDefault();
                    if (draggedElement !== this) {
                        this.style.backgroundColor = 'rgba(255,215,0,0.2)';
                    }
                });
                
                item.addEventListener('dragleave', function(e) {
                    this.style.backgroundColor = 'rgba(0,0,0,0.2)';
                });
            });
        }

        // Reorder videos in the playlist
        function reorderPlaylistVideos(fromIndex, toIndex) {
            console.log('Reordering video from index', fromIndex, 'to', toIndex);
            
            const container = document.getElementById('editablePlaylistContent');
            const items = Array.from(container.querySelectorAll('.editable-video-item'));
            
            // Get the video path for the item being moved
            const draggedItem = items[fromIndex];
            const videoPath = draggedItem.querySelector('div:nth-child(3)').textContent.trim();
            
            // Move the element in the array (visual update only)
            items.splice(fromIndex, 1);
            items.splice(toIndex, 0, draggedItem);
            
            // Update the DOM
            container.innerHTML = '';
            items.forEach((item, newIndex) => {
                // Update the index in the item
                item.dataset.videoIndex = newIndex;
                // Update the displayed number
                const numberElement = item.querySelector('div:nth-child(2)');
                if (numberElement) {
                    numberElement.textContent = `${newIndex + 1}.`;
                }
                // Update the remove button onclick
                const removeButton = item.querySelector('button');
                if (removeButton) {
                    removeButton.setAttribute('onclick', `removeVideoFromPlaylist(${newIndex})`);
                }
                container.appendChild(item);
            });
            
            // Re-initialize drag and drop
            initializePlaylistDragAndDrop();
            
            // Add reorder action to queue instead of immediately persisting
            const playlistContainer = document.getElementById('editablePlaylistContent');
            const playlistFilename = playlistContainer.dataset.playlistFilename;
            const playlistName = playlistContainer.dataset.playlistName;
            
            addToActionQueue({
                type: 'reorder_video',
                videoPath: videoPath,
                fromIndex: fromIndex,
                toIndex: toIndex,
                playlistFilename: playlistFilename,
                playlistName: playlistName
            });
        }

        // Mark playlist as having unsaved changes
        function markPlaylistAsChanged() {
            const saveButton = document.querySelector('button[onclick="savePlaylistChanges()"]');
            if (saveButton) {
                saveButton.style.background = '#ff6b35';
                saveButton.textContent = ' Save Changes*';
            }
        }

        // Add Videos to Current Playlist
        async function addVideosToCurrentPlaylist() {
            console.log('Add Videos to current playlist clicked');
            
            const container = document.getElementById('editablePlaylistContent');
            const playlistName = container.dataset.playlistName;
            const playlistFilename = container.dataset.playlistFilename;
            
            // Show video selection interface above the current playlist
            showVideoSelectionInterface(playlistName, playlistFilename);
        }

        // Show video selection interface
        async function showVideoSelectionInterface(playlistName, playlistFilename) {
            // Check if interface already exists
            let existingInterface = document.getElementById('videoSelectionInterface');
            if (existingInterface) {
                existingInterface.remove();
            }
            
            // Create the video selection interface
            const playlistContainer = document.getElementById('editablePlaylistContent').parentElement;
            const videoSelectionDiv = document.createElement('div');
            videoSelectionDiv.id = 'videoSelectionInterface';
            videoSelectionDiv.style.cssText = `
                margin-bottom: 20px;
                border: 2px solid #28a745;
                border-radius: 8px;
                background: #000000;
                padding: 15px;
                flex: 1;
                display: flex;
                flex-direction: column;
                min-height: 500px;
            `;
            
            videoSelectionDiv.innerHTML = `
                <div style="display: flex; justify-content: space-between; align-items: center; margin-bottom: 15px;">
                    <h4 style="color: #28a745; font-size: 16px; margin: 0;"> Add Videos to "${playlistName}"</h4>
                    <button onclick="closeVideoSelectionInterface()" style="background: #000000; color: #dc3545; border: 2px solid #dc3545; border-radius: 4px; padding: 5px 10px; cursor: pointer; font-weight: bold; transition: all 0.3s ease;" onmouseover="this.style.transform='scale(1.05)'; this.style.boxShadow='0 0 15px #dc3545'; this.style.textShadow='0 0 8px #dc3545';" onmouseout="this.style.transform='scale(1)'; this.style.boxShadow='none'; this.style.textShadow='none';"> Close</button>
                </div>
                
                <!-- Search and Filter -->
                <div style="display: flex; gap: 10px; margin-bottom: 15px; align-items: center; flex-shrink: 0;">
                    <input type="text" id="playlistVideoSearchInput" placeholder="Search videos..." style="flex: 1; padding: 8px; background: rgba(0,0,0,0.8); border: 1px solid #28a745; border-radius: 4px; color: white; font-size: 13px;" oninput="searchVideosForPlaylist()">
                    <button onclick="searchVideosForPlaylist()" style="padding: 8px 16px; background: #000000; color: #17a2b8; border: 2px solid #17a2b8; border-radius: 4px; cursor: pointer; font-weight: bold; transition: all 0.3s ease;" onmouseover="this.style.transform='scale(1.05)'; this.style.boxShadow='0 0 15px #17a2b8'; this.style.textShadow='0 0 8px #17a2b8';" onmouseout="this.style.transform='scale(1)'; this.style.boxShadow='none'; this.style.textShadow='none';"> Filter</button>
                    <button onclick="clearPlaylistVideoSearch()" style="padding: 8px 16px; background: #000000; color: #dc3545; border: 2px solid #dc3545; border-radius: 4px; cursor: pointer; font-weight: bold; transition: all 0.3s ease;" onmouseover="this.style.transform='scale(1.05)'; this.style.boxShadow='0 0 15px #dc3545'; this.style.textShadow='0 0 8px #dc3545';" onmouseout="this.style.transform='scale(1)'; this.style.boxShadow='none'; this.style.textShadow='none';">Clear</button>
                    <button onclick="refreshVideoMetadataForPlaylist()" style="padding: 8px 16px; background: #000000; color: #ffc107; border: 2px solid #ffc107; border-radius: 4px; cursor: pointer; font-weight: bold; transition: all 0.3s ease;" onmouseover="this.style.transform='scale(1.05)'; this.style.boxShadow='0 0 15px #ffc107'; this.style.textShadow='0 0 8px #ffc107';" onmouseout="this.style.transform='scale(1)'; this.style.boxShadow='none'; this.style.textShadow='none';"> Refresh</button>
                </div>
                
                <!-- Video Results -->
                <div id="playlistVideoResults" style="flex: 1; overflow-y: auto; border: 1px solid #444; border-radius: 4px; background: rgba(0,0,0,0.4); padding: 10px; min-height: 400px;">
                    <div style="text-align: center; color: #888; padding: 40px;">
                        Loading all videos...
                    </div>
                </div>
            `;
            
            // Insert before the current playlist
            playlistContainer.insertBefore(videoSelectionDiv, playlistContainer.firstChild);
            
            // Make the playlist container use flex layout
            playlistContainer.style.display = 'flex';
            playlistContainer.style.flexDirection = 'column';
            playlistContainer.style.flex = '1';
            
            // Load all videos immediately
            loadAllVideosForPlaylist();
        }

        // Close video selection interface
        function closeVideoSelectionInterface() {
            const interface = document.getElementById('videoSelectionInterface');
            if (interface) {
                interface.remove();
            }
        }

        // Store all videos globally for filtering
        let allVideosForPlaylist = [];
        let currentFilteredVideos = []; // Store currently filtered/displayed videos

        // Load all videos for playlist addition
        async function loadAllVideosForPlaylist() {
            const resultsContainer = document.getElementById('playlistVideoResults');
            
            resultsContainer.innerHTML = '<div style="text-align: center; color: #888; padding: 40px;"> Loading all videos...</div>';
            
            try {
                // Load the video library directly to get all videos
                console.log('Loading all videos using loadVideoLibrary function...');
                
                // Get all videos from the library
                if (!allVideos || allVideos.length === 0) {
                    await loadVideoLibrary();
                }
                
                if (allVideos && allVideos.length > 0) {
                    // Use the existing allVideos array
                    allVideosForPlaylist = allVideos.map((video, index) => ({
                        name: video.name || video.filename || 'Unknown',
                        path: video.path || video.name || video.filename,
                        size: video.size || 'Unknown',
                        index: index
                    }));
                    
                    console.log('Loaded videos from video library:', allVideosForPlaylist.length);
                    currentFilteredVideos = allVideosForPlaylist; // Initially all videos are "filtered"
                    displayPlaylistVideosForSelection(allVideosForPlaylist);
                } else {
                    // Fallback: Try to get videos through API directly
                    const response = await fetch('/api/videos');
                    if (response.ok) {
                        const videoData = await response.json();
                        if (videoData.success && videoData.videos) {
                            allVideosForPlaylist = videoData.videos.map((video, index) => ({
                                name: video.name || video.filename || 'Unknown',
                                path: video.path || video.name || video.filename,
                                size: video.size || 'Unknown',
                                index: index
                            }));
                            currentFilteredVideos = allVideosForPlaylist; // Initially all videos are "filtered"
                            displayPlaylistVideosForSelection(allVideosForPlaylist);
                        } else {
                            throw new Error('No videos found via API');
                        }
                    } else {
                        throw new Error('Failed to fetch videos from API');
                    }
                }
                
            } catch (error) {
                console.error('Error loading all videos:', error);
                resultsContainer.innerHTML = `
                    <div style="text-align: center; color: #dc3545; padding: 40px;">
                        <div>Error loading videos</div>
                        <button onclick="loadAllVideosForPlaylist()" style="margin-top: 10px; padding: 8px 16px; background: #17a2b8; color: white; border: none; border-radius: 4px; cursor: pointer;">
                            <span onclick="event.stopPropagation(); loadAllVideosForPlaylist()" style="padding: 8px 16px; background: #000000; color: #17a2b8; border: 2px solid #17a2b8; border-radius: 4px; cursor: pointer;"> Load All Videos</span>
                        </button>
                    </div>
                `;
            }
        }

        // Search videos for playlist addition (filter locally or search remotely)
        async function searchVideosForPlaylist() {
            const searchTerm = document.getElementById('playlistVideoSearchInput').value.trim().toLowerCase();
            console.log('Searching with term:', searchTerm);
            console.log('Available videos:', allVideosForPlaylist ? allVideosForPlaylist.length : 0);
            
            // If we have videos loaded, filter locally
            if (allVideosForPlaylist && allVideosForPlaylist.length > 0) {
                let filteredVideos = allVideosForPlaylist;
                if (searchTerm) {
                    filteredVideos = allVideosForPlaylist.filter(video => {
                        // More robust filtering with null checks
                        const videoName = (video.name || '').toLowerCase();
                        const videoPath = (video.path || '').toLowerCase();
                        const videoSize = (video.size || '').toLowerCase();
                        
                        return videoName.includes(searchTerm) || 
                               videoPath.includes(searchTerm) ||
                               videoSize.includes(searchTerm);
                    });
                }
                
                console.log('Filtered videos locally:', filteredVideos.length, 'from', allVideosForPlaylist.length, 'total');
                console.log('Sample filtered results:', filteredVideos.slice(0, 3));
                currentFilteredVideos = filteredVideos; // Store filtered results
                displayPlaylistVideosForSelection(filteredVideos);
                return;
            }
            
            // If no videos loaded yet, load all videos first then filter
            console.log('Videos not loaded yet, loading all videos first...');
            const resultsContainer = document.getElementById('playlistVideoResults');
            resultsContainer.innerHTML = '<div style="text-align: center; color: #888; padding: 40px;"> Loading videos for search...</div>';
            
            try {
                // Load all videos first
                await loadAllVideosForPlaylist();
                
                // Now that videos are loaded, search again
                if (allVideosForPlaylist && allVideosForPlaylist.length > 0 && searchTerm) {
                    const filteredVideos = allVideosForPlaylist.filter(video => {
                        const videoName = (video.name || '').toLowerCase();
                        const videoPath = (video.path || '').toLowerCase();
                        const videoSize = (video.size || '').toLowerCase();
                        
                        return videoName.includes(searchTerm) || 
                               videoPath.includes(searchTerm) ||
                               videoSize.includes(searchTerm);
                    });
                    
                    console.log('Filtered videos after loading:', filteredVideos.length, 'from', allVideosForPlaylist.length, 'total');
                    currentFilteredVideos = filteredVideos; // Store filtered results
                    displayPlaylistVideosForSelection(filteredVideos);
                } else if (allVideosForPlaylist && allVideosForPlaylist.length > 0) {
                    // No search term, show all videos
                    currentFilteredVideos = allVideosForPlaylist; // Store all videos as current
                    displayPlaylistVideosForSelection(allVideosForPlaylist);
                }
            } catch (error) {
                console.error('Error searching videos:', error);
                resultsContainer.innerHTML = `
                    <div style="text-align: center; color: #dc3545; padding: 40px;">
                        <div>Error loading videos for search</div>
                        <button onclick="loadAllVideosForPlaylist()" style="margin-top: 10px; padding: 8px 16px; background: #000000; color: #17a2b8; border: 2px solid #17a2b8; border-radius: 4px; cursor: pointer; font-weight: bold;"> Load All Videos</button>
                    </div>
                `;
            }
        }

        // Refresh video metadata for playlist
        async function refreshVideoMetadataForPlaylist() {
            const resultsContainer = document.getElementById('playlistVideoResults');
            resultsContainer.innerHTML = '<div style="text-align: center; color: #888; padding: 40px;"> Refreshing video metadata...</div>';
            
            try {
                // Use the existing refreshMetadata function from the main dashboard
                console.log('Refreshing metadata using main refreshMetadata function...');
                
                // Call the existing refreshMetadata function
                if (typeof refreshMetadata === 'function') {
                    await refreshMetadata();
                } else {
                    // Fallback: manually trigger the refresh metadata button
                    const refreshBtn = document.querySelector('button[onclick*="refreshMetadata"]');
                    if (refreshBtn) {
                        refreshBtn.click();
                    }
                }
                
                // Wait for metadata refresh to complete
                await new Promise(resolve => setTimeout(resolve, 2000));
                
                // Clear search and reload all videos
                const videoSearchInput = document.getElementById('playlistVideoSearchInput');
                if (videoSearchInput) {
                    videoSearchInput.value = '';
                }
                allVideosForPlaylist = []; // Clear cache
                
                // Reload all videos with fresh metadata
                await loadAllVideosForPlaylist();
                
            } catch (error) {
                console.error('Error refreshing metadata:', error);
                resultsContainer.innerHTML = `
                    <div style="text-align: center; color: #dc3545; padding: 40px;">
                        <div>Error refreshing metadata</div>
                        <button onclick="refreshVideoMetadataForPlaylist()" style="margin-top: 10px; padding: 8px 16px; background: #ffc107; color: #000; border: none; border-radius: 4px; cursor: pointer;">Retry</button>
                    </div>
                `;
            }
        }

        // Display videos for selection
        function displayPlaylistVideosForSelection(videos) {
            const resultsContainer = document.getElementById('playlistVideoResults');
            
            if (!videos || videos.length === 0) {
                resultsContainer.innerHTML = `
                    <div style="text-align: center; color: #888; padding: 40px;">
                        <div style="margin-bottom: 15px;">No videos found</div>
                        <button onclick="loadAllVideosForPlaylist()" style="padding: 8px 16px; background: #17a2b8; color: white; border: none; border-radius: 4px; cursor: pointer;">Load All Videos</button>
                    </div>
                `;
                return;
            }
            
            const videosHTML = videos.map((video, index) => `
                <div id="videoItem_${index}" style="display: flex; align-items: center; padding: 10px; border-bottom: 1px solid #333; margin-bottom: 5px; background: #000000; border-radius: 4px;">
                    <input type="checkbox" id="addVideo_${index}" onchange="togglePlaylistVideoSelection(${index})" style="margin-right: 10px;">
                    
                    <!-- Video Thumbnail -->
                    <div class="video-thumbnail-container" id="thumbnail-metadata-${index}" style="margin-right: 10px;" 
                         onmouseenter="handleThumbnailHover('${video.name}', '${video.path}', 'thumbnail-metadata-${index}')"
                         onmouseleave="handleThumbnailLeave('thumbnail-metadata-${index}')"
                         onclick="handleThumbnailHover('${video.name}', '${video.path}', 'thumbnail-metadata-${index}')">
                        <div class="video-thumbnail-placeholder"></div>
                        <div class="video-thumbnail-loading" style="display: none;">Loading...</div>
                        <video class="video-thumbnail" muted></video>
                    </div>
                    
                    <div style="flex: 1; margin-right: 10px;">
                        <div style="color: #e0e0e0; font-size: 16px; font-weight: bold; margin-bottom: 3px; cursor: pointer;"
                             onmouseenter="handleThumbnailHover('${video.name}', '${video.path}', 'thumbnail-metadata-${index}')"
                             onmouseleave="handleThumbnailLeave('thumbnail-metadata-${index}')"
                             onclick="handleThumbnailHover('${video.name}', '${video.path}', 'thumbnail-metadata-${index}')">${video.name}</div>
                        <div style="color: #888; font-size: 13px;">${video.path}</div>
                        <div style="color: #666; font-size: 12px;">Size: ${video.size || 'Unknown'}</div>
                    </div>
                    
                    <button onclick="addSingleVideoToPlaylist('${video.name}', '${video.path}')" style="background: #000000; color: #28a745; border: 2px solid #28a745; border-radius: 4px; padding: 6px 12px; cursor: pointer; font-size: 12px; transition: all 0.3s ease;" onmouseover="this.style.transform='scale(1.05)'; this.style.boxShadow='0 0 15px #28a745'; this.style.textShadow='0 0 8px #28a745';" onmouseout="this.style.transform='scale(1)'; this.style.boxShadow='none'; this.style.textShadow='none';">
                         Add to Playlist
                    </button>
                </div>
            `).join('');
            
            resultsContainer.innerHTML = `
                <div style="margin-bottom: 10px; padding: 10px; background: #000000; border-radius: 4px;">
                    <div style="display: flex; justify-content: space-between; align-items: center;">
                        <span style="color: #28a745; font-weight: bold;">Found ${videos.length} videos</span>
                        <div style="display: flex; gap: 8px;">
                            <button onclick="addAllVideosToCurrentPlaylist()" style="background: #000000; color: #28a745; border: 2px solid #28a745; border-radius: 4px; padding: 6px 12px; cursor: pointer; font-size: 12px; font-weight: bold; transition: all 0.3s ease;" onmouseover="this.style.transform='scale(1.05)'; this.style.boxShadow='0 0 15px #28a745'; this.style.textShadow='0 0 8px #28a745';" onmouseout="this.style.transform='scale(1)'; this.style.boxShadow='none'; this.style.textShadow='none';">
                                 Add All Videos
                            </button>
                            <button onclick="addSelectedVideosToCurrentPlaylist()" style="background: #000000; color: #28a745; border: 2px solid #28a745; border-radius: 4px; padding: 6px 12px; cursor: pointer; font-size: 12px; font-weight: bold; transition: all 0.3s ease;" onmouseover="this.style.transform='scale(1.05)'; this.style.boxShadow='0 0 15px #28a745'; this.style.textShadow='0 0 8px #28a745';" onmouseout="this.style.transform='scale(1)'; this.style.boxShadow='none'; this.style.textShadow='none';">
                                 Add Selected Videos
                            </button>
                        </div>
                    </div>
                </div>
                ${videosHTML}
            `;
        }

        // Load playlist content from file
        async function loadPlaylistContent(playlistFilename) {
            try {
                const response = await fetch('/api/load_playlist_content', {
                    method: 'POST',
                    headers: {
                        'Content-Type': 'application/json',
                        ...window.authHeaders
                    },
                    body: JSON.stringify({
                        filename: playlistFilename
                    })
                });
                
                if (response.ok) {
                    const data = await response.json();
                    console.log('Loaded playlist content:', data);
                    return data;
                } else {
                    throw new Error('Failed to load playlist content');
                }
            } catch (error) {
                console.error('Error loading playlist content:', error);
                throw error;
            }
        }

        // Get video size from the video library (allVideos array)
        function getVideoSizeFromLibrary(videoName, videoPath) {
            if (typeof allVideos !== 'undefined' && allVideos && allVideos.length > 0) {
                const videoInLibrary = allVideos.find(v => 
                    v.name === videoName || 
                    v.name === videoPath || 
                    v.path === videoName || 
                    v.path === videoPath ||
                    v.filename === videoName
                );
                return videoInLibrary?.size || null;
            }
            return null;
        }

        // Generate editable playlist HTML
        function generateEditablePlaylistHTML(videos) {
            if (!videos || videos.length === 0) {
                return `
                    <div style="text-align: center; color: #888; padding: 40px; font-size: 14px;">
                        <div style="font-size: 48px; margin-bottom: 10px;"></div>
                        <div>This playlist is empty</div>
                        <div style="font-size: 12px; margin-top: 10px;">Use "Add Videos" button to add videos to this playlist</div>
                    </div>
                `;
            }
            
            return videos.map((video, index) => `
                <div class="editable-video-item" draggable="true" data-video-index="${index}" data-video-name="${video.name}" data-video-path="${video.path || video.name}" style="display: flex; align-items: center; padding: 12px; border-bottom: 1px solid #333; background: rgba(0,0,0,0.2); margin-bottom: 2px; border-radius: 4px; transition: all 0.3s ease; cursor: move;">
                    <!-- Drag Handle -->
                    <div class="drag-handle" style="cursor: grab; padding: 5px 8px; margin-right: 10px; color: #ffd700; font-size: 16px; opacity: 0.7;" title="Drag to reorder"></div>
                    
                    <!-- Video Thumbnail -->
                    <div class="video-thumbnail-container" id="thumbnail-edit-${index}" style="margin-right: 10px;" 
                         onmouseenter="handleThumbnailHover('${video.name}', '${(video.path && video.path.startsWith('/')) ? video.path : '/home/gus/video-system/videos/' + video.name}', 'thumbnail-edit-${index}')"
                         onmouseleave="handleThumbnailLeave('thumbnail-edit-${index}')"
                         onclick="handleThumbnailHover('${video.name}', '${(video.path && video.path.startsWith('/')) ? video.path : '/home/gus/video-system/videos/' + video.name}', 'thumbnail-edit-${index}')">
                        <div class="video-thumbnail-placeholder"></div>
                        <div class="video-thumbnail-loading" style="display: none;">Loading...</div>
                        <video class="video-thumbnail" muted></video>
                    </div>
                    
                    <!-- Video Index -->
                    <div style="color: #ffd700; font-weight: bold; font-size: 14px; min-width: 35px; margin-right: 10px;">${index + 1}.</div>
                    
                    <!-- Video Name -->
                    <div style="flex: 1; color: #e0e0e0; font-size: 16px; word-break: break-all; line-height: 1.3; cursor: pointer;"
                         onmouseenter="handleThumbnailHover('${video.name}', '${(video.path && video.path.startsWith('/')) ? video.path : '/home/gus/video-system/videos/' + video.name}', 'thumbnail-edit-${index}')"
                         onmouseleave="handleThumbnailLeave('thumbnail-edit-${index}')"
                         onclick="handleThumbnailHover('${video.name}', '${(video.path && video.path.startsWith('/')) ? video.path : '/home/gus/video-system/videos/' + video.name}', 'thumbnail-edit-${index}')">
                        <div>${video.name}</div>
                        <div style="color: #888; font-size: 13px; margin-top: 2px;">${video.size || getVideoSizeFromLibrary(video.name, video.path) || 'Unknown size'}</div>
                        ${video.path && video.path !== video.name ? `<div style="color: #666; font-size: 12px; margin-top: 1px;">${video.path}</div>` : ''}
                    </div>
                    
                    <!-- Remove Button -->
                    <button onclick="removeVideoFromPlaylist(${index})" title="Remove from playlist" style="background: #000000; color: #dc3545; border: 2px solid #dc3545; border-radius: 4px; padding: 6px 10px; cursor: pointer; font-size: 12px; margin-left: 10px; transition: all 0.3s ease;">
                         Remove
                    </button>
                </div>
            `).join('');
        }

        // Add single video to playlist
        async function addSingleVideoToPlaylist(videoName, videoPath, showErrorModal = true) {
            console.log('Adding single video to playlist (queued):', videoName, videoPath);
            
            const container = document.getElementById('editablePlaylistContent');
            const playlistName = container.dataset.playlistName;
            const playlistFilename = container.dataset.playlistFilename;
            
            // Clean the video name and path - remove any HTML elements or extra content
            const cleanVideoName = videoName.replace(//g, '').replace(/^\s+|\s+$/g, '').trim();
            const cleanVideoPath = videoPath ? videoPath.replace(//g, '').replace(/^\s+|\s+$/g, '').trim() : cleanVideoName;
            
            // Ensure we have a valid path
            let finalVideoPath = cleanVideoPath;
            if (!finalVideoPath.startsWith('/')) {
                finalVideoPath = cleanVideoName;
            }
            
            console.log('Cleaned video data:', { name: cleanVideoName, path: finalVideoPath });
            
            // Add to action queue instead of persisting immediately
            addToActionQueue({
                type: 'add_individual_video',
                playlistFilename: playlistFilename,
                playlistName: playlistName,
                video: {
                    name: finalVideoPath,
                    path: finalVideoPath
                },
                description: `Add video: ${finalVideoPath.split('/').pop()}`
            });
            
            return { success: true, message: 'Video added to queue successfully' };
        }

        // Add all visible videos to current playlist
        async function addAllVideosToCurrentPlaylist() {
            const container = document.getElementById('editablePlaylistContent');
            const playlistName = container.dataset.playlistName;
            const playlistFilename = container.dataset.playlistFilename;
            
            console.log('Adding all VISIBLE/FILTERED videos to current playlist (queued):', playlistName);
            
            // Use currently filtered videos (what's actually displayed)
            const videosToAdd = currentFilteredVideos || [];
            
            if (videosToAdd.length === 0) {
                console.log('No videos to add - either no videos loaded or search returned no results');
                return;
            }
            
            const searchTerm = document.getElementById('playlistVideoSearchInput').value.trim().toLowerCase();
            console.log(`Adding ${videosToAdd.length} videos to playlist (${searchTerm ? 'filtered' : 'all visible'} videos)`);
            
            // Add to action queue without executing immediately  
            addToActionQueue({
                type: 'add_selected_videos',  // Use add_selected_videos instead of add_all_videos
                playlistFilename: playlistFilename,
                playlistName: playlistName,
                videos: videosToAdd,
                description: `Add ${videosToAdd.length} ${searchTerm ? 'filtered' : 'visible'} videos to playlist`
            });
            
            // Keep the interface open so user can continue adding videos
            // Don't close the modal - let user see the action was queued
            
            // Don't show modal - just provide console feedback and return to edit interface
            console.log('Add all videos action queued successfully');
            
            // Ensure we stay in the playlist edit interface by not showing any modals
            // The user will see the visual feedback from the counter and save button
        }

        // Add selected videos to current playlist
        async function addSelectedVideosToCurrentPlaylist() {
            const checkboxes = document.querySelectorAll('#playlistVideoResults input[type="checkbox"]:checked');
            console.log('Found checked checkboxes:', checkboxes.length);
            
            // Debug: also check all checkboxes
            const allCheckboxes = document.querySelectorAll('#playlistVideoResults input[type="checkbox"]');
            console.log('Total checkboxes available:', allCheckboxes.length);
            
            if (checkboxes.length === 0) {
                showPlaylistErrorModal('No Videos Selected', 'Please select one or more videos by checking their checkboxes before adding to the playlist.');
                return;
            }
            
            const container = document.getElementById('editablePlaylistContent');
            const playlistName = container.dataset.playlistName;
            const playlistFilename = container.dataset.playlistFilename;
            
            // Collect selected videos
            const selectedVideos = [];
            
            checkboxes.forEach(checkbox => {
                const videoContainer = checkbox.closest('div');
                
                // Extract video name and path more carefully (account for thumbnail container)
                const videoInfo = videoContainer.querySelector('div:nth-child(3)');
                if (videoInfo) {
                    const nameElement = videoInfo.querySelector('div:first-child');
                    const pathElement = videoInfo.querySelector('div:nth-child(2)');
                    
                    let videoName = nameElement ? nameElement.textContent.trim() : '';
                    let videoPath = pathElement ? pathElement.textContent.trim() : videoName;
                    
                    // Clean up the name and path to remove any HTML artifacts
                    videoName = videoName.replace(//g, '').replace(/^\s+|\s+$/g, '').trim();
                    videoPath = videoPath.replace(//g, '').replace(/^\s+|\s+$/g, '').trim();
                    
                    if (videoPath.startsWith('/') && videoPath.includes('.mp4')) {
                        // Extract just the filename from the full path
                        const fileName = videoPath.split('/').pop();
                        selectedVideos.push({
                            name: fileName,
                            path: videoPath
                        });
                    } else if (videoName) {
                        selectedVideos.push({
                            name: videoName,
                            path: videoName
                        });
                    }
                }
            });
            
            if (selectedVideos.length === 0) {
                showPlaylistErrorModal('No Valid Videos', 'No valid videos were found in the selection. Please try again.');
                return;
            }
            
            // Add to action queue without executing immediately
            addToActionQueue({
                type: 'add_selected_videos',
                playlistFilename: playlistFilename,
                playlistName: playlistName,
                videos: selectedVideos,
                description: `Add ${selectedVideos.length} selected videos to playlist`
            });
            
            // Clear selections
            checkboxes.forEach(cb => cb.checked = false);
            
            // Keep the interface open so user can continue selecting and adding videos
            // Don't close the modal - let user see the action was queued
            
            // Don't show modal - just provide console feedback and return to edit interface
            console.log(`${selectedVideos.length} selected videos queued successfully`);
            
            // Ensure we stay in the playlist edit interface by not showing any modals
            // The user will see the visual feedback from the counter and save button
        }

        // Action queue system for playlist modifications
        let playlistActionQueue = [];
        let unsavedChangesCount = 0;
        let actionCounter = 0;
        
        // Initialize action queue system
        function initializeActionQueue() {
            playlistActionQueue = [];
            unsavedChangesCount = 0;
            updateSaveButtonState();
            updateUnsavedCounter();
        }
        
        // Add action to queue
        function addToActionQueue(action) {
            playlistActionQueue.push({
                id: Date.now() + Math.random(),
                timestamp: new Date().toISOString(),
                action: action
            });
            unsavedChangesCount++;
            updateSaveButtonState();
            updateUnsavedCounter();
            flashSaveButton();
        }
        
        // Update save button visual state
        function updateSaveButtonState() {
            const saveButton = document.querySelector('button[onclick="savePlaylistChanges()"]');
            if (!saveButton) return;
            
            if (unsavedChangesCount === 0) {
                // No changes - green
                saveButton.style.background = '#000000';
                saveButton.style.color = '#28a745';
                saveButton.style.border = '2px solid #28a745';
                saveButton.textContent = ' Save Changes';
            } else {
                // Unsaved changes - yellow
                saveButton.style.background = '#000000';
                saveButton.style.color = '#ffd700';
                saveButton.style.border = '2px solid #ffd700';
                saveButton.textContent = ' Save Changes';
            }
        }
        
        // Flash save button when new action is added
        function flashSaveButton() {
            const saveButton = document.querySelector('button[onclick="savePlaylistChanges()"]');
            if (!saveButton || unsavedChangesCount <= 1) return;
            
            // Flash orange for 3 seconds
            let flashCount = 0;
            const flashInterval = setInterval(() => {
                if (flashCount < 6) { // 3 seconds at 500ms intervals
                    const isOrange = flashCount % 2 === 0;
                    if (isOrange) {
                        saveButton.style.background = '#000000';
                        saveButton.style.color = '#ff8c00';
                        saveButton.style.border = '2px solid #ff8c00';
                        saveButton.style.transform = 'scale(1.1)';
                    } else {
                        saveButton.style.background = '#000000';
                        saveButton.style.color = '#ffd700';
                        saveButton.style.border = '2px solid #ffd700';
                        saveButton.style.transform = 'scale(1.0)';
                    }
                    flashCount++;
                } else {
                    // Return to yellow state
                    saveButton.style.background = '#000000';
                    saveButton.style.color = '#ffd700';
                    saveButton.style.border = '2px solid #ffd700';
                    saveButton.style.transform = 'scale(1.0)';
                    clearInterval(flashInterval);
                }
            }, 500);
        }
        
        // Update unsaved changes counter
        function updateUnsavedCounter() {
            let counterElement = document.getElementById('unsavedCounter');
            
            if (!counterElement) {
                // Create counter element TO THE RIGHT of the save button
                const saveButton = document.querySelector('button[onclick="savePlaylistChanges()"]');
                if (saveButton) {
                    counterElement = document.createElement('div');
                    counterElement.id = 'unsavedCounter';
                    counterElement.style.cssText = `
                        display: inline-flex;
                        align-items: center;
                        margin-left: 15px;
                        padding: 4px 8px;
                        font-size: 12px;
                        font-weight: bold;
                        transition: all 0.3s ease;
                        border: none;
                        background: none;
                    `;
                    // Insert AFTER the save button, not before
                    saveButton.parentNode.insertBefore(counterElement, saveButton.nextSibling);
                }
            }
            
            if (counterElement) {
                if (unsavedChangesCount === 0) {
                    counterElement.innerHTML = ' No unsaved changes';
                    counterElement.style.background = 'none';
                    counterElement.style.color = '#28a745';
                    counterElement.style.border = 'none';
                    counterElement.style.animation = 'none';
                } else {
                    const lastAction = playlistActionQueue.length > 0 ? 
                        playlistActionQueue[playlistActionQueue.length - 1] : null;
                    const actionDesc = lastAction ? ` - ${lastAction.description}` : '';
                    counterElement.innerHTML = ` ${unsavedChangesCount} unsaved action${unsavedChangesCount !== 1 ? 's' : ''}${actionDesc}`;
                    counterElement.style.background = 'none';
                    counterElement.style.color = '#ffd700';
                    counterElement.style.border = 'none';
                    counterElement.style.animation = 'flash 1s infinite';
                }
            }
        }
        
        // Add flashing animation CSS
        const flashStyle = document.createElement('style');
        flashStyle.textContent = `
            @keyframes flash {
                0%, 100% { opacity: 1; }
                50% { opacity: 0.3; }
            }
        `;
        document.head.appendChild(flashStyle);
        
        // Remove video from playlist (remove ONLY the specific instance)
        function removeVideoFromPlaylist(index) {
            console.log('Removing video at index:', index);
            
            const container = document.getElementById('editablePlaylistContent');
            const videoItems = container.querySelectorAll('.editable-video-item');
            
            if (index >= 0 && index < videoItems.length) {
                const targetItem = videoItems[index];
                const videoPath = targetItem.dataset.videoPath || targetItem.dataset.videoName;
                
                if (!videoPath) {
                    console.error('Could not find video path for removal');
                    return;
                }
                
                console.log('Removing single video instance at index:', index, 'video:', videoPath);
                
                // Mark only this specific instance for visual removal
                targetItem.style.background = 'rgba(220, 53, 69, 0.3)';
                targetItem.style.opacity = '0.5';
                targetItem.style.textDecoration = 'line-through';
                
                // Add "PENDING REMOVAL" indicator
                const pendingIndicator = document.createElement('div');
                pendingIndicator.style.cssText = `
                    color: #dc3545;
                    font-size: 11px;
                    font-weight: bold;
                    margin-left: 10px;
                    background: rgba(220, 53, 69, 0.2);
                    padding: 2px 6px;
                    border-radius: 3px;
                    border: 1px solid #dc3545;
                `;
                pendingIndicator.textContent = 'PENDING REMOVAL';
                
                // Remove existing remove button and add pending indicator
                const existingButton = targetItem.querySelector('button');
                if (existingButton) {
                    existingButton.style.display = 'none';
                }
                targetItem.appendChild(pendingIndicator);
                
                // Add to action queue with specific index
                addToActionQueue({
                    type: 'remove_video_by_index',
                    videoIndex: index,
                    videoPath: videoPath,
                    description: `Remove video at position ${index + 1}: ${videoPath.split('/').pop()}`
                });
                
                // Update the playlist count to show pending removal
                const countElement = container.parentElement.querySelector('h3');
                if (countElement) {
                    const pendingRemovals = container.querySelectorAll('.editable-video-item').length - container.querySelectorAll('[style*="line-through"]').length;
                    const pendingCount = container.querySelectorAll('[style*="line-through"]').length;
                    if (pendingCount > 0) {
                        countElement.innerHTML = ` Videos in Playlist (${videoItems.length - pendingCount}) - ${pendingCount} pending removal`;
                    }
                }
                
                console.log(`Marked video at index ${index} for removal`);
            }
        }

        // Refresh playlist metadata
        async function refreshPlaylistMetadata() {
            console.log('Refreshing playlist metadata');
            
            const container = document.getElementById('editablePlaylistContent');
            const viewerContainer = document.getElementById('playlistVideosList');
            
            console.log('Refresh debug - container:', container, 'viewerContainer:', viewerContainer);
            
            if (container) {
                // Edit playlist modal
                const playlistFilename = container.dataset.playlistFilename;
                
                // Show loading
                container.innerHTML = '<div style="text-align: center; color: #888; padding: 40px;"> Refreshing playlist...</div>';
                
                try {
                    // Reload the playlist content
                    const playlistData = await loadPlaylistContent(playlistFilename);
                    
                    // Update the UI
                    container.innerHTML = generateEditablePlaylistHTML(playlistData.videos);
                    
                    // Update count
                    const countElement = container.parentElement.querySelector('h3');
                    if (countElement) {
                        countElement.innerHTML = ` Videos in Playlist (${playlistData.videos.length})`;
                    }
                    
                    // Re-initialize drag and drop
                    initializePlaylistDragAndDrop();
                    
                    // Reset save button
                    const saveButton = document.querySelector('button[onclick="savePlaylistChanges()"]');
                    if (saveButton) {
                        saveButton.style.background = '#ffd700';
                        saveButton.textContent = ' Save Changes';
                    }
                    
                } catch (error) {
                    console.error('Error refreshing playlist:', error);
                    container.innerHTML = '<div style="text-align: center; color: #dc3545; padding: 40px;">Error refreshing playlist</div>';
                }
            } else if (viewerContainer) {
                console.log('In playlist viewer modal branch');
                // Playlist viewer modal - get playlist name from modal title in the same modal as the viewer container
                const playlistModal = viewerContainer.closest('.modal');
                const modalTitle = playlistModal ? playlistModal.querySelector('h2') : null;
                console.log('Modal title found:', modalTitle);
                console.log('Modal title text:', modalTitle ? modalTitle.textContent : 'null');
                if (modalTitle && modalTitle.textContent.includes('Videos from playlist:')) {
                    const playlistName = modalTitle.textContent.replace(' Videos from playlist: ', '').trim();
                    console.log('Extracted playlist name:', playlistName);
                    
                    // Show loading
                    viewerContainer.innerHTML = '<div style="text-align: center; color: #fd7e14; padding: 40px;"><div style="font-size: 48px; margin-bottom: 15px;"></div><div>Refreshing playlist...</div></div>';
                    
                    console.log('About to make API call with playlist name:', playlistName);
                    
                    try {
                        // Reload playlist content
                        console.log('Making API call to /api/open_playlist_content');
                        
                        // Add timeout to prevent hanging
                        const controller = new AbortController();
                        const timeoutId = setTimeout(() => controller.abort(), 10000); // 10 second timeout
                        
                        const response = await fetch('/api/open_playlist_content', {
                            method: 'POST',
                            headers: {
                                'Content-Type': 'application/json',
                                ...window.authHeaders
                            },
                            body: JSON.stringify({
                                playlist_name: playlistName
                            }),
                            signal: controller.signal
                        });
                        
                        clearTimeout(timeoutId);
                        console.log('API response received:', response.status, response.ok);
                        
                        if (response.ok) {
                            const contentData = await response.json();
                            console.log('API response data:', contentData);
                            if (contentData.success !== false && contentData.videos) {
                                // Refresh the playlist display
                                displayPlaylistContent(contentData, playlistModal);
                                console.log('Playlist content refreshed successfully');
                            } else {
                                console.log('API returned success=false or no videos:', contentData.message);
                                viewerContainer.innerHTML = '<div style="text-align: center; color: #dc3545; padding: 40px;">Error: ' + (contentData.message || 'No playlist data') + '</div>';
                            }
                        } else {
                            console.log('API response not OK:', response.status);
                            viewerContainer.innerHTML = '<div style="text-align: center; color: #dc3545; padding: 40px;">API Error: ' + response.status + '</div>';
                        }
                        
                    } catch (error) {
                        console.error('Error refreshing playlist viewer:', error);
                        viewerContainer.innerHTML = '<div style="text-align: center; color: #dc3545; padding: 40px;">Error refreshing playlist</div>';
                    }
                }
            }
        }

        // Save playlist changes - Process action queue and execute all pending actions
        async function savePlaylistChanges() {
            console.log('Processing playlist action queue and saving changes...');
            console.log('Current action queue:', playlistActionQueue);
            
            const container = document.getElementById('editablePlaylistContent');
            const playlistName = container.dataset.playlistName;
            const playlistFilename = container.dataset.playlistFilename;
            
            // Show saving state
            const saveButton = document.querySelector('button[onclick="savePlaylistChanges()"]');
            const originalText = saveButton.textContent;
            saveButton.textContent = ' Saving...';
            saveButton.style.background = '#000000'; // Black background
            saveButton.style.color = '#ffc107'; // Yellow text
            saveButton.disabled = true;
            
            let errors = [];
            
            try {
                // Process each action in the queue sequentially
                for (const queueItem of playlistActionQueue) {
                    const action = queueItem.action;
                    
                    try {
                        switch (action.type) {
                            case 'add_all_videos':
                                await processAddAllVideos(action, playlistName);
                                break;
                                
                            case 'add_selected_videos':
                                await processAddSelectedVideos(action, playlistName);
                                break;
                                
                            case 'add_individual_video':
                                await processAddIndividualVideo(action, playlistName);
                                break;
                                
                            case 'remove_video':
                                await processRemoveVideo(action);
                                break;
                                
                            case 'remove_video_by_index':
                                await processRemoveVideoByIndex(action);
                                break;
                                
                            case 'remove_all_videos':
                                await processRemoveAllVideos(action);
                                break;
                                
                            case 'reorder_video':
                                await processReorderVideo(action);
                                break;
                                
                            default:
                                console.warn('Unknown action type:', action.type);
                                break;
                        }
                        
                        console.log(`Completed action: ${action.type}`);
                        
                    } catch (actionError) {
                        console.error(`Error processing action ${action.type}:`, actionError);
                        errors.push(`${action.type}: ${actionError.message}`);
                    }
                }
                
                console.log('All actions processed successfully - now getting final video order from current DOM state');
                
                // Don't refresh content - use current DOM state which reflects all our changes
                console.log('Using current DOM state for final video order (no refresh needed)');
                
                // Get final video order from current DOM state  
                const videoItems = container.querySelectorAll('.editable-video-item');
                const videos = Array.from(videoItems).map(item => {
                    const rawName = item.dataset.videoName || item.textContent.trim();
                    const rawPath = item.dataset.videoPath || item.dataset.videoName || item.textContent.trim();
                    // Ensure name is just the filename, not a path
                    const actualName = rawName.includes('/') ? rawName.split('/').pop() : rawName;
                    return {
                        name: actualName,
                        path: rawPath
                    };
                }).filter(video => video.name && video.path);
                
                console.log('Final videos list after refresh:', videos, 'DOM elements found:', videoItems.length);
                
                // Only save final order if we have videos
                if (videos.length > 0) {
                    const response = await fetch('/api/save_playlist_order', {
                        method: 'POST',
                        headers: {
                            'Content-Type': 'application/json',
                            ...window.authHeaders
                        },
                        body: JSON.stringify({
                            filename: playlistFilename,
                            playlist_name: playlistName,
                            videos: videos
                        })
                    });
                    
                    if (!response.ok) {
                        throw new Error('Failed to save final playlist order');
                    }
                    console.log('Final playlist order saved successfully');
                } else {
                    console.log('No videos in final state - skipping save_playlist_order call');
                }
                
                // NOW reset counters since changes are successfully persisted
                playlistActionQueue.length = 0;  // Clear array
                playlistActionQueue = [];        // Reset reference
                unsavedChangesCount = 0;         // Reset counter
                actionCounter = 0;               // Reset action counter
                
                console.log('COUNTERS RESET AFTER SUCCESSFUL SAVE - queue:', playlistActionQueue.length, 'unsaved:', unsavedChangesCount);
                
                // Update button to show success state
                saveButton.style.background = '#000000';
                saveButton.style.color = '#28a745';
                saveButton.style.border = '2px solid #28a745';
                saveButton.innerHTML = ' Changes Saved';
                saveButton.disabled = false;
                
                // Force counter to show no unsaved changes
                const counterElement = document.getElementById('unsavedCounter');
                if (counterElement) {
                    counterElement.innerHTML = ' No unsaved changes';
                    counterElement.style.background = 'none';
                    counterElement.style.color = '#28a745';
                    counterElement.style.border = 'none';
                    counterElement.style.animation = 'none';
                    counterElement.style.display = 'inline-block';
                }
                
                // Hide undo button since no actions pending
                const undoButton = document.getElementById('undoLastChangeBtn');
                if (undoButton) {
                    undoButton.style.display = 'none';
                }
                
                console.log('UI UPDATED AFTER SUCCESS - queue:', playlistActionQueue.length, 'unsaved:', unsavedChangesCount);
                
                // After 3 seconds, set to ready state for new actions
                setTimeout(() => {
                    // Ensure counters stay at 0
                    console.log('Final check - queue:', playlistActionQueue.length, 'unsaved:', unsavedChangesCount);
                    
                    // Set button to ready for new changes
                    saveButton.style.background = '#000000';
                    saveButton.style.color = '#28a745';
                    saveButton.style.border = '2px solid #28a745';
                    saveButton.innerHTML = ' Save Changes';
                    saveButton.disabled = false;
                }, 2000);
                
            } catch (error) {
                console.error('Error processing action queue:', error);
                
                // Even on error, show yellow "Saving..." state for 3 seconds
                setTimeout(() => {
                    saveButton.textContent = originalText;
                    saveButton.style.background = '#ff6b35';
                    saveButton.disabled = false;
                }, 3000);
            }
        }
        
        // Process add_all_videos action
        async function processAddAllVideos(action, playlistName) {
            console.log('Processing add_all_videos action:', action);
            
            // Call API to add all videos to playlist
            const response = await fetch('/api/add_all_videos_to_playlist', {
                method: 'POST',
                headers: {
                    ...window.authHeaders,
                    'Content-Type': 'application/json'
                },
                body: JSON.stringify({
                    playlist_name: action.playlistName,
                    playlist_filename: action.playlistFilename
                })
            });
            
            if (!response.ok) {
                throw new Error('Failed to add all videos to playlist');
            }
            
            // Refresh playlist content to show newly added videos
            await refreshPlaylistContent();
        }
        
        // Process add_selected_videos action
        async function processAddSelectedVideos(action, playlistName) {
            console.log('Processing add_selected_videos action:', action);
            
            if (!action.videos || !Array.isArray(action.videos)) {
                throw new Error('No videos specified for add_selected_videos action');
            }
            
            // Call API to add selected videos to playlist
            const response = await fetch('/api/add_videos_to_playlist', {
                method: 'POST',
                headers: {
                    ...window.authHeaders,
                    'Content-Type': 'application/json'
                },
                body: JSON.stringify({
                    playlist_name: action.playlistName,
                    videos: action.videos,
                    type: 'selected'
                })
            });
            
            if (!response.ok) {
                throw new Error('Failed to add selected videos to playlist');
            }
            
            // Refresh playlist content to show newly added videos
            await refreshPlaylistContent();
        }
        
        // Process add_individual_video action
        async function processAddIndividualVideo(action, playlistName) {
            console.log('Processing add_individual_video action:', action);
            
            if (!action.video) {
                throw new Error('No video specified for add_individual_video action');
            }
            
            // Call API to add individual video to playlist
            const response = await fetch('/api/add_single_video_to_playlist', {
                method: 'POST',
                headers: {
                    ...window.authHeaders,
                    'Content-Type': 'application/json'
                },
                body: JSON.stringify({
                    playlist_filename: action.playlistFilename,
                    playlist_name: action.playlistName,
                    video: action.video
                })
            });
            
            if (!response.ok) {
                throw new Error('Failed to add individual video to playlist');
            }
            
            // Refresh playlist content to show newly added video
            await refreshPlaylistContent();
        }
        
        // Process remove_video action
        async function processRemoveVideo(action) {
            console.log('Processing remove_video action:', action);
            
            const container = document.getElementById('editablePlaylistContent');
            const videoItems = Array.from(container.querySelectorAll('.editable-video-item'));
            
            // Remove all instances of this video path
            const itemsToRemove = videoItems.filter(item => 
                (item.dataset.videoPath || item.dataset.videoName) === action.videoPath
            );
            
            itemsToRemove.forEach(item => item.remove());
            
            // Update video indices
            updateVideoIndices();
        }
        
        // Process remove_video_by_index action (remove only specific instance)
        async function processRemoveVideoByIndex(action) {
            console.log('Processing remove_video_by_index action:', action);
            
            const container = document.getElementById('editablePlaylistContent');
            const videoItems = Array.from(container.querySelectorAll('.editable-video-item'));
            
            // Remove only the specific video at the given index
            if (action.videoIndex >= 0 && action.videoIndex < videoItems.length) {
                const itemToRemove = videoItems[action.videoIndex];
                itemToRemove.remove();
                console.log(`Removed video at index ${action.videoIndex}`);
            } else {
                console.error(`Invalid video index: ${action.videoIndex}, available indices: 0-${videoItems.length - 1}`);
            }
            
            // Update video indices
            updateVideoIndices();
        }
        
        // Process remove_all_videos action
        async function processRemoveAllVideos(action) {
            console.log('Processing remove_all_videos action:', action);
            
            try {
                const response = await fetch('/api/remove_all_videos_from_playlist', {
                    method: 'POST',
                    headers: {
                        'Content-Type': 'application/json',
                        ...window.authHeaders
                    },
                    body: JSON.stringify({
                        playlist_filename: action.playlistFilename,
                        playlist_name: action.playlistName
                    })
                });

                if (response.ok) {
                    console.log('Successfully removed all videos from playlist');
                    // Update UI to show empty playlist
                    const container = document.getElementById('editablePlaylistContent');
                    container.innerHTML = '<div style="text-align: center; color: #888; padding: 40px;">No videos in playlist</div>';
                    
                    // Update playlist count
                    const countElement = container.parentElement.querySelector('h3');
                    if (countElement) {
                        countElement.innerHTML = ' Videos in Playlist (0)';
                    }
                } else {
                    console.error('Failed to remove all videos from playlist');
                    throw new Error(`Server responded with ${response.status}`);
                }
            } catch (error) {
                console.error('Error removing all videos from playlist:', error);
                throw error;
            }
        }
        
        // Process reorder_video action
        async function processReorderVideo(action) {
            console.log('Processing reorder_video action:', action);
            
            // The reorder action is processed by updating the final video order
            // when all actions are complete. This function serves as a placeholder
            // to acknowledge the reorder action was processed.
            
            // Note: The actual reordering logic happens in the final save step
            // where the current DOM order is preserved to the playlist file.
        }
        
        // Update video indices after removal
        function updateVideoIndices() {
            const container = document.getElementById('editablePlaylistContent');
            const videoItems = container.querySelectorAll('.editable-video-item');
            
            videoItems.forEach((item, index) => {
                item.dataset.videoIndex = index;
                const indexElement = item.querySelector('div:nth-child(2)');
                if (indexElement) {
                    indexElement.textContent = `${index + 1}.`;
                }
                const removeButton = item.querySelector('button[onclick*="removeVideoFromPlaylist"]');
                if (removeButton) {
                    removeButton.setAttribute('onclick', `removeVideoFromPlaylist(${index})`);
                }
            });
        }
        
        // Refresh playlist content after save
        async function refreshPlaylistContent() {
            try {
                const container = document.getElementById('editablePlaylistContent');
                const playlistName = container.dataset.playlistName;
                const playlistFilename = container.dataset.playlistFilename;
                
                const response = await fetch('/api/load_playlist_content', {
                    method: 'POST',
                    headers: {
                        'Content-Type': 'application/json',
                        ...window.authHeaders
                    },
                    body: JSON.stringify({
                        filename: playlistFilename,
                        playlist_name: playlistName
                    })
                });
                
                if (response.ok) {
                    const playlistData = await response.json();
                    container.innerHTML = generateEditablePlaylistHTML(playlistData.videos);
                    
                    // Update playlist count
                    const countElement = container.parentElement.querySelector('h3');
                    if (countElement) {
                        countElement.innerHTML = ` Videos in Playlist (${playlistData.videos.length})`;
                    }
                    
                    // Re-initialize drag and drop
                    initializePlaylistDragAndDrop();
                } else {
                    console.error('Failed to refresh playlist content');
                }
            } catch (error) {
                console.error('Error refreshing playlist content:', error);
            }
        }

        // Specialized modal for playlist actions
        function showPlaylistActionModal(title, message, playlistName) {
            return new Promise((resolve) => {
                const modal = document.getElementById('confirmationModal');
                const titleElement = document.getElementById('confirmationTitle');
                const messageElement = document.getElementById('confirmationMessage');
                const fileListElement = document.getElementById('confirmationFileList');
                const cancelBtn = document.getElementById('confirmationCancelBtn');
                const deleteBtn = document.getElementById('confirmationDeleteBtn');

                // Set modal content
                titleElement.textContent = title;
                
                // Highlight playlist name in yellow if provided
                if (playlistName) {
                    const highlightedMessage = message.replace(
                        `"${playlistName}"`, 
                        `<span style="background: rgba(255, 215, 0, 0.2); color: #ffd700; padding: 2px 6px; border-radius: 4px; border: 1px solid #ffd700; font-weight: bold;">${playlistName}</span>`
                    );
                    messageElement.innerHTML = highlightedMessage;
                } else {
                    messageElement.textContent = message;
                }
                fileListElement.innerHTML = '';
                fileListElement.style.display = 'none'; // Hide file list completely

                // Hide warning text for playlist actions
                const warningText = modal.querySelector('.warning-text');
                if (warningText) {
                    warningText.style.display = 'none';
                }

                // Update buttons - only show OK button
                cancelBtn.style.display = 'none';
                deleteBtn.textContent = 'OK';
                deleteBtn.className = 'modal-btn modal-btn-ok';
                deleteBtn.style.background = '#10b981';

                // Make modal smaller and centered
                const modalContent = modal.querySelector('.confirmation-modal-content');
                modalContent.style.width = '400px';
                modalContent.style.maxWidth = '90vw';

                // Show modal
                modal.style.display = 'flex';

                // Handle button clicks
                const handleOK = () => {
                    modal.style.display = 'none';
                    cleanup();
                    resolve(true);
                };

                const cleanup = () => {
                    deleteBtn.removeEventListener('click', handleOK);
                    // Reset modal styles
                    modalContent.style.width = '';
                    modalContent.style.maxWidth = '';
                    deleteBtn.textContent = 'Delete';
                    deleteBtn.className = 'modal-btn modal-btn-delete';
                    deleteBtn.style.background = '';
                    cancelBtn.style.display = '';
                    fileListElement.style.display = '';
                    if (warningText) {
                        warningText.style.display = '';
                    }
                };

                deleteBtn.addEventListener('click', handleOK);
            });
        }

        // Remove all videos from playlist
        async function removeAllVideosFromPlaylist() {
            const container = document.getElementById('editablePlaylistContent');
            const playlistName = container.dataset.playlistName;
            const playlistFilename = container.dataset.playlistFilename;
            
            // Confirm action using specialized playlist modal
            const confirmed = await showPlaylistActionModal(
                'Remove All Videos',
                `To permanently remove all videos from playlist "${playlistName}", click the Save button to persist the changes.`,
                playlistName
            );
            
            // Since the specialized modal always returns true (OK button), 
            // we proceed with the action immediately
            
            console.log('Queuing removal of all videos from playlist:', playlistName);
            
            // Mark all videos visually for removal
            const videoItems = container.querySelectorAll('.editable-video-item');
            let removedCount = 0;
            
            videoItems.forEach((item, index) => {
                // Mark for visual removal
                item.style.background = 'rgba(220, 53, 69, 0.3)';
                item.style.opacity = '0.5';
                item.style.textDecoration = 'line-through';
                
                // Add "PENDING REMOVAL" indicator
                const pendingIndicator = document.createElement('div');
                pendingIndicator.style.cssText = `
                    color: #dc3545;
                    font-size: 11px;
                    font-weight: bold;
                    margin-left: 10px;
                    background: rgba(220, 53, 69, 0.2);
                    padding: 2px 6px;
                    border-radius: 3px;
                    border: 1px solid #dc3545;
                `;
                pendingIndicator.textContent = 'PENDING REMOVAL';
                
                // Remove existing remove button and add pending indicator
                const existingButton = item.querySelector('button');
                if (existingButton) {
                    existingButton.style.display = 'none';
                }
                item.appendChild(pendingIndicator);
                removedCount++;
            });
            
            // Add to action queue
            addToActionQueue({
                type: 'remove_all_videos',
                playlistFilename: playlistFilename,
                playlistName: playlistName,
                description: `Remove all ${removedCount} videos from playlist`
            });
            
            // Update the playlist count to show pending removal
            const countElement = container.parentElement.querySelector('h3');
            if (countElement) {
                countElement.innerHTML = ` Videos in Playlist (0) - ${removedCount} pending removal`;
            }
            
            console.log(`Marked all ${removedCount} videos for removal`);
        }

        // Close edit modal
        function closeEditModal() {
            const editModal = document.querySelector('.playlist-edit-modal');
            if (editModal) {
                editModal.remove();
            }
            
            // Also close video selection interface if open
            closeVideoSelectionInterface();
        }

        // Delete Playlist functionality
        async function deletePlaylist() {
            console.log('Delete Playlist button clicked');
            console.log('Auth headers available:', !!window.authHeaders);
            console.log('Auth headers content:', window.authHeaders);
            
            try {
                // Get existing playlists with metadata
                const response = await fetch('/api/playlists', {
                    method: 'GET',
                    headers: {
                        'Authorization': window.authHeaders?.Authorization || '',
                        'Content-Type': 'application/json'
                    }
                });
                
                console.log('Response status:', response.status);
                console.log('Response headers:', [...response.headers.entries()]);
                
                if (!response.ok) {
                    throw new Error(`Server responded with ${response.status}`);
                }
                
                const data = await response.json();
                console.log('Playlist list response:', data);
                
                if (!data.success) {
                    throw new Error(data.message || 'Failed to get playlist data');
                }
                
                if (!data.playlists || data.playlists.length === 0) {
                    showPlaylistErrorModal('No Playlists Available', 'No playlists found in the system to delete.');
                    return;
                }
                
                // Show delete modal with playlist data
                showDeletePlaylistModal(data.playlists);
                
            } catch (error) {
                console.error('Error fetching playlists for deletion:', error);
                showPlaylistErrorModal('Error Loading Playlists', `Failed to load playlists for deletion: ${error.message}`);
            }
        }

        // Show delete playlist modal
        function showDeletePlaylistModal(playlists) {
            console.log('Opening delete playlist modal with', playlists.length, 'playlists');
            
            // Remove existing modal if present
            const existingModal = document.querySelector('.playlist-delete-modal');
            if (existingModal) {
                existingModal.remove();
            }
            
            // Create modal
            const modal = document.createElement('div');
            modal.className = 'modal playlist-delete-modal';
            modal.style.display = 'block';
            
            modal.innerHTML = `
                <div class="modal-content playlist-modal-content" style="width: 80% !important; max-width: 900px !important; min-width: 600px !important; margin: 5% auto !important; padding: 0 !important; display: flex; flex-direction: column; background: #000000; border: 2px solid #dc3545;">
                    <div class="modal-header" style="background: #000000; padding: 15px; border: 2px solid #dc3545; border-bottom: 1px solid #dc3545; flex-shrink: 0;">
                        <h2 style="color: #dc3545; font-size: 18px; margin: 0; text-shadow: 0 0 5px #dc3545;"> Manage Playlists</h2>
                        <button class="close" onclick="closeDeletePlaylistModal()" style="color: #dc3545; background: none; border: none; font-size: 20px; cursor: pointer; float: right; text-shadow: 0 0 5px #dc3545;">&times;</button>
                    </div>
                    <div class="modal-body" style="padding: 20px; flex: 1; overflow: hidden; display: flex; flex-direction: column;">
                        
                        <!-- Search Section -->
                        <div style="margin-bottom: 20px; padding: 15px; background: rgba(220,53,69,0.1); border: 1px solid #dc3545; border-radius: 8px;">
                            <div style="display: flex; gap: 10px; align-items: center;">
                                <input type="text" id="deletePlaylistSearchInput" placeholder="Search playlists to manage..." style="flex: 1; padding: 8px; background: #000000; border: 1px solid #dc3545; border-radius: 4px; color: #ffffff; font-size: 14px;" oninput="searchPlaylistsForDeletion()">
                                <button onclick="searchPlaylistsForDeletion()" style="padding: 8px 16px; background: #000000; color: #28a745; border: 2px solid #28a745; border-radius: 4px; cursor: pointer; font-weight: bold; box-shadow: 0 0 10px rgba(40, 167, 69, 0.5); transition: all 0.3s ease;" onmouseover="this.style.transform='scale(1.05)'; this.style.boxShadow='0 0 20px rgba(40, 167, 69, 0.8)'; this.style.textShadow='0 0 10px #28a745';" onmouseout="this.style.transform='scale(1)'; this.style.boxShadow='0 0 10px rgba(40, 167, 69, 0.5)'; this.style.textShadow='none';"> Find</button>
                                <button onclick="showAllPlaylistsForDeletion()" style="padding: 8px 16px; background: #000000; color: #17a2b8; border: 2px solid #17a2b8; border-radius: 4px; cursor: pointer; font-weight: bold; box-shadow: 0 0 10px rgba(23, 162, 184, 0.5); transition: all 0.3s ease;" onmouseover="this.style.transform='scale(1.05)'; this.style.boxShadow='0 0 20px rgba(23, 162, 184, 0.8)'; this.style.textShadow='0 0 10px #17a2b8';" onmouseout="this.style.transform='scale(1)'; this.style.boxShadow='0 0 10px rgba(23, 162, 184, 0.5)'; this.style.textShadow='none';"> Show All</button>
                            </div>
                            <div style="margin-top: 10px; color: #dc3545; font-size: 12px;"> Select playlists to remove from the system. Videos will remain safe.</div>
                        </div>
                        
                        <!-- Selection Controls -->
                        <div style="margin-bottom: 15px; display: flex; gap: 10px; align-items: center;">
                            <button onclick="selectAllPlaylistsForDeletion()" style="padding: 6px 12px; background: #000000; color: #ffd700; border: 2px solid #ffffff; border-radius: 4px; cursor: pointer; font-size: 12px; font-weight: bold; box-shadow: 0 0 10px rgba(255, 255, 255, 0.5); transition: all 0.3s ease;" onmouseover="this.style.transform='scale(1.05)'; this.style.boxShadow='0 0 20px rgba(255, 255, 255, 0.8)'; this.style.textShadow='0 0 10px #ffffff';" onmouseout="this.style.transform='scale(1)'; this.style.boxShadow='0 0 10px rgba(255, 255, 255, 0.5)'; this.style.textShadow='none';">Select All</button>
                            <button onclick="deselectAllPlaylistsForDeletion()" style="padding: 6px 12px; background: #000000; color: #ffd700; border: 2px solid #ffffff; border-radius: 4px; cursor: pointer; font-size: 12px; font-weight: bold; box-shadow: 0 0 10px rgba(255, 255, 255, 0.5); transition: all 0.3s ease;" onmouseover="this.style.transform='scale(1.05)'; this.style.boxShadow='0 0 20px rgba(255, 255, 255, 0.8)'; this.style.textShadow='0 0 10px #ffffff';" onmouseout="this.style.transform='scale(1)'; this.style.boxShadow='0 0 10px rgba(255, 255, 255, 0.5)'; this.style.textShadow='none';">Clear All</button>
                            <span id="deleteSelectedCount" style="color: #dc3545; font-weight: bold; margin-left: 10px;">0 selected</span>
                        </div>
                        
                        <!-- Playlist List -->
                        <div id="deletePlaylistList" style="flex: 1; overflow-y: auto; border: 1px solid #dc3545; border-radius: 4px; background: rgba(0,0,0,0.5); padding: 10px; max-height: 400px;">
                            <!-- Playlists will be populated here -->
                        </div>
                        
                        <!-- Action Buttons -->
                        <div style="margin-top: 20px; display: flex; gap: 10px; justify-content: space-between; align-items: center;">
                            <button onclick="closeDeletePlaylistModal()" style="padding: 10px 20px; background: #000000; color: #dc3545; border: 2px solid #dc3545; border-radius: 6px; cursor: pointer; font-weight: bold; box-shadow: 0 0 10px rgba(220, 53, 69, 0.5); transition: all 0.3s ease;" onmouseover="this.style.transform='scale(1.05)'; this.style.boxShadow='0 0 20px rgba(220, 53, 69, 0.8)'; this.style.textShadow='0 0 10px #dc3545';" onmouseout="this.style.transform='scale(1)'; this.style.boxShadow='0 0 10px rgba(220, 53, 69, 0.5)'; this.style.textShadow='none';">Cancel</button>
                            <div style="display: flex; gap: 10px;">
                                <button onclick="deleteSinglePlaylist()" style="padding: 10px 20px; background: #000000; color: #ffc107; border: 2px solid #ffc107; border-radius: 6px; cursor: pointer; font-weight: bold; box-shadow: 0 0 10px rgba(255, 193, 7, 0.5); transition: all 0.3s ease;" onmouseover="this.style.transform='scale(1.05)'; this.style.boxShadow='0 0 20px rgba(255, 193, 7, 0.8)'; this.style.textShadow='0 0 10px #ffc107';" onmouseout="this.style.transform='scale(1)'; this.style.boxShadow='0 0 10px rgba(255, 193, 7, 0.5)'; this.style.textShadow='none';"> Remove Single</button>
                                <button onclick="confirmDeleteSelectedPlaylists()" style="padding: 10px 20px; background: #000000; color: #dc3545; border: 2px solid #dc3545; border-radius: 6px; cursor: pointer; font-weight: bold; box-shadow: 0 0 10px rgba(220, 53, 69, 0.5); transition: all 0.3s ease;" onmouseover="this.style.transform='scale(1.05)'; this.style.boxShadow='0 0 20px rgba(220, 53, 69, 0.8)'; this.style.textShadow='0 0 10px #dc3545';" onmouseout="this.style.transform='scale(1)'; this.style.boxShadow='0 0 10px rgba(220, 53, 69, 0.5)'; this.style.textShadow='none';"> Remove Selected</button>
                                <button onclick="deleteAllPlaylists()" style="padding: 10px 20px; background: #000000; color: #8B0000; border: 2px solid #8B0000; border-radius: 6px; cursor: pointer; font-weight: bold; box-shadow: 0 0 10px rgba(139, 0, 0, 0.5); transition: all 0.3s ease;" onmouseover="this.style.transform='scale(1.05)'; this.style.boxShadow='0 0 20px rgba(139, 0, 0, 0.8)'; this.style.textShadow='0 0 10px #8B0000';" onmouseout="this.style.transform='scale(1)'; this.style.boxShadow='0 0 10px rgba(139, 0, 0, 0.5)'; this.style.textShadow='none';"> Remove All</button>
                            </div>
                        </div>
                    </div>
                </div>
            `;
            
            // Add to page
            document.body.appendChild(modal);
            
            // Store playlists globally for filtering
            window.allPlaylistsForDeletion = playlists;
            
            // Display all playlists initially
            displayPlaylistsForDeletion(playlists);
        }

        // Display playlists for deletion
        function displayPlaylistsForDeletion(playlists) {
            const listContainer = document.getElementById('deletePlaylistList');
            
            if (!playlists || playlists.length === 0) {
                listContainer.innerHTML = '<div style="text-align: center; color: #888; padding: 40px;">No playlists found</div>';
                return;
            }
            
            const playlistsHTML = playlists.map((playlist, index) => `
                <div style="display: flex; align-items: center; padding: 10px; border-bottom: 1px solid #333; margin-bottom: 5px; background: rgba(220,53,69,0.1); border-radius: 4px;">
                    <input type="checkbox" id="deletePlaylist_${index}" style="margin-right: 10px;" onchange="updateDeleteSelectionCount()">
                    
                    <div style="flex: 1; margin-right: 10px;">
                        <div style="color: #ffffff; font-size: 14px; font-weight: bold; margin-bottom: 3px;">${playlist.name}</div>
                        <div style="color: #888; font-size: 11px;">${playlist.filename}</div>
                        <div style="color: #dc3545; font-size: 14px;">Videos: ${playlist.video_count || 0} | Created: ${playlist.created_date || 'Unknown'}</div>
                    </div>
                    
                    <div style="color: #dc3545; font-size: 12px; font-weight: bold;"> DELETE</div>
                </div>
            `).join('');
            
            listContainer.innerHTML = playlistsHTML;
            updateDeleteSelectionCount();
        }

        // Search playlists for deletion
        function searchPlaylistsForDeletion() {
            const searchTerm = document.getElementById('deletePlaylistSearchInput').value.toLowerCase().trim();
            
            if (!searchTerm) {
                showAllPlaylistsForDeletion();
                return;
            }
            
            const filteredPlaylists = window.allPlaylistsForDeletion.filter(playlist => 
                playlist.name.toLowerCase().includes(searchTerm) || 
                playlist.filename.toLowerCase().includes(searchTerm)
            );
            
            displayPlaylistsForDeletion(filteredPlaylists);
        }

        // Show all playlists for deletion
        function showAllPlaylistsForDeletion() {
            document.getElementById('deletePlaylistSearchInput').value = '';
            displayPlaylistsForDeletion(window.allPlaylistsForDeletion);
        }

        // Select all playlists for deletion
        function selectAllPlaylistsForDeletion() {
            const checkboxes = document.querySelectorAll('#deletePlaylistList input[type="checkbox"]');
            checkboxes.forEach(cb => cb.checked = true);
            updateDeleteSelectionCount();
        }

        // Deselect all playlists for deletion
        function deselectAllPlaylistsForDeletion() {
            const checkboxes = document.querySelectorAll('#deletePlaylistList input[type="checkbox"]');
            checkboxes.forEach(cb => cb.checked = false);
            updateDeleteSelectionCount();
        }

        // Update selection count
        function updateDeleteSelectionCount() {
            const checkboxes = document.querySelectorAll('#deletePlaylistList input[type="checkbox"]:checked');
            const countElement = document.getElementById('deleteSelectedCount');
            countElement.textContent = `${checkboxes.length} selected`;
        }

        // Confirm deletion of selected playlists
        async function confirmDeleteSelectedPlaylists() {
            const checkboxes = document.querySelectorAll('#deletePlaylistList input[type="checkbox"]:checked');
            
            if (checkboxes.length === 0) {
                await showDeleteSuccess('Please select at least one playlist to remove.');
                return;
            }
            
            // Get selected playlist names
            const selectedPlaylists = [];
            checkboxes.forEach(checkbox => {
                const playlistItem = checkbox.closest('div');
                const nameElement = playlistItem.querySelector('div:nth-child(2) div:first-child');
                const filenameElement = playlistItem.querySelector('div:nth-child(2) div:nth-child(2)');
                if (nameElement && filenameElement) {
                    selectedPlaylists.push({
                        name: nameElement.textContent.trim(),
                        filename: filenameElement.textContent.trim()
                    });
                }
            });
            
            // Show confirmation modal
            const playlistNames = selectedPlaylists.map(p => p.name).join(', ');
            const playlistCount = selectedPlaylists.length;
            
            const confirmed = await showDeleteConfirmation(
                ' Remove Selected Playlists',
                `You are about to remove ${playlistCount} playlist${playlistCount > 1 ? 's' : ''}:<br><br><strong>${playlistNames}</strong><br><br>This will only remove the playlist files. Your videos will remain safe and unchanged.<br><br>Do you want to continue?`
            );
            
            if (confirmed) {
                await deleteSelectedPlaylists(selectedPlaylists);
            }
        }

        // Delete single playlist (first selected or prompt user)
        async function deleteSinglePlaylist() {
            const checkboxes = document.querySelectorAll('#deletePlaylistList input[type="checkbox"]:checked');
            
            if (checkboxes.length === 0) {
                await showDeleteSuccess('Please select one playlist to delete.');
                return;
            }
            
            if (checkboxes.length > 1) {
                await showDeleteSuccess('Please select only one playlist for single deletion, or use "Delete Selected" for multiple playlists.');
                return;
            }
            
            // Get selected playlist info
            const checkbox = checkboxes[0];
            const playlistItem = checkbox.closest('div');
            const nameElement = playlistItem.querySelector('div:nth-child(2) div:first-child');
            const filenameElement = playlistItem.querySelector('div:nth-child(2) div:nth-child(2)');
            
            if (!nameElement || !filenameElement) {
                await showDeleteSuccess('Error: Could not get playlist information.');
                return;
            }
            
            const playlistName = nameElement.textContent.trim();
            const playlistFilename = filenameElement.textContent.trim();
            
            // Show confirmation
            const confirmed = await showDeleteConfirmation(
                ' Remove Playlist',
                `You are about to remove the playlist:<br><br><strong>${playlistName}</strong><br><br>This will only delete the playlist file. Your videos will remain safe and unchanged.<br><br>Do you want to continue?`
            );
            
            if (!confirmed) return;
            
            try {
                const response = await fetch('/api/delete_single_playlist', {
                    method: 'POST',
                    headers: {
                        'Content-Type': 'application/json',
                        ...window.authHeaders
                    },
                    body: JSON.stringify({
                        playlist_filename: playlistFilename,
                        playlist_name: playlistName
                    })
                });
                
                const data = await response.json();
                
                if (response.ok && data.success) {
                    await showDeleteSuccess(` Playlist removed successfully: <strong>${playlistName}</strong><br><br>Your videos remain safe and unchanged.`);
                    closeDeletePlaylistModal();
                } else {
                    throw new Error(data.message || 'Failed to delete playlist');
                }
                
            } catch (error) {
                console.error('Error deleting single playlist:', error);
                await showDeleteSuccess(` Failed to delete playlist: ${error.message}`);
            }
        }

        // Delete selected playlists
        async function deleteSelectedPlaylists(playlists) {
            console.log('Deleting selected playlists:', playlists);
            
            try {
                const playlistsData = playlists.map(p => ({
                    playlist_filename: p.filename,
                    playlist_name: p.name
                }));
                
                const response = await fetch('/api/delete_selected_playlists', {
                    method: 'POST',
                    headers: {
                        'Content-Type': 'application/json',
                        ...window.authHeaders
                    },
                    body: JSON.stringify({
                        playlists: playlistsData
                    })
                });
                
                const data = await response.json();
                
                if (response.ok && data.success) {
                    let message = ` Playlists processed successfully<br><br>`;
                    message += `<strong>Removed:</strong> ${data.deleted_count} playlists<br>`;
                    if (data.failed_count > 0) {
                        message += `<strong>Failed:</strong> ${data.failed_count} playlists<br><br>`;
                        message += '<strong>Playlists that could not be removed:</strong><br>';
                        data.failed_playlists.forEach(failed => {
                            message += ` ${failed.name}: ${failed.error}<br>`;
                        });
                    }
                    message += `<br>Your videos remain safe and unchanged.`;
                    
                    await showDeleteSuccess(message);
                    
                    if (data.deleted_count > 0) {
                        closeDeletePlaylistModal();
                    }
                } else {
                    throw new Error(data.message || 'Failed to delete selected playlists');
                }
                
            } catch (error) {
                console.error('Error deleting selected playlists:', error);
                await showDeleteSuccess(` Failed to delete selected playlists: ${error.message}`);
            }
        }

        // Delete all playlists
        async function deleteAllPlaylists() {
            const totalPlaylists = window.allPlaylistsForDeletion ? window.allPlaylistsForDeletion.length : 0;
            
            if (totalPlaylists === 0) {
                await showDeleteSuccess('No playlists found to delete.');
                return;
            }
            
            // Show warning confirmation
            const playlistNames = window.allPlaylistsForDeletion.map(p => p.name).slice(0, 10).join(', ');
            const moreText = totalPlaylists > 10 ? `... and ${totalPlaylists - 10} more` : '';
            
            const confirmed = await showDeleteConfirmation(
                ' Remove All Playlists',
                `You are about to remove <strong>all ${totalPlaylists} playlists</strong>:<br><br>` +
                `<strong>${playlistNames}${moreText}</strong><br><br>` +
                `This will only remove the playlist files (${totalPlaylists} files). Your videos and their data will remain safe and unchanged.<br><br>` +
                `Do you want to continue?`
            );
            
            if (!confirmed) return;
            
            // Second confirmation for safety
            const doubleConfirmed = await showDeleteConfirmation(
                ' Final Confirmation',
                `Please confirm that you want to remove all ${totalPlaylists} playlist files.<br><br>` +
                `Your videos will not be affected and will remain accessible in the system.<br><br>` +
                `Click Delete to proceed, or Cancel to abort.`
            );
            
            if (!doubleConfirmed) return;
            
            try {
                const response = await fetch('/api/delete_all_playlists', {
                    method: 'POST',
                    headers: {
                        'Content-Type': 'application/json',
                        ...window.authHeaders
                    },
                    body: JSON.stringify({
                        confirm: true
                    })
                });
                
                const data = await response.json();
                
                if (response.ok && data.success) {
                    let message = ` <strong>Playlists Removed Successfully</strong><br><br>`;
                    message += `<strong>Removed:</strong> ${data.deleted_count} playlist files<br>`;
                    if (data.failed_count > 0) {
                        message += `<strong>Failed:</strong> ${data.failed_count} files<br><br>`;
                        message += '<strong>Files that could not be removed:</strong><br>';
                        data.failed_playlists.forEach(failed => {
                            message += ` ${failed.filename}: ${failed.error}<br>`;
                        });
                    }
                    message += `<br>Your videos remain safe and unchanged.<br><br><strong>Completed at:</strong> ${data.timestamp}`;
                    
                    await showDeleteSuccess(message);
                    closeDeletePlaylistModal();
                } else {
                    throw new Error(data.message || 'Failed to delete all playlists');
                }
                
            } catch (error) {
                console.error('Error deleting all playlists:', error);
                await showDeleteSuccess(` Failed to delete all playlists: ${error.message}`);
            }
        }

        // Close delete playlist modal
        function closeDeletePlaylistModal() {
            const modal = document.querySelector('.playlist-delete-modal');
            if (modal) {
                modal.remove();
            }
            window.allPlaylistsForDeletion = null;
        }

        // Custom confirmation modal functions
        let deleteConfirmationResolver = null;

        function showDeleteConfirmation(title, message) {
            return new Promise((resolve) => {
                deleteConfirmationResolver = resolve;
                document.getElementById('playlistDeleteConfirmationHeader').innerHTML = title;
                document.getElementById('playlistDeleteConfirmationBody').innerHTML = message.replace(/\n/g, '<br>');
                document.getElementById('playlistDeleteConfirmationModal').style.display = 'block';
            });
        }

        function closeDeleteConfirmation(result) {
            document.getElementById('playlistDeleteConfirmationModal').style.display = 'none';
            if (deleteConfirmationResolver) {
                deleteConfirmationResolver(result);
                deleteConfirmationResolver = null;
            }
        }

        // Custom success modal functions
        function showDeleteSuccess(message) {
            return new Promise((resolve) => {
                document.getElementById('deleteSuccessBody').innerHTML = message.replace(/\n/g, '<br>');
                document.getElementById('deleteSuccessModal').style.display = 'block';
                window.deleteSuccessResolver = resolve;
            });
        }

        function closeDeleteSuccess() {
            document.getElementById('deleteSuccessModal').style.display = 'none';
            if (window.deleteSuccessResolver) {
                window.deleteSuccessResolver();
                window.deleteSuccessResolver = null;
            }
        }
        

</script>
    <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/xterm@5.3.0/css/xterm.css" />
    
    <!-- Custom Confirmation Modal -->
    <div id="confirmationModal" class="confirmation-modal">
        <div class="confirmation-modal-content">
            <div class="confirmation-modal-header">
                <span class="icon"></span>
                <h3 id="confirmationTitle">Confirm Deletion</h3>
            </div>
            <div class="confirmation-modal-body">
                <p id="confirmationMessage">Are you sure you want to delete this item?</p>
                <div id="confirmationFileList" class="file-list" style="display: block;"></div>
                <div class="warning-text"> This action cannot be undone!</div>
            </div>
            <div class="confirmation-modal-footer">
                <button id="confirmationCancelBtn" class="modal-btn modal-btn-cancel">Cancel</button>
                <button id="confirmationDeleteBtn" class="modal-btn modal-btn-delete">Delete</button>
            </div>
        </div>
    </div>
    
    <!-- Success Modal -->
    <div id="oldReserveSuccessModal" class="success-modal">
        <div class="success-modal-content">
            <div class="success-modal-header">
                <span class="success-icon"></span>
                <h3 id="successTitle">Success!</h3>
            </div>
            <div class="success-modal-body">
                <div id="successDetails" class="success-details" style="display: block;">
                    <div id="successCount" class="success-count"></div>
                    <div id="successFileList" class="success-file-list"></div>
                </div>
            </div>
            <div class="success-modal-footer">
                <button id="successOkBtn" class="success-modal-btn" onclick="closeModal('oldReserveSuccessModal')">OK</button>
            </div>
        </div>
    </div>
   <div id="reserveQuotaModal" class="modal">
        <div class="modal-content" style="max-width: 1000px; height: auto;">
            <div class="modal-header">
                <h2> Disk Reserve Quota | Status Configuration</h2>
                <button class="close" onclick="document.getElementById('reserveQuotaModal').style.display='none'">&times;</button>
            </div>
            <div class="modal-body" style="padding: 20px 30px 10px 30px; height: auto;">                <!-- Storage Status Display -->                <div style="margin-bottom: 20px; padding: 15px; background: #1a1a1a; border-radius: 8px; border: 1px solid #333;">                    <div style="display: flex; align-items: center; flex-wrap: nowrap; justify-content: space-between; margin-bottom: 10px;">                        <span style="color: #fff; font-size: 16px; font-weight: 500;"> Storage Status</span>                        <span style="color: #fff; font-size: 16px; font-weight: 500;"><div style="display: flex; align-items: center; gap: 10px;"><span style="color: #4CAF50; font-size: 14px; font-weight: 400;"> Used space amount: <strong style="color: #fff;">6.42 GB</strong></span><span style="color: #fff; font-weight: 500;">     </span><span style="color: #64B5F6; font-size: 14px; font-weight: 400;"> Total disk size: <strong style="color: #fff;">9.51 GB</strong></span></div></span>                    </div>                    <div style="width: 100%; height: 8px; background: #333; border-radius: 4px; overflow: hidden; margin-bottom: 15px;">                        <div style="width: 67%; height: 100%; background: linear-gradient(to right, #4CAF50, #FF9800, #F44336);"></div>                    </div>                    <div style="display: flex; justify-content: space-between; font-size: 14px; color: #ccc;">                        <div><span style="color: #4CAF50;"></span> Available: <span style="color: #fff;">3.09 GB</span></div>                        <div><span style="color: #FF9800;"></span> Reserve: <span style="color: #fff;">0.5 GB</span></div>                        <div><span style="color: #F44336;"></span> Upload limit: <span style="color: #fff;">2.60 GB</span></div>                    </div>                </div>                                <!-- Two Column Layout: Input Controls Left, Disclaimer Right -->                <div style="display: flex; gap: 30px; margin-bottom: 20px;">                    <!-- Left Column: Reserve Input Section -->                    <div style="flex: 1;">                        <label style="display: block; margin-bottom: 8px; font-weight: 500; color: #fff;">Set Reserve Amount:</label>                        <div style="display: flex; gap: 10px; align-items: center; margin-bottom: 15px; max-width: 600px; white-space: nowrap;">                            <input type="number" id="reserveAmount" placeholder="0.5" style="width: 120px; padding: 8px 12px; background: #2a2a2a; border: 1px solid #555; border-radius: 4px; color: #fff;" step="0.1" min="0">                            <span style="padding: 8px 12px; color: #ccc; font-size: 14px; font-weight: 500;">GB</span>                            <button style="padding: 8px 16px; background: transparent; color: #4CAF50; border: 2px solid #4CAF50; border-radius: 4px; cursor: pointer; font-weight: 500; transition: all 0.3s ease;" onmouseover="this.style.transform='scale(1.05)'; this.style.boxShadow='0 0 15px #4CAF50'; this.style.textShadow='0 0 8px #4CAF50';" onmouseout="this.style.transform='scale(1)'; this.style.boxShadow='none'; this.style.textShadow='none';" onclick="setReserveValue()">Set</button>                        </div>                                                <div style="margin-bottom: 15px;">                            <label style="display: flex; align-items: center; color: #fff; cursor: pointer; white-space: nowrap;">                                <input type="checkbox" id="reserveNotSetCheckbox" style="margin-right: 8px;" onchange="toggleReserveInput()">                                Use all available space - Unsets reserve value                            </label>                        </div>                    </div>                                        <!-- Right Column: Disclaimer -->                    <div style="flex: 1;">                        <div style="padding: 15px; background: #2a1a1a; border: 1px solid #664444; border-radius: 8px; height: fit-content;">                            <div style="display: flex; align-items: center; margin-bottom: 8px;">                                <span style="color: #dc2626; margin-right: 8px; font-size: 18px;"></span>                                <strong style="color: #dc2626;">Reserve Quota Information</strong>                            </div>                            <p style="margin: 0; color: #ccc; font-size: 13px; line-height: 1.4;">                                Reserve quota prevents your disk from filling completely by keeping a buffer of free space.                                 This ensures system stability and prevents upload failures. The reserved space cannot be used for uploads                                 and will show as "unavailable" in your storage calculations.                            </p>                        </div>                    </div>                </div>            </div>
        </div>
    </div>
   <!-- Quota Notification Containers -->
    <div id="quotaNotificationSuccess" class="quota-notification" style="display: none;">
        <div class="quota-notification-header">
            <div class="quota-notification-title">
                <span></span> Reserve Value Set
            </div>
            <button class="quota-notification-close" onclick="closeQuotaNotification('quotaNotificationSuccess')">&times;</button>
        </div>
        <div class="quota-notification-body" id="quotaSuccessMessage">
            Reserve value successfully set!
        </div>
    </div>
    
    <div id="quotaNotificationError" class="quota-notification error" style="display: none;">
        <div class="quota-notification-header">
            <div class="quota-notification-title">
                <span></span> Invalid Input
            </div>
            <button class="quota-notification-close" onclick="closeQuotaNotification('quotaNotificationError')">&times;</button>
        </div>
        <div class="quota-notification-body" id="quotaErrorMessage">
            Please enter a valid reserve amount greater than 0
        </div>
    </div>
<!-- Success Modal -->
<div id="reserveSuccessModal" class="quota-error-modal">
    <div class="quota-error-content">
        <div style="background:#4CAF50; padding:15px; border-radius:8px 8px 0 0; color:white; display:flex; justify-content:space-between; align-items:center;">
            <h3 style="margin:0; text-shadow: 3px 3px 8px rgba(0,0,0,0.9);"> Success</h3>
            <button onclick="closeModal('reserveSuccessModal')" style="background:transparent; border:none; color:white; font-size:20px; cursor:pointer;">&times;</button>
        </div>
        <div style="padding:20px; text-align:center;">
            <p id="reserveSuccessMessage" style="color:#fff; margin:0 0 15px 0;">Success!</p>
            <button onclick="closeModal('reserveSuccessModal')" style="background:#4CAF50; color:white; border:none; padding:8px 16px; border-radius:4px; cursor:pointer;">OK</button>
        </div>
    </div>
</div>

</div>
<!-- Warning Modal for NOT SET Reserve -->
<div id="reserveWarningModal" class="quota-error-modal">
    <div class="quota-error-content">
        <div style="background:#000000; padding:15px; border-radius:8px 8px 0 0; color:#ffffff; display:flex; justify-content:space-between; align-items:center; border: 1px solid #ffff00;">
            <h3 style="margin:0;"> Warning: No Reserve Value</h3>
            <button onclick="cancelNotSetReserve()" style="background:transparent; border:none; color:#ffff00; font-size:20px; cursor:pointer;">&times;</button>
        </div>
        <div style="padding:20px; text-align:center; background:#000000; color:#ffff00;">
            <p style="margin:0 0 15px 0; font-weight:bold;">
                 You are about to disable storage reservation!
            </p>
            <p style="margin:0 0 20px 0;">
                Without a reserve value, your system may run out of disk space completely, 
                potentially causing system instability or crashes. This could prevent 
                critical operations and file saving.
            </p>
            <p style="margin:0 0 20px 0; color:#ff6600; font-weight:bold;">
                Are you sure you want to proceed without setting a reserve value?
            </p>
            <div style="display:flex; gap:10px; justify-content:center;">
                <button onclick="confirmNotSetReserve()" style="background:#dc2626; color:white; border:none; padding:10px 20px; border-radius:4px; cursor:pointer; font-weight:bold;">
                    Yes, Disable Reserve
                </button>
                <button onclick="cancelNotSetReserve()" style="background:#16a34a; color:white; border:none; padding:10px 20px; border-radius:4px; cursor:pointer; font-weight:bold;">
                    Cancel, Keep Safe
                </button>
            </div>
        </div>
    </div>
</div>

<!-- Refresh Success Modal -->
<div id="refreshSuccessModal" class="success-modal">
    <div class="refresh-modal-content">
        <div style="background:#000000; padding:20px; border-radius:8px 8px 0 0; color:#ffffff; text-align:center;">
            <div style="margin-bottom:15px;">
                <span style="font-size:48px; color:#4CAF50;"></span>
            </div>
            <h3 style="margin:0 0 10px 0; color:#4CAF50; font-size:24px;">Storage capacity data</h3>
            <p style="margin:0; color:#ffffff; font-size:16px; opacity:0.9;">
                 Data successfully updated from configuration file
            </p>
        </div>
        <div style="padding:20px; text-align:center; background:#000000; color:#ffffff; border-radius:0 0 8px 8px;">
            <div style="margin-bottom:20px;">
                <div style="display:flex; justify-content:space-around; margin-bottom:15px;">
                    <div style="text-align:center;">
                        <div style="color:#4CAF50; font-size:14px; font-weight:bold;"> RESERVE</div>
                        <div style="color:#ffffff; font-size:16px;" id="refreshModalReserve">--</div>
                    </div>
                    <div style="text-align:center;">
                        <div style="color:#2196F3; font-size:14px; font-weight:bold;"> UPLOAD LIMIT</div>
                        <div style="color:#ffffff; font-size:16px;" id="refreshModalUpload">--</div>
                    </div>
                    <div style="text-align:center;">
                        <div style="color:#FF9800; font-size:14px; font-weight:bold;"> AVAILABLE</div>
                        <div style="color:#ffffff; font-size:16px;" id="refreshModalAvailable">--</div>
                    </div>
                </div>
            </div>
            <button onclick="closeRefreshModal()" style="background:#4CAF50; color:white; border:none; padding:10px 20px; border-radius:4px; cursor:pointer; font-weight:bold;">
                OK
            </button>
        </div>
    </div>
</div>

<!-- Error Modal -->
<div id="errorModal" class="quota-error-modal">
    <div class="quota-error-content">
        <div style="background:#dc2626; padding:15px; border-radius:8px 8px 0 0; color:white; display:flex; justify-content:space-between; align-items:center;">
            <h3 style="margin:0;"> Error</h3>
            <button onclick="closeModal('errorModal')" style="background:transparent; border:none; color:white; font-size:20px; cursor:pointer;">&times;</button>
        </div>
        <div style="padding:20px; text-align:center;">
            <p id="errorMessage" style="color:#fff; margin:0 0 15px 0;">Error!</p>
            <button onclick="closeModal('errorModal')" style="background:#dc2626; color:white; border:none; padding:8px 16px; border-radius:4px; cursor:pointer;">OK</button>
        </div>
    </div>
</div>

<!-- Insufficient Reserve Space Modal -->
<div id="insufficientReserveModal" class="quota-error-modal">
    <div class="quota-error-content">
        <div style="background:#dc2626; padding:20px; border-radius:8px 8px 0 0; color:#ffffff; text-align:center; border: 2px solid #dc2626;">
            <div style="margin-bottom:15px;">
                <span style="font-size:48px; color:#dc2626;"></span>
            </div>
            <h3 style="margin:0 0 10px 0; color:#dc2626; font-size:24px;">Insufficient Reserve Space</h3>
            <p style="margin:0; color:#ffffff; font-size:16px; opacity:0.9;">
                Upload would exceed reserved storage limit
            </p>
        </div>
        <div style="padding:20px; background:#1a1a1a; border-radius:0 0 8px 8px; color:#ffffff;">
            <div style="display:grid; grid-template-columns:1fr 1fr; gap:15px; margin-bottom:15px;">
                <div style="text-align:center;">
                    <div style="color:#fbbf24; font-size:14px; margin-bottom:5px;"> TOTAL SPACE</div>
                    <div id="reserveErrorModalTotalSpace" style="font-size:18px; font-weight:bold; color:#fbbf24;">-- GB</div>
                </div>
                <div style="text-align:center;">
                    <div style="color:#dc2626; font-size:14px; margin-bottom:5px;"> USED SPACE</div>
                    <div id="reserveErrorModalUsedSpace" style="font-size:18px; font-weight:bold; color:#dc2626;">-- GB</div>
                </div>
                <div style="text-align:center;">
                    <div style="color:#10b981; font-size:14px; margin-bottom:5px;"> AVAILABLE</div>
                    <div id="reserveErrorModalAvailableSpace" style="font-size:18px; font-weight:bold; color:#10b981;">-- GB</div>
                </div>
                <div style="text-align:center;">
                    <div style="color:#f59e0b; font-size:14px; margin-bottom:5px;"> RESERVED</div>
                    <div id="reserveErrorModalReservedValue" style="font-size:18px; font-weight:bold; color:#f59e0b;">-- GB</div>
                </div>
            </div>
            <div style="display:flex; justify-content:space-between; margin-bottom:15px; padding:10px; background:#374151; border-radius:6px;">
                <div style="text-align:center;">
                    <div style="color:#60a5fa; font-size:14px; margin-bottom:5px;"> UPLOAD SIZE</div>
                    <div id="reserveModalUploadSize" style="font-size:20px; font-weight:bold; color:#60a5fa;">-- GB</div>
                </div>
                <div style="text-align:center;">
                    <div style="color:#f87171; font-size:14px; margin-bottom:5px;"> REMAINING</div>
                    <div id="reserveModalRemainingSpace" style="font-size:20px; font-weight:bold; color:#f87171;">-- GB</div>
                </div>
            </div>
            <div style="padding:15px; background:#374151; border-radius:6px; margin-bottom:20px;">
                <p style="margin:0; font-size:14px; color:#d1d5db; line-height:1.4;">
                    This upload would reduce your available space below the reserved limit. 
                    Please reduce the upload size or adjust your storage reserve settings.
                </p>
            </div>
            <button onclick="closeModal('insufficientReserveModal')" 
                    style="background:#dc2626; color:white; border:none; padding:12px 24px; border-radius:6px; cursor:pointer; font-size:16px; font-weight:bold;">
                 OK 
            </button>
        </div>
    </div>
</div>

<!-- Upload Space Valid Modal -->
<div id="uploadSpaceValidModal" class="quota-error-modal">
    <div class="quota-error-content">
        <div style="background:#10b981; padding:20px; border-radius:8px 8px 0 0; color:#ffffff; text-align:center; border: 2px solid #10b981;">
            <div style="margin-bottom:15px;">
                <span style="font-size:48px; color:#10b981;"></span>
            </div>
            <h3 style="margin:0 0 10px 0; color:#10b981; font-size:24px;">Upload Space Available</h3>
            <p style="margin:0; color:#ffffff; font-size:16px; opacity:0.9;">
                Upload is within reserved storage limits
            </p>
        </div>
        <div style="padding:20px; background:#1a1a1a; border-radius:0 0 8px 8px; color:#ffffff;">
            <div style="display:grid; grid-template-columns:1fr 1fr; gap:15px; margin-bottom:15px;">
                <div style="text-align:center;">
                    <div style="color:#fbbf24; font-size:14px; margin-bottom:5px;"> TOTAL SPACE</div>
                    <div id="reserveSuccessModalTotalSpace" style="font-size:18px; font-weight:bold; color:#fbbf24;">-- GB</div>
                </div>
                <div style="text-align:center;">
                    <div style="color:#dc2626; font-size:14px; margin-bottom:5px;"> USED SPACE</div>
                    <div id="reserveSuccessModalUsedSpace" style="font-size:18px; font-weight:bold; color:#dc2626;">-- GB</div>
                </div>
                <div style="text-align:center;">
                    <div style="color:#10b981; font-size:14px; margin-bottom:5px;"> AVAILABLE</div>
                    <div id="reserveSuccessModalAvailableSpace" style="font-size:18px; font-weight:bold; color:#10b981;">-- GB</div>
                </div>
                <div style="text-align:center;">
                    <div style="color:#f59e0b; font-size:14px; margin-bottom:5px;"> RESERVED</div>
                    <div id="reserveSuccessModalReservedValue" style="font-size:18px; font-weight:bold; color:#f59e0b;">-- GB</div>
                </div>
            </div>
            <div style="display:flex; justify-content:space-between; margin-bottom:15px; padding:10px; background:#374151; border-radius:6px;">
                <div style="text-align:center;">
                    <div style="color:#60a5fa; font-size:14px; margin-bottom:5px;"> UPLOAD SIZE</div>
                    <div id="successModalUploadSize" style="font-size:20px; font-weight:bold; color:#60a5fa;">-- GB</div>
                </div>
                <div style="text-align:center;">
                    <div style="color:#10b981; font-size:14px; margin-bottom:5px;"> REMAINING</div>
                    <div id="successModalRemainingSpace" style="font-size:20px; font-weight:bold; color:#10b981;">-- GB</div>
                </div>
            </div>
            <div style="display:flex; justify-content:space-between; align-items:center; padding:15px; background:#065f46; border-radius:6px; margin-bottom:20px;">
                <div style="color:#d1fae5; font-size:14px;">
                    <span style="font-weight:bold;">Upload Limit Available:</span>
                </div>
                <div id="successModalUploadLimit" style="font-size:18px; font-weight:bold; color:#10b981;">-- GB</div>
            </div>
            <button onclick="closeModal('uploadSpaceValidModal')" 
                    style="background:#10b981; color:white; border:none; padding:12px 24px; border-radius:6px; cursor:pointer; font-size:16px; font-weight:bold;">
                 Continue 
            </button>
        </div>
    </div>
</div>

    <!-- Delete Confirmation Modal -->
    <div id="deleteConfirmationModal" class="modal" style="display: none; z-index: 10002;">
        <div class="modal-content" style="max-width: 600px; height: auto; background: linear-gradient(135deg, #2a0a0a, #1a0a0a); border: 3px solid #dc3545; border-radius: 15px; box-shadow: 0 0 30px rgba(220, 53, 69, 0.6), inset 0 0 20px rgba(220, 53, 69, 0.1);">
            <div class="modal-header" style="background: linear-gradient(135deg, #3d1a1a, #2d1a1a); border-bottom: 2px solid #dc3545; border-radius: 12px 12px 0 0; position: relative; overflow: hidden;">
                <div style="position: absolute; top: 0; left: 0; right: 0; height: 2px; background: linear-gradient(90deg, transparent, #dc3545, transparent); animation: pulse 2s infinite;"></div>
                <h2 style="color: #dc3545; text-shadow: 0 0 10px rgba(220, 53, 69, 0.8); font-weight: 700; margin: 0; display: flex; align-items: center; gap: 15px;">
                    <span style="font-size: 32px;"></span>
                    <span style="background: linear-gradient(45deg, #dc3545, #ff6b6b); -webkit-background-clip: text; -webkit-text-fill-color: transparent;">DELETE CONFIRMATION</span>
                </h2>
                <button class="close" onclick="closeDeleteModal()" style="background: linear-gradient(135deg, #dc3545, #c82333) !important; color: #ffffff !important; border: 2px solid #ffffff; border-radius: 50%; width: 40px; height: 40px; font-size: 18px; font-weight: bold; box-shadow: 0 0 15px rgba(220, 53, 69, 0.6); transition: all 0.3s ease;">&times;</button>
            </div>
            <div class="modal-body" style="padding: 30px; background: #0a0a0a; color: white; text-align: center;">
                <div style="margin-bottom: 25px;">
                    <div style="font-size: 64px; margin-bottom: 15px;"></div>
                    <h3 id="deleteModalTitle" style="color: #ff6b6b; margin-bottom: 15px; font-size: 24px; font-weight: bold;">DANGEROUS OPERATION</h3>
                    <p id="deleteModalMessage" style="color: #ccc; font-size: 18px; margin-bottom: 25px; line-height: 1.5;"></p>
                    <div id="deleteVideosList" style="max-height: 200px; overflow-y: auto; background: rgba(220, 53, 69, 0.1); border: 1px solid #dc3545; border-radius: 8px; padding: 15px; margin-bottom: 25px; text-align: left; display: none;">
                        <h4 style="color: #dc3545; margin-bottom: 10px;">Videos to be deleted:</h4>
                        <div id="deleteVideosListContent" style="color: #ccc; font-size: 14px;"></div>
                    </div>
                </div>
                <div style="display: flex; gap: 20px; justify-content: center;">
                    <button onclick="closeDeleteModal()" style="padding: 15px 30px; background: linear-gradient(145deg, #6c757d, #545b62); color: white; border: none; border-radius: 8px; font-weight: bold; cursor: pointer; font-size: 16px; transition: all 0.3s ease;">
                         Cancel
                    </button>
                    <button id="confirmDeleteBtn" onclick="confirmDelete()" style="padding: 15px 30px; background: linear-gradient(145deg, #dc3545, #c82333); color: white; border: none; border-radius: 8px; font-weight: bold; cursor: pointer; font-size: 16px; transition: all 0.3s ease; box-shadow: 0 0 15px rgba(220, 53, 69, 0.4);">
                         DELETE PERMANENTLY
                    </button>
                </div>
                <p style="color: #888; font-size: 12px; margin-top: 20px; font-style: italic;">
                    This action cannot be undone. Files will be permanently removed from the system.
                </p>
            </div>
        </div>
    </div>

    <!-- Deletion Success Modal -->
    <div id="deletionSuccessModal" class="modal" style="display: none; z-index: 10003;">
        <div class="modal-content" style="max-width: 650px; height: auto; background: linear-gradient(135deg, #0a2a0a, #0a1a0a); border: 3px solid #28a745; border-radius: 15px; box-shadow: 0 0 30px rgba(40, 167, 69, 0.6), inset 0 0 20px rgba(40, 167, 69, 0.1);">
            <div class="modal-header" style="background: linear-gradient(135deg, #1a3d1a, #1a2d1a); border-bottom: 2px solid #28a745; border-radius: 12px 12px 0 0; position: relative; overflow: hidden;">
                <div style="position: absolute; top: 0; left: 0; right: 0; height: 2px; background: linear-gradient(90deg, transparent, #28a745, transparent); animation: pulse 2s infinite;"></div>
                <h2 style="color: #28a745; text-shadow: 0 0 10px rgba(40, 167, 69, 0.8); font-weight: 700; margin: 0; display: flex; align-items: center; gap: 15px;">
                    <span style="font-size: 32px;"></span>
                    <span style="background: linear-gradient(45deg, #28a745, #6bff6b); -webkit-background-clip: text; -webkit-text-fill-color: transparent;">DELETION COMPLETE</span>
                </h2>
                <button class="close" onclick="closeDeletionSuccessModal()" style="background: linear-gradient(135deg, #28a745, #20a045) !important; color: #ffffff !important; border: 2px solid #ffffff; border-radius: 50%; width: 40px; height: 40px; font-size: 18px; font-weight: bold; box-shadow: 0 0 15px rgba(40, 167, 69, 0.6); transition: all 0.3s ease;">&times;</button>
            </div>
            <div class="modal-body" style="padding: 30px; background: #0a0a0a; color: white; text-align: center;">
                <div style="margin-bottom: 25px;">
                    <div style="font-size: 64px; margin-bottom: 15px;"></div>
                    <h3 id="deletionSuccessTitle" style="color: #6bff6b; margin-bottom: 15px; font-size: 24px; font-weight: bold;">OPERATION SUCCESSFUL</h3>
                    <p id="deletionSuccessMessage" style="color: #ccc; font-size: 18px; margin-bottom: 25px; line-height: 1.5;"></p>
                    <div id="deletionStats" style="background: rgba(40, 167, 69, 0.1); border: 1px solid #28a745; border-radius: 8px; padding: 20px; margin-bottom: 25px;">
                        <h4 style="color: #28a745; margin-bottom: 15px;"> Video Count Analysis</h4>
                        <div style="display: grid; grid-template-columns: 1fr 1fr; gap: 15px; text-align: left;">
                            <div style="color: #ccc;">
                                <strong style="color: #ff6b6b;">Before Deletion:</strong><br>
                                <span id="videosBeforeCount" style="font-size: 20px; color: #fff;">-</span> videos
                            </div>
                            <div style="color: #ccc;">
                                <strong style="color: #6bff6b;">After Refresh:</strong><br>
                                <span id="videosAfterCount" style="font-size: 20px; color: #fff;">-</span> videos
                            </div>
                        </div>
                        <div style="margin-top: 15px; padding-top: 15px; border-top: 1px solid #333;">
                            <strong style="color: #28a745;"> Confirmed Deleted:</strong>
                            <span id="confirmedDeletedCount" style="font-size: 24px; color: #6bff6b; margin-left: 10px;">-</span> videos
                        </div>
                    </div>
                </div>
                <button onclick="closeDeletionSuccessModal()" style="padding: 15px 30px; background: linear-gradient(145deg, #28a745, #20a045); color: white; border: none; border-radius: 8px; font-weight: bold; cursor: pointer; font-size: 16px; transition: all 0.3s ease; box-shadow: 0 0 15px rgba(40, 167, 69, 0.4);">
                     Continue
                </button>
            </div>
        </div>
    </div>

    <!-- Download Progress Modal -->
    <div id="download-modal" class="modal">
        <div class="modal-content">
            <div class="modal-header">
                <h2> Download Progress</h2>
                <button class="close" onclick="closeDownloadModal()" style="display: block;">&times;</button>
            </div>
            <div class="modal-body" style="padding: 20px 30px 10px 30px; height: auto; min-height: 400px; max-height: 80vh; overflow-y: auto; background: rgba(0,255,0,0.1) !important;">
                <div id="download-modal-progress-container">
                    <!-- Progress items will be inserted here -->
                </div>
            </div>
            <div class="modal-footer" id="download-modal-footer" style="display: none; padding: 20px; text-align: center; border-top: 1px solid #333; background: rgba(0,0,0,0.1); position: sticky; bottom: 0;">
                <button id="download-ok-btn" class="success-modal-btn" onclick="closeDownloadModal()" style="padding: 12px 30px; font-size: 16px; display: none;">Press Ok to close this window</button>
            </div>
        </div>
    </div>

    <!-- Individual File Download Progress Modal -->
    <div id="individual-download-modal" class="modal">
        <div class="modal-content">
            <div class="modal-header">
                <h2> File Download Progress</h2>
                <button class="close" onclick="closeIndividualDownloadModal()" style="display: block;">&times;</button>
            </div>
            <div class="modal-body" style="padding: 20px 30px 10px 30px; height: auto; min-height: 200px; max-height: 80vh; overflow-y: auto; background: rgba(0,255,0,0.1) !important;">
                <div id="individual-download-progress-container">
                    <!-- Progress item will be inserted here -->
                </div>
            </div>
            <div class="modal-footer" id="individual-download-modal-footer" style="display: none; padding: 20px; text-align: center; border-top: 1px solid #333; background: rgba(0,0,0,0.1); position: sticky; bottom: 0;">
                <button id="individual-download-ok-btn" class="success-modal-btn" onclick="closeIndividualDownloadModal()" style="padding: 12px 30px; font-size: 16px; display: none;">Press Ok to close this window</button>
            </div>
        </div>
    </div>

    <!-- System Specs Modal -->
    <div id="system-specs-modal" class="system-specs-modal">
        <div class="system-specs-modal-content">
            <div class="system-specs-header">
                <span class="system-specs-title">Linux System Specifications</span>
                <span class="system-specs-close" onclick="closeSystemSpecs()">&times;</span>
            </div>
            <div class="system-specs-body">
                <div class="system-specs-terminal" id="system-specs-terminal">
                    <div class="system-specs-loading" id="system-specs-loading">
                        Loading system specifications...
                        <br><br>
                         Analyzing hardware and software configuration
                        <br>
                         Gathering network information
                        <br>
                         Collecting memory and storage details
                    </div>
                </div>
            </div>
        </div>
    </div>


    <!-- Custom Playlist Delete Confirmation Modal -->
    <div id="playlistDeleteConfirmationModal" class="delete-confirmation-modal">
        <div class="delete-confirmation-content">
            <div class="delete-confirmation-header" id="playlistDeleteConfirmationHeader">
                 CONFIRM DELETION
            </div>
            <div class="delete-confirmation-body" id="playlistDeleteConfirmationBody">
                Are you sure you want to proceed with this deletion?
            </div>
            <div class="delete-confirmation-footer">
                <button class="cancel-btn" onclick="closeDeleteConfirmation(false)">Cancel</button>
                <button class="delete-btn" onclick="closeDeleteConfirmation(true)">Delete</button>
            </div>
        </div>
    </div>

    <!-- Custom Delete Success Modal -->
    <div id="deleteSuccessModal" class="delete-success-modal">
        <div class="delete-success-content">
            <div class="delete-success-header">
                 SUCCESS
            </div>
            <div class="delete-success-body" id="deleteSuccessBody">
                Operation completed successfully.
            </div>
            <div class="delete-success-footer">
                <button class="ok-btn" onclick="closeDeleteSuccess()">OK</button>
            </div>
        </div>
    </div>

    <!-- Welcome Video Modal -->
    <div id="welcomeModal" class="welcome-modal">
        <div class="welcome-modal-content">
            <div class="modal-close" onclick="closeWelcomeModal()">&times;</div>
            <div class="modal-lines-top"></div>
            <video id="welcomeVideo" width="100%" height="100%" autoplay loop playsinline preload="auto">
                <source src="/api/video/welcome" type="video/webm">
                Your browser does not support the video tag.
            </video>
            <div class="modal-lines-bottom"></div>
        </div>
    </div>

    <style>
        .welcome-modal {
            display: none;
            position: fixed;
            z-index: 10000;
            left: 0;
            top: 0;
            width: 100%;
            height: 100%;
            background-color: rgba(0, 0, 0, 0.9);
        }

        .welcome-modal-content {
            position: relative;
            margin: 10% auto;
            width: 60%;
            height: 60%;
            background: #000;
            border: 2px solid #00ffff;
            border-radius: 20px;
            box-shadow: 0 0 50px rgba(0, 255, 255, 0.8);
            padding: 20px;
        }

        .modal-close {
            position: absolute;
            top: 10px;
            right: 20px;
            color: #00ffff;
            font-size: 40px;
            font-weight: bold;
            cursor: pointer;
            z-index: 10001;
            text-shadow: 0 0 10px rgba(0, 255, 255, 0.8);
        }

        .modal-close:hover {
            color: #ffffff;
            text-shadow: 0 0 20px rgba(255, 255, 255, 1);
        }

        .modal-lines-top, .modal-lines-bottom {
            position: absolute;
            left: 10px;
            right: 10px;
            height: 6px;
            background: linear-gradient(90deg, 
                transparent, 
                #00ffff, 
                #00ff00, 
                #ffff00, 
                #ff00ff, 
                #00ffff, 
                transparent);
            animation: rainbow-slide 3s ease-in-out infinite;
            box-shadow: 0 0 20px rgba(0, 255, 255, 0.8);
            z-index: 10002;
        }

        .modal-lines-top {
            top: 20px;
            border-radius: 4px;
        }

        .modal-lines-bottom {
            bottom: 20px;
            border-radius: 4px;
            animation-delay: 1.5s;
        }

        @keyframes rainbow-slide {
            0%, 100% { 
                background: linear-gradient(90deg, 
                    transparent, 
                    #00ffff, 
                    #00ff00, 
                    #ffff00, 
                    #ff00ff, 
                    #00ffff, 
                    transparent);
            }
            25% { 
                background: linear-gradient(90deg, 
                    transparent, 
                    #ff00ff, 
                    #00ffff, 
                    #00ff00, 
                    #ffff00, 
                    #ff00ff, 
                    transparent);
            }
            50% { 
                background: linear-gradient(90deg, 
                    transparent, 
                    #ffff00, 
                    #ff00ff, 
                    #00ffff, 
                    #00ff00, 
                    #ffff00, 
                    transparent);
            }
            75% { 
                background: linear-gradient(90deg, 
                    transparent, 
                    #00ff00, 
                    #ffff00, 
                    #ff00ff, 
                    #00ffff, 
                    #00ff00, 
                    transparent);
            }
        }

        #welcomeVideo {
            width: 100%;
            height: calc(100% - 80px);
            object-fit: contain;
            border-radius: 15px;
            margin-top: 30px;
            margin-bottom: 30px;
            background: #000;
        }

    </style>

    <script>
        // Function to start welcome video with sound
        function startWelcomeVideo(isPageReload = false) {
            console.log(' startWelcomeVideo called - isPageReload:', isPageReload);
            const video = document.getElementById('welcomeVideo');
            if (!video) {
                console.error(' Video element not found');
                return;
            }
            
            console.log(' Video element found - implementing sound-enabled autoplay');
            
            // Reset video state
            video.currentTime = 0;
            video.volume = 1.0;
            video.loop = true;
            
            // Start with muted autoplay (guaranteed to work)
            video.muted = true;
            video.autoplay = true;
            
            // Load and start video muted
            video.load();
            
            console.log(' Starting muted autoplay first, then enabling sound...');
            video.play().then(function() {
                console.log(' Video started (muted) - now enabling sound interaction');
                
                // Add one-time click listener to enable sound
                const enableSoundOnClick = function(e) {
                    console.log(' User clicked - enabling sound now!');
                    
                    // Remove this listener
                    video.removeEventListener('click', enableSoundOnClick);
                    
                    // Enable sound
                    video.muted = false;
                    video.volume = 1.0;
                    
                    console.log(' Sound ENABLED - video now playing with audio');
                    console.log('Final state - paused:', video.paused, 'muted:', video.muted, 'volume:', video.volume);
                };
                
                // Add click listener to video itself
                video.addEventListener('click', enableSoundOnClick);
                
                // Try to enable sound immediately - should work consistently for both login and reload
                setTimeout(function() {
                    console.log(' Attempting to enable sound automatically after muted start...');
                    console.log('Current scenario: isPageReload =', isPageReload);
                    
                    // Try to unmute regardless of scenario
                    video.muted = false;
                    video.volume = 1.0;
                    
                    // Check if browser allowed it
                    setTimeout(function() {
                        if (video.paused) {
                            console.log(' Browser blocked unmuted audio - reverting to muted with click option');
                            video.muted = true;
                            video.play().then(() => {
                                console.log(' Resumed muted playback - click video to enable sound');
                            });
                        } else {
                            console.log(' Sound automatically enabled - removing click listener');
                            video.removeEventListener('click', enableSoundOnClick);
                            console.log('Final state - paused:', video.paused, 'muted:', video.muted, 'volume:', video.volume);
                        }
                    }, 100);
                }, 200);
                
            }).catch(function(error) {
                console.error(' Video autoplay failed:', error.message);
            });
        }

        // Welcome video modal is now triggered by checkAuthentication() function

        // Video modal is now handled by checkAuthentication() function only

        function closeWelcomeModal() {
            const video = document.getElementById('welcomeVideo');
            video.pause();
            video.currentTime = 0;
            document.getElementById('welcomeModal').style.display = 'none';
        }

        // Close modal when clicking outside
        window.addEventListener('click', function(event) {
            const modal = document.getElementById('welcomeModal');
            if (event.target === modal) {
                closeWelcomeModal();
            }
        });
    </script>

</body>
</html>
